<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><style>/* Isabelle fonts */

@font-face {
  font-family: 'Isabelle DejaVu Sans';
  src: url('../../fonts/IsabelleDejaVuSans.ttf') format('truetype');
}

@font-face {
  font-family: 'Isabelle DejaVu Sans';
  src: url('../../fonts/IsabelleDejaVuSans-Bold.ttf') format('truetype');
  font-weight: bold;
}

@font-face {
  font-family: 'Isabelle DejaVu Sans';
  src: url('../../fonts/IsabelleDejaVuSans-Oblique.ttf') format('truetype');
  font-style: italic;
}

@font-face {
  font-family: 'Isabelle DejaVu Sans';
  src: url('../../fonts/IsabelleDejaVuSans-BoldOblique.ttf') format('truetype');
  font-weight: bold;
  font-style: italic;
}

@font-face {
  font-family: 'Isabelle DejaVu Sans Mono';
  src: url('../../fonts/IsabelleDejaVuSansMono.ttf') format('truetype');
}

@font-face {
  font-family: 'Isabelle DejaVu Sans Mono';
  src: url('../../fonts/IsabelleDejaVuSansMono-Bold.ttf') format('truetype');
  font-weight: bold;
}

@font-face {
  font-family: 'Isabelle DejaVu Sans Mono';
  src: url('../../fonts/IsabelleDejaVuSansMono-Oblique.ttf') format('truetype');
  font-style: italic;
}

@font-face {
  font-family: 'Isabelle DejaVu Sans Mono';
  src: url('../../fonts/IsabelleDejaVuSansMono-BoldOblique.ttf') format('truetype');
  font-weight: bold;
  font-style: italic;
}

@font-face {
  font-family: 'Isabelle DejaVu Serif';
  src: url('../../fonts/IsabelleDejaVuSerif.ttf') format('truetype');
}

@font-face {
  font-family: 'Isabelle DejaVu Serif';
  src: url('../../fonts/IsabelleDejaVuSerif-Bold.ttf') format('truetype');
  font-weight: bold;
}

@font-face {
  font-family: 'Isabelle DejaVu Serif';
  src: url('../../fonts/IsabelleDejaVuSerif-Italic.ttf') format('truetype');
  font-style: italic;
}

@font-face {
  font-family: 'Isabelle DejaVu Serif';
  src: url('../../fonts/IsabelleDejaVuSerif-BoldItalic.ttf') format('truetype');
  font-weight: bold;
  font-style: italic;
}

@font-face {
  font-family: 'Vacuous';
  src: url('../../fonts/Vacuous.ttf') format('truetype');
}


/* standard document markup */

dt {
  float: left;
  clear: left;
  padding-right: 0.5em;
  font-weight: bold;
}

body {
  color: #000000;
  background-color: #FFFFFF;
}

.head     { background-color: #FFFFFF; }
.source   {
  direction: ltr; unicode-bidi: bidi-override;
  background-color: #FFFFFF;
  padding: 10px;
  font-family: "Isabelle DejaVu Sans Mono", monospace;
}

.theories { background-color: #FFFFFF; padding: 10px; }
.sessions { background-color: #FFFFFF; padding: 10px; }
.document { white-space: normal; font-family: "Isabelle DejaVu Serif", serif; }

.name     { font-style: italic; }
.filename { font-family: "Isabelle DejaVu Sans Mono", monospace; }


/* basic syntax markup */

.hidden         { font-family: Vacuous; font-size: 1%; color: rgba(255,255,255,0); }
.control        { font-weight: bold; font-style: italic; }

.binding        { color: #336655; }
.tfree          { color: #A020F0; }
.tvar           { color: #A020F0; }
.free           { color: #0000FF; }
.skolem         { color: #D2691E; }
.bound          { color: #008000; }
.var            { color: #00009B; }
.numeral        { }
.literal        { font-weight: bold; }
.delimiter      { }
.inner_numeral  { color: #FF0000; }
.inner_quoted   { color: #FF00CC; }
.inner_cartouche { color: #CC6600; }
.comment1       { color: #CC0000; }
.comment2       { color: #FF8400; }
.comment3       { color: #6600CC; }
.dynamic        { color: #7BA428; }
.class_parameter_color { color: #D2691E; }

.bold           { font-weight: bold; }

.main           { color: #000000; }
.command        { font-weight: bold; }
.keyword        { font-weight: bold; }
.keyword1       { color: #006699; }
.keyword2       { color: #009966; }
.keyword3       { color: #0099FF; }
.quasi_keyword  { color: #9966FF; }
.operator       { color: #323232; }
.string         { color: #FF00CC; }
.alt_string     { color: #CC00CC; }
.verbatim       { color: #6600CC; }
.cartouche      { color: #CC6600; }
.comment        { color: #CC0000; }
.improper       { color: #FF5050; }
.antiquote      { color: #6600CC; }
.raw_text       { color: #6600CC; }
.plain_text     { color: #CC6600; }
.bad            { background-color: #FF6A6A; }
.quoted         { background-color: rgba(139,139,139,0.05); }
.antiquoted     { background-color: rgba(255,200,50,0.1); }


/* message background */

.writeln_message      { background-color: #F0F0F0; }
.information_message  { background-color: #DCEAF3; }
.tracing_message      { background-color: #F0F8FF; }
.warning_message      { background-color: #EEE8AA; }
.legacy_message       { background-color: #EEE8AA; }
.error_message        { background-color: #FFC1C1; }


/* message underline */

.writeln { border-bottom: 1px dotted #C0C0C0; }
.information { border-bottom: 1px dotted #C1DFEE; }
.warning { border-bottom: 1px dotted #FF8C00; }
.legacy { border-bottom: 1px dotted #FF8C00; }
.error { border-bottom: 1px dotted #B22222; }


/* tooltips */

.writeln { position: relative; display: inline-block; }
.information { position: relative; display: inline-block; }
.warning { position: relative; display: inline-block; }
.legacy { position: relative; display: inline-block; }
.error { position: relative; display: inline-block; }

.writeln:hover .tooltip { visibility: visible; }
.information:hover .tooltip { visibility: visible; }
.warning:hover .tooltip { visibility: visible; }
.legacy:hover .tooltip { visibility: visible; }
.error:hover .tooltip { visibility: visible; }

.tooltip {
  top: -0.5ex;
  left: 5em;
  visibility: hidden;
  width: 50em;
  border: 1px solid #808080;
  padding: 1px 1px;
  background-color: #FFFFE9;
  position: absolute;
  z-index: 1;
}

.tooltip pre { margin: 1px; white-space: pre-wrap; }
</style>
<title>Theory "bus_verify_impl"</title>
</head>
<body><pre class="source"><span class="keyword1"><span class="command">theory</span></span> bus_verify_impl

<span class="keyword2"><span class="keyword">imports</span></span> plugin_verify_impl
  <span class="quoted">"../des/des_bus"</span>
  <span class="quoted">"../impl/thy/bus"</span>

<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹bus axiomatization ›</span></span></span>
<span class="keyword1"><span class="command">axiomatization</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> noFail_whileLoop <span class="main">:</span> 
     <span class="quoted"><span class="quoted"><span class="language">"no_fail <span class="free">P</span> <span class="main">(</span><span class="free">B</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> no_fail <span class="free">P</span> <span class="main">(</span>whileLoop <span class="free">C</span> <span class="free">B</span> <span class="free">r</span><span class="main">)</span>"</span></span></span>

<span class="keyword1"><span class="command">axiomatization</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> noFail_whileLoopE <span class="main">:</span> 
     <span class="quoted"><span class="quoted"><span class="language">"no_fail <span class="free">P</span> <span class="main">(</span><span class="free">B</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> no_fail <span class="free">P</span> <span class="main">(</span>whileLoopE <span class="free">C</span> <span class="free">B</span> <span class="free">r</span><span class="main">)</span>"</span></span></span>

<span class="keyword1"><span class="command">axiomatization</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> actorPluginInfo_valid<span class="main">:</span>
    <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">apil</span> <span class="bound">api</span> <span class="bound">s</span><span class="main">.</span> actorPluginInfoEqual <span class="bound">apil</span> <span class="bound">api</span> <span class="bound">s</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">and</span></span> pluginInfo_valid<span class="main">:</span>
    <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span> <span class="bound">apia</span><span class="main">.</span> is_valid_PluginInfo_C <span class="bound">s</span>
          <span class="main">(</span>PluginInfoVector_C.data_C
            <span class="main">(</span>heap_PluginInfoVector_C <span class="bound">s</span>
              <span class="main">(</span>plugins_C <span class="main">(</span>heap_TaskInfo_C <span class="bound">s</span> <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>TaskInfo_C<span class="main">)</span> <span class="main">&amp;(</span><span class="bound">apia</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''taskInfo_C''</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span></span>

<span class="keyword1"><span class="command">axiomatization</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> zero_axi<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">0</span> <span class="main">≤</span> <span class="numeral">2147483649</span> <span class="main">+</span> <span class="main">0</span> <span class="main">∧</span> <span class="main">0</span> <span class="main">≤</span> <span class="numeral">2147483646</span>"</span></span></span>

<span class="keyword1"><span class="command">axiomatization</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> non_fail_super<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"no_fail <span class="free">P</span> <span class="free">m</span>"</span></span></span>

<span class="keyword1"><span class="command">axiomatization</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> Impl_loadPluginInfoList_super<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">P</span> <span class="bound">Q</span> <span class="bound">setResult</span> <span class="bound">anBus</span> <span class="bound">param</span> <span class="bound">anActor</span><span class="main">.</span>
       <span class="main">⦃</span><span class="bound">P</span><span class="main">⦄</span> Impl_loadPluginInfoList <span class="bound">setResult</span> <span class="bound">anBus</span> <span class="bound">param</span> <span class="bound">anActor</span> <span class="main">⦃</span><span class="bound">Q</span><span class="main">⦄</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">and</span></span> Impl_updateActorPluginState_super<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">P</span> <span class="bound">Q</span> <span class="bound">busPtr</span> <span class="bound">anActorPtr</span> <span class="bound">anImplState</span><span class="main">.</span>
       <span class="main">⦃</span><span class="bound">P</span><span class="main">⦄</span> Impl_updateActorPluginState <span class="bound">busPtr</span> <span class="bound">anActorPtr</span> <span class="bound">anImplState</span> <span class="main">⦃</span><span class="bound">Q</span><span class="main">⦄</span>"</span></span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹data structure aux›</span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹bus valid›</span></span></span>

<span class="keyword1"><span class="command">definition</span></span> pluginOwner_valid <span class="main">::</span> <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C ptr <span class="main">⇒</span> lifted_globals <span class="main">⇒</span> bool"</span></span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">pluginOwner_valid</span> <span class="free"><span class="bound">busPtr</span></span> <span class="free"><span class="bound">s</span></span> <span class="main">≡</span> 
                 <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">.</span>
                 <span class="main">0</span> <span class="main">≤</span> <span class="bound">r</span> <span class="main">∧</span> <span class="bound">r</span> <span class="main">&lt;</span> <span class="numeral">128</span> <span class="main">∧</span> is_valid_GeneralBus_C <span class="free"><span class="bound">s</span></span> <span class="free"><span class="bound">busPtr</span></span> <span class="main">⟶</span>
                 is_valid_w64 <span class="free"><span class="bound">s</span></span> <span class="main">(</span><span class="keyword1">PTR_COERCE</span><span class="main">(</span><span class="numeral">64</span> signed word <span class="main">→</span> <span class="numeral">64</span> word<span class="main">)</span> <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span><span class="numeral">64</span> signed word<span class="main">)</span> <span class="main">&amp;(</span><span class="free"><span class="bound">busPtr</span></span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginOwner_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>
                 <span class="main">)</span>"</span></span></span>
<span class="keyword1"><span class="command">definition</span></span> pluginName_valid <span class="main">::</span> <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C ptr <span class="main">⇒</span> lifted_globals <span class="main">⇒</span> bool"</span></span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">pluginName_valid</span> <span class="free"><span class="bound">busPtr</span></span> <span class="free"><span class="bound">s</span></span> <span class="main">≡</span> 
                 <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">.</span>
                 <span class="main">0</span> <span class="main">≤</span> <span class="bound">r</span> <span class="main">∧</span> <span class="bound">r</span> <span class="main">&lt;</span> <span class="numeral">128</span> <span class="main">∧</span> is_valid_GeneralBus_C <span class="free"><span class="bound">s</span></span> <span class="free"><span class="bound">busPtr</span></span> <span class="main">⟶</span>
                 is_valid_w8'ptr <span class="free"><span class="bound">s</span></span> <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span><span class="numeral">8</span> word ptr<span class="main">)</span> <span class="main">&amp;(</span><span class="free"><span class="bound">busPtr</span></span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginName_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="bound">r</span><span class="main">)</span>
                 <span class="main">)</span>"</span></span></span>
<span class="keyword1"><span class="command">definition</span></span> pluginList_valid <span class="main">::</span> <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C ptr <span class="main">⇒</span> lifted_globals <span class="main">⇒</span> bool"</span></span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">pluginList_valid</span> <span class="free"><span class="bound">busPtr</span></span> <span class="free"><span class="bound">s</span></span> <span class="main">≡</span> 
                 <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">.</span>
                 <span class="main">0</span> <span class="main">≤</span> <span class="bound">r</span> <span class="main">∧</span> <span class="bound">r</span> <span class="main">&lt;</span> <span class="numeral">128</span>
                 <span class="main">∧</span> is_valid_GeneralBus_C <span class="free"><span class="bound">s</span></span> <span class="free"><span class="bound">busPtr</span></span> <span class="main">⟶</span>
                 is_valid_GeneralPlugin_C <span class="free"><span class="bound">s</span></span> <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free"><span class="bound">busPtr</span></span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span></span>

<span class="keyword1"><span class="command">definition</span></span> bus_valid <span class="main">::</span> <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C ptr <span class="main">⇒</span> lifted_globals <span class="main">⇒</span> bool"</span></span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">bus_valid</span> <span class="free"><span class="bound">busPtr</span></span> <span class="free"><span class="bound">s</span></span> <span class="main">≡</span> <span class="main">0</span> <span class="main">≤</span> sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="free"><span class="bound">s</span></span> <span class="free"><span class="bound">busPtr</span></span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
            sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="free"><span class="bound">s</span></span> <span class="free"><span class="bound">busPtr</span></span><span class="main">)</span><span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">128</span> 
              <span class="main">∧</span> is_valid_GeneralBus_C <span class="free"><span class="bound">s</span></span> <span class="free"><span class="bound">busPtr</span></span> <span class="main">∧</span> pluginOwner_valid <span class="free"><span class="bound">busPtr</span></span> <span class="free"><span class="bound">s</span></span> 
              <span class="main">∧</span> pluginList_valid <span class="free"><span class="bound">busPtr</span></span> <span class="free"><span class="bound">s</span></span>  <span class="main">∧</span> pluginName_valid <span class="free"><span class="bound">busPtr</span></span> <span class="free"><span class="bound">s</span></span> 
              <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">∈</span> set <span class="main">(</span>array_addrs <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span><span class="numeral">64</span> signed word<span class="main">)</span> <span class="main">&amp;(</span><span class="free"><span class="bound">busPtr</span></span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginOwner_C''</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="numeral">128</span><span class="main">)</span><span class="main">.</span>is_valid_w64 <span class="free"><span class="bound">s</span></span> <span class="main">(</span><span class="keyword1">PTR_COERCE</span><span class="main">(</span><span class="numeral">64</span> signed word <span class="main">→</span> <span class="numeral">64</span> word<span class="main">)</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span>
              <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span> <span class="main">∈</span> set <span class="main">(</span>array_addrs <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span><span class="numeral">8</span> word ptr<span class="main">)</span> <span class="main">&amp;(</span><span class="free"><span class="bound">busPtr</span></span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginName_C''</span><span class="main">]</span><span class="main">)</span><span class="main">)</span> <span class="numeral">128</span><span class="main">)</span><span class="main">.</span> is_valid_w8'ptr <span class="free"><span class="bound">s</span></span> <span class="bound">a</span><span class="main">)</span>
              <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">w8ptr</span> <span class="bound">ptrLen</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>set <span class="main">(</span>array_addrs <span class="bound">w8ptr</span> <span class="bound">ptrLen</span><span class="main">)</span><span class="main">.</span> is_valid_w8'ptr <span class="free"><span class="bound">s</span></span> <span class="bound">a</span><span class="main">)</span> <span class="main">⟶</span> 
                      <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">a</span></span> <span class="main">&lt;</span> int <span class="bound">ptrLen</span><span class="main">.</span> is_valid_w8'ptr <span class="free"><span class="bound">s</span></span> <span class="main">(</span><span class="bound">w8ptr</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="main">)</span>
              <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">w64ptr</span> <span class="bound">ptrLen</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">a</span><span class="main">∈</span>set <span class="main">(</span>array_addrs <span class="bound">w64ptr</span> <span class="bound">ptrLen</span><span class="main">)</span><span class="main">.</span> is_valid_w64 <span class="free"><span class="bound">s</span></span> <span class="main">(</span><span class="keyword1">PTR_COERCE</span><span class="main">(</span><span class="numeral">64</span> signed word <span class="main">→</span> <span class="numeral">64</span> word<span class="main">)</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> 
                      <span class="main">(</span><span class="main">∀</span><span class="bound"><span class="bound">a</span></span> <span class="main">&lt;</span> int <span class="bound">ptrLen</span><span class="main">.</span> is_valid_w64 <span class="free"><span class="bound">s</span></span> <span class="main">(</span><span class="keyword1">PTR_COERCE</span><span class="main">(</span><span class="numeral">64</span> signed word <span class="main">→</span> <span class="numeral">64</span> word<span class="main">)</span>   <span class="main">(</span><span class="bound">w64ptr</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">)</span>
              "</span></span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹update aux›</span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusPluginOwner_C_update1<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"<span class="free">po</span> <span class="main">=</span> GeneralBus_C.pluginOwner_C <span class="main">(</span>GeneralBus_C.pluginOwner_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">po</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust pluginOwner_C.simps pluginOwner_C_update.simps<span class="main">)</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> BusPluginOwner_C_update2<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.pluginName_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.pluginName_C <span class="main">(</span>GeneralBus_C.pluginOwner_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">po</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust pluginName_C.simps pluginOwner_C_update.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusPluginOwner_C_update3<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.nRegisteredPlugin_C <span class="main">(</span>GeneralBus_C.pluginOwner_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">po</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust nRegisteredPlugin_C.simps pluginOwner_C_update.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusPluginOwner_C_update4<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.pluginList_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.pluginList_C <span class="main">(</span>GeneralBus_C.pluginOwner_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">po</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust pluginList_C.simps pluginOwner_C_update.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusPluginOwner_C_update5<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.name_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.name_C <span class="main">(</span>GeneralBus_C.pluginOwner_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">po</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust name_C.simps pluginOwner_C_update.simps<span class="main">)</span></span>


<span class="keyword1"><span class="command">lemma</span></span> BusPluginName_C_update1<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"<span class="free">pn</span> <span class="main">=</span> GeneralBus_C.pluginName_C <span class="main">(</span>GeneralBus_C.pluginName_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">pn</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust pluginName_C.simps pluginName_C_update.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusPluginName_C_update2<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.pluginOwner_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.pluginOwner_C <span class="main">(</span>GeneralBus_C.pluginName_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">pn</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust pluginName_C_update.simps pluginOwner_C.simps<span class="main">)</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> BusPluginName_C_update3<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.nRegisteredPlugin_C <span class="main">(</span>GeneralBus_C.pluginName_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">pn</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust pluginName_C_update.simps nRegisteredPlugin_C.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusPluginName_C_update4<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.pluginList_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.pluginList_C <span class="main">(</span>GeneralBus_C.pluginName_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">pn</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust pluginName_C_update.simps pluginList_C.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusPluginName_C_update5<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.name_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.name_C <span class="main">(</span>GeneralBus_C.pluginName_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">pn</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust pluginName_C_update.simps name_C.simps<span class="main">)</span></span>


<span class="keyword1"><span class="command">lemma</span></span> BusNRegisteredPlugin_C_update1<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">" GeneralBus_C.nRegisteredPlugin_C <span class="main">(</span>GeneralBus_C.nRegisteredPlugin_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">nrp</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">nrp</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust nRegisteredPlugin_C.simps nRegisteredPlugin_C_update.simps<span class="main">)</span></span>
  
<span class="keyword1"><span class="command">lemma</span></span> BusNRegisteredPlugin_C_update2<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.pluginOwner_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.pluginOwner_C <span class="main">(</span>GeneralBus_C.nRegisteredPlugin_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">nrp</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust nRegisteredPlugin_C_update.simps pluginOwner_C.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusNRegisteredPlugin_C_update3<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.pluginName_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.pluginName_C <span class="main">(</span>GeneralBus_C.nRegisteredPlugin_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">nrp</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust nRegisteredPlugin_C_update.simps pluginName_C.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusNRegisteredPlugin_C_update4<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.pluginList_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.pluginList_C <span class="main">(</span>GeneralBus_C.nRegisteredPlugin_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">nrp</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust nRegisteredPlugin_C_update.simps pluginList_C.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusNRegisteredPlugin_C_update5<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.name_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.name_C <span class="main">(</span>GeneralBus_C.nRegisteredPlugin_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">nrp</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust nRegisteredPlugin_C_update.simps name_C.simps<span class="main">)</span></span>


<span class="keyword1"><span class="command">lemma</span></span> BusPluginList_C_update1<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"<span class="free">pl</span> <span class="main">=</span> GeneralBus_C.pluginList_C <span class="main">(</span>GeneralBus_C.pluginList_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">pl</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust pluginList_C.simps pluginList_C_update.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusPluginList_C_update2<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.pluginOwner_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.pluginOwner_C <span class="main">(</span>GeneralBus_C.pluginList_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">pl</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust pluginList_C_update.simps pluginOwner_C.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusPluginList_C_update3<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.pluginName_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.pluginName_C <span class="main">(</span>GeneralBus_C.pluginList_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">pl</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust pluginList_C_update.simps pluginName_C.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusPluginList_C_update4<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.nRegisteredPlugin_C <span class="main">(</span>GeneralBus_C.pluginList_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">pl</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust pluginList_C_update.simps nRegisteredPlugin_C.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusPluginList_C_update5<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.name_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.name_C <span class="main">(</span>GeneralBus_C.pluginList_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">pl</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust pluginList_C_update.simps name_C.simps<span class="main">)</span></span>


<span class="keyword1"><span class="command">lemma</span></span> BusName_C_update1<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"<span class="free">na</span> <span class="main">=</span> GeneralBus_C.name_C <span class="main">(</span>GeneralBus_C.name_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">na</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust name_C.simps name_C_update.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusName_C_update2<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.pluginOwner_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.pluginOwner_C <span class="main">(</span>GeneralBus_C.name_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">na</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust name_C_update.simps pluginOwner_C.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusName_C_update3<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.pluginName_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.pluginName_C <span class="main">(</span>GeneralBus_C.name_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">na</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust name_C_update.simps pluginName_C.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusName_C_update4<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.nRegisteredPlugin_C <span class="main">(</span>GeneralBus_C.name_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">na</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust name_C_update.simps nRegisteredPlugin_C.simps<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> BusName_C_update5<span class="main">[</span><span class="language"><span class="operator">simp</span></span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"GeneralBus_C.pluginList_C <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span> <span class="main">=</span> GeneralBus_C.pluginList_C <span class="main">(</span>GeneralBus_C.name_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">na</span><span class="main">)</span> <span class="main">(</span>heap_GeneralBus_C <span class="free">s</span> <span class="free">busC</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="language"><span class="free">busC</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust name_C_update.simps pluginList_C.simps<span class="main">)</span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹lemma aux›</span></span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹corres aux›</span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> corres_underlying_split_r<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ac<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">s</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r'</span> <span class="free">G</span> <span class="free">G'</span> <span class="free">a</span> <span class="free">c</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> valid<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⦃</span><span class="free">G</span><span class="main">⦄</span> <span class="free">a</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span>"</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⦃</span><span class="free">G'</span><span class="main">⦄</span> <span class="free">c</span> <span class="main">⦃</span><span class="free">P'</span><span class="main">⦄</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bd<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">rv</span> <span class="bound">rv'</span><span class="main">.</span> <span class="free">r'</span> <span class="bound">rv</span> <span class="bound">rv'</span> <span class="main">⟶</span>
                        corres_underlying <span class="free">s</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="main">(</span><span class="free">P</span> <span class="bound">rv</span><span class="main">)</span> <span class="main">(</span><span class="free">P'</span> <span class="bound">rv'</span><span class="main">)</span> <span class="main">(</span>return <span class="bound">rv</span><span class="main">)</span> <span class="main">(</span><span class="free">d</span> <span class="bound">rv'</span><span class="main">)</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">s</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">G</span> <span class="free">G'</span> <span class="free">a</span> <span class="main">(</span><span class="free">c</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">rv'</span><span class="main">.</span> <span class="free">d</span> <span class="bound">rv'</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command">using</span></span> corres_underlying_split<span class="main">[</span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> b <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted"><span class="language">"return"</span></span></span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> ac bd valid
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">smt</span> corres_bind_return corres_split'<span class="main">)</span></span> 

<span class="keyword1"><span class="command">lemma</span></span> corres_underlying_split_l<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ac<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">s</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r'</span> <span class="free">G</span> <span class="free">G'</span> <span class="free">a</span> <span class="free">c</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> valid<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⦃</span><span class="free">G</span><span class="main">⦄</span> <span class="free">a</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span>"</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⦃</span><span class="free">G'</span><span class="main">⦄</span> <span class="free">c</span> <span class="main">⦃</span><span class="free">P'</span><span class="main">⦄</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bd<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">rv</span> <span class="bound">rv'</span><span class="main">.</span> <span class="free">r'</span> <span class="bound">rv</span> <span class="bound">rv'</span> <span class="main">⟶</span>
                        corres_underlying <span class="free">s</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="main">(</span><span class="free">P</span> <span class="bound">rv</span><span class="main">)</span> <span class="main">(</span><span class="free">P'</span> <span class="bound">rv'</span><span class="main">)</span> <span class="main">(</span><span class="free">b</span> <span class="bound">rv</span><span class="main">)</span> <span class="main">(</span>return <span class="bound">rv'</span><span class="main">)</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">s</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">G</span> <span class="free">G'</span> <span class="main">(</span><span class="free">a</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">rv'</span><span class="main">.</span> <span class="free">b</span> <span class="bound">rv'</span><span class="main">)</span><span class="main">)</span> <span class="free">c</span>"</span></span></span>
  <span class="keyword1"><span class="command">using</span></span> corres_underlying_split<span class="main">[</span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> d <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted"><span class="language">"return"</span></span></span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> ac bd valid
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">smt</span> corres_bind_return2 corres_underlying_split<span class="main">)</span></span>


<span class="keyword1"><span class="command">lemma</span></span> corres_underlying_split_r_ret<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ac<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">s</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r'</span> <span class="free">G</span> <span class="free">G'</span> <span class="main">(</span> return<span class="main">()</span> <span class="main">)</span> <span class="free">c</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> valid<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⦃</span><span class="free">G</span><span class="main">⦄</span> return <span class="main">()</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span>"</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⦃</span><span class="free">G'</span><span class="main">⦄</span> <span class="free">c</span> <span class="main">⦃</span><span class="free">P'</span><span class="main">⦄</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bd<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">rv</span> <span class="bound">rv'</span><span class="main">.</span> <span class="free">r'</span> <span class="bound">rv</span> <span class="bound">rv'</span> <span class="main">⟶</span>
                        corres_underlying <span class="free">s</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="main">(</span><span class="free">P</span> <span class="bound">rv</span><span class="main">)</span> <span class="main">(</span><span class="free">P'</span> <span class="bound">rv'</span><span class="main">)</span> <span class="free">b</span> <span class="main">(</span><span class="free">d</span> <span class="bound">rv'</span><span class="main">)</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">s</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">G</span> <span class="free">G'</span> <span class="free">b</span> <span class="main">(</span><span class="free">c</span> <span class="main">&gt;&gt;=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">rv'</span><span class="main">.</span> <span class="free">d</span> <span class="bound">rv'</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command">using</span></span> corres_underlying_split<span class="main">[</span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> a <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted"><span class="language">"return <span class="main">()</span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> b <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">b</span>"</span></span></span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">using</span></span> ac bd valid
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> corres_add_noop_lhs<span class="main">)</span></span>
  

<span class="keyword1"><span class="command">lemma</span></span> corres_if_simple<span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⟦</span> <span class="main">∀</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">sr</span><span class="main">.</span> <span class="free">P</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">P'</span> <span class="bound">t</span> <span class="main">⟶</span>  <span class="free">G</span> <span class="main">=</span> <span class="free">G'</span> <span class="main">;</span>
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">a</span> <span class="free">c</span><span class="main">;</span> 
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">b</span> <span class="free">d</span> <span class="main">⟧</span> <span class="main">⟹</span>
    corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span>
      <span class="free">P</span>  <span class="free">P'</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">G</span> <span class="keyword1">then</span> <span class="free">a</span> <span class="keyword1">else</span> <span class="free">b</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">G'</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="keyword1">else</span> <span class="free">d</span><span class="main">)</span>"</span></span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span>  corres_underlying_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">simp</span></span>   <span class="keyword1"><span class="command">unfolding</span></span> case_prod_unfold
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span> 

<span class="keyword1"><span class="command">lemma</span></span> corres_if_simple_pre<span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⟦</span> <span class="main">∀</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">sr</span><span class="main">.</span> <span class="free">P</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">P'</span> <span class="bound">t</span> <span class="main">⟶</span>  <span class="free">G</span> <span class="main">=</span> <span class="free">G'</span> <span class="main">;</span>
     <span class="free">G</span> <span class="main">∧</span> <span class="free">G'</span> <span class="main">⟶</span> corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">a</span> <span class="free">c</span><span class="main">;</span> 
     <span class="main">¬</span><span class="main">(</span><span class="free">G</span> <span class="main">∧</span> <span class="free">G'</span><span class="main">)</span> <span class="main">⟶</span> corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">b</span> <span class="free">d</span> <span class="main">⟧</span> <span class="main">⟹</span>
    corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span>
      <span class="free">P</span>  <span class="free">P'</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">G</span> <span class="keyword1">then</span> <span class="free">a</span> <span class="keyword1">else</span> <span class="free">b</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">G'</span> <span class="keyword1">then</span> <span class="free">c</span> <span class="keyword1">else</span> <span class="free">d</span><span class="main">)</span>"</span></span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span>  corres_underlying_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">simp</span></span>   <span class="keyword1"><span class="command">unfolding</span></span> case_prod_unfold
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>


<span class="keyword1"><span class="command">lemma</span></span> corres_if_condition <span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⟦</span> <span class="main">∀</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">sr</span><span class="main">.</span> <span class="free">P</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">P'</span> <span class="bound">t</span> <span class="main">⟶</span>  <span class="free">G</span> <span class="main">=</span> <span class="free">G'</span> <span class="bound">t</span> <span class="main">;</span>
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">a</span> <span class="free">c</span><span class="main">;</span> 
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">b</span> <span class="free">d</span> <span class="main">⟧</span> <span class="main">⟹</span>
  corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span>
      <span class="free">P</span>  <span class="free">P'</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">G</span> <span class="keyword1">then</span> <span class="free">a</span> <span class="keyword1">else</span> <span class="free">b</span><span class="main">)</span> <span class="main">(</span>condition <span class="free">G'</span> <span class="free">c</span>  <span class="free">d</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>  corres_underlying_def condition_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">simp</span></span>  <span class="keyword1"><span class="command">unfolding</span></span> case_prod_unfold
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>

<span class="keyword1"><span class="command">lemma</span></span> corres_if_condition_pre <span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⟦</span> <span class="main">∀</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">sr</span><span class="main">.</span> <span class="free">P</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">P'</span> <span class="bound">t</span> <span class="main">⟶</span>  <span class="free">G</span> <span class="main">=</span> <span class="free">G'</span> <span class="bound">t</span> <span class="main">;</span>
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="main">(</span><span class="free">P'</span> <span class="keyword1">and</span> <span class="free">G'</span><span class="main">)</span> <span class="free">a</span> <span class="free">c</span><span class="main">;</span> 
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">P'</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span><span class="free">G'</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="free">b</span> <span class="free">d</span> <span class="main">⟧</span> <span class="main">⟹</span>
  corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span>
      <span class="free">P</span>  <span class="free">P'</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">G</span> <span class="keyword1">then</span> <span class="free">a</span> <span class="keyword1">else</span> <span class="free">b</span><span class="main">)</span> <span class="main">(</span>condition <span class="free">G'</span> <span class="free">c</span>  <span class="free">d</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>  corres_underlying_def condition_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">simp</span></span>  <span class="keyword1"><span class="command">unfolding</span></span> case_prod_unfold
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>

<span class="keyword1"><span class="command">lemma</span></span> corres_if_condition_pre2 <span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⟦</span> <span class="main">∀</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">sr</span><span class="main">.</span> <span class="free">P</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">P'</span> <span class="bound">t</span> <span class="main">⟶</span>  <span class="free">G</span> <span class="main">=</span> <span class="free">G'</span> <span class="bound">t</span> <span class="main">;</span>
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">P</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">G</span><span class="main">)</span> <span class="main">(</span><span class="free">P'</span> <span class="keyword1">and</span> <span class="free">G'</span><span class="main">)</span> <span class="free">a</span> <span class="free">c</span><span class="main">;</span> 
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">P'</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">¬</span><span class="main">(</span><span class="free">G'</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="free">b</span> <span class="free">d</span> <span class="main">⟧</span> <span class="main">⟹</span>
  corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span>
      <span class="free">P</span>  <span class="free">P'</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">G</span> <span class="keyword1">then</span> <span class="free">a</span> <span class="keyword1">else</span> <span class="free">b</span><span class="main">)</span> <span class="main">(</span>condition <span class="free">G'</span> <span class="free">c</span>  <span class="free">d</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span>  corres_underlying_def condition_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">simp</span></span>  <span class="keyword1"><span class="command">unfolding</span></span> case_prod_unfold
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>

<span class="keyword1"><span class="command">lemma</span></span> corres_condition_P<span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⟦</span> <span class="main">∀</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">sr</span><span class="main">.</span> <span class="free">P</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">P'</span> <span class="bound">t</span> <span class="main">⟶</span>  <span class="free">G</span> <span class="bound">s</span> <span class="main">=</span> <span class="free">G'</span> <span class="bound">t</span><span class="main">;</span>
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">a</span> <span class="free">c</span><span class="main">;</span> 
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">b</span> <span class="free">d</span> <span class="main">⟧</span> <span class="main">⟹</span>
    corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span>
      <span class="free">P</span>  <span class="free">P'</span>
        <span class="main">(</span>condition <span class="free">G</span> <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="main">(</span>condition <span class="free">G'</span> <span class="free">c</span> <span class="free">d</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> condition_def corres_underlying_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">simp</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> case_prod_unfold
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>

<span class="keyword1"><span class="command">lemma</span></span> corres_condition_P2<span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⟦</span> <span class="main">∀</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">sr</span><span class="main">.</span> <span class="free">P</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">P'</span> <span class="bound">t</span> <span class="main">⟶</span>  <span class="free">G</span> <span class="bound">s</span> <span class="main">=</span> <span class="free">G'</span> <span class="bound">t</span><span class="main">;</span>
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">G</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">G'</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">P'</span> <span class="bound">s</span><span class="main">)</span> <span class="free">a</span> <span class="free">c</span><span class="main">;</span> 
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span><span class="free">G</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">P</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span><span class="free">G'</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">P'</span> <span class="bound">s</span><span class="main">)</span> <span class="free">b</span> <span class="free">d</span> <span class="main">⟧</span> <span class="main">⟹</span>
    corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span>
      <span class="free">P</span>  <span class="free">P'</span>
        <span class="main">(</span>condition <span class="free">G</span> <span class="free">a</span> <span class="free">b</span><span class="main">)</span> <span class="main">(</span>condition <span class="free">G'</span> <span class="free">c</span> <span class="free">d</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> condition_def corres_underlying_def 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">simp</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> case_prod_unfold
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>

<span class="keyword1"><span class="command">lemma</span></span> corres_condition_G <span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⟦</span> <span class="main">∀</span><span class="bound">s</span><span class="main">.</span> <span class="free">P'</span> <span class="bound">s</span> <span class="main">⟶</span> <span class="free">G'</span> <span class="bound">s</span> <span class="main">;</span>
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">a</span> <span class="free">c</span> <span class="main">⟧</span> <span class="main">⟹</span>
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span>  <span class="free">P'</span> <span class="free">a</span> <span class="main">(</span>condition <span class="free">G'</span> <span class="free">c</span>  <span class="free">d</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> condition_def corres_underlying_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">simp</span></span>

<span class="keyword1"><span class="command">lemma</span></span> corres_condition_notG <span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⟦</span> <span class="main">∀</span><span class="bound">s</span><span class="main">.</span> <span class="free">P'</span> <span class="bound">s</span> <span class="main">⟶</span> <span class="main">¬</span><span class="free">G'</span> <span class="bound">s</span> <span class="main">;</span>
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">a</span> <span class="free">d</span> <span class="main">⟧</span> <span class="main">⟹</span>
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span>  <span class="free">P'</span> <span class="free">a</span> <span class="main">(</span>condition <span class="free">G'</span> <span class="free">c</span>  <span class="free">d</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> condition_def corres_underlying_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">simp</span></span> 



<span class="keyword1"><span class="command">lemma</span></span> corres_condition_case <span class="main">:</span> 
<span class="quoted"><span class="quoted"><span class="language">" <span class="main">⟦</span>  <span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">P'</span> <span class="bound">s</span> <span class="main">⟹</span>
     <span class="keyword1">case</span> <span class="free">st</span> <span class="keyword1">of</span>
     actorState.ACTOR_STATE_INIT <span class="main">⇒</span> <span class="free">C1</span> <span class="bound">s</span> <span class="main">|</span> 
      actorState.ACTOR_STATE_RUNNING <span class="main">⇒</span> <span class="main">¬</span> <span class="free">C1</span> <span class="bound">s</span> <span class="main">∧</span>  <span class="free">C2</span> <span class="bound">s</span> <span class="main">|</span>
      actorState.ACTOR_STATE_PAUSE <span class="main">⇒</span><span class="main">¬</span> <span class="free">C1</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">C2</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">C3</span> <span class="bound">s</span><span class="main">|</span> 
      actorState.ACTOR_STATE_FINISH <span class="main">⇒</span><span class="main">¬</span> <span class="free">C1</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">C2</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">C3</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">C4</span> <span class="bound">s</span><span class="main">|</span>
       <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="main">¬</span><span class="main">(</span><span class="free">C1</span> <span class="bound">s</span> <span class="main">∨</span> <span class="free">C2</span> <span class="bound">s</span> <span class="main">∨</span> <span class="free">C3</span> <span class="bound">s</span> <span class="main">∨</span> <span class="free">C4</span> <span class="bound">s</span><span class="main">)</span> <span class="main">;</span>
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">A1</span> <span class="free">A</span><span class="main">;</span> 
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">B1</span> <span class="free">B</span><span class="main">;</span>
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">D1</span> <span class="free">D</span><span class="main">;</span> 
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">E1</span> <span class="free">E</span><span class="main">;</span> 
     corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span> <span class="free">P'</span> <span class="free">F1</span> <span class="free">F</span> <span class="main">⟧</span> <span class="main">⟹</span>
  corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">r</span> <span class="free">P</span>  <span class="free">P'</span> 
    <span class="main">(</span><span class="keyword1">case</span> <span class="free">st</span> <span class="keyword1">of</span> 
      actorState.ACTOR_STATE_INIT <span class="main">⇒</span> <span class="free">A1</span> <span class="main">|</span> 
      actorState.ACTOR_STATE_RUNNING <span class="main">⇒</span> <span class="free">B1</span> <span class="main">|</span>
      actorState.ACTOR_STATE_PAUSE <span class="main">⇒</span> <span class="free">D1</span> <span class="main">|</span> 
      actorState.ACTOR_STATE_FINISH <span class="main">⇒</span> <span class="free">E1</span> <span class="main">|</span>
       <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free">F1</span><span class="main">)</span>
    <span class="main">(</span>condition <span class="free">C1</span>  <span class="free">A</span> <span class="main">(</span>condition <span class="free">C2</span> <span class="free">B</span> <span class="main">(</span>condition <span class="free">C3</span> <span class="free">D</span> <span class="main">(</span>condition <span class="free">C4</span> <span class="free">E</span> <span class="free">F</span> <span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">st</span>"</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> corres_underlying_def condition_def
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>


<span class="keyword1"><span class="command">lemma</span></span> corres_modify_ret<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> rl<span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⋀</span><span class="bound">s</span> <span class="bound">s'</span><span class="main">.</span> <span class="main">⟦</span> <span class="free">P</span> <span class="bound">s</span><span class="main">;</span> <span class="free">P'</span> <span class="bound">s'</span><span class="main">;</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">sr</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">,</span> <span class="free">g</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">sr</span>"</span></span></span>
 <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">sr</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">r'</span><span class="main">.</span> True<span class="main">)</span> <span class="free">P</span> <span class="free">P'</span> <span class="main">(</span>modify <span class="free">f</span><span class="main">)</span> <span class="main">(</span>modify <span class="free">g</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command">using</span></span> rl 
  <span class="keyword1"><span class="command">unfolding</span></span> corres_underlying_def modify_def get_def put_def NonDetMonad.bind_def
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>


<span class="keyword1"><span class="command">lemma</span></span> bind_modify <span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">"<span class="keyword1">do</span> <span class="bound">y</span> <span class="main">←</span> modify <span class="free">A</span><span class="main">;</span>
      <span class="bound">y</span> <span class="main">←</span> modify <span class="free">B</span><span class="main">;</span>
      <span class="bound">y</span> <span class="main">←</span> modify <span class="free">C</span><span class="main">;</span>
      <span class="bound">y</span> <span class="main">←</span> modify <span class="free">D</span><span class="main">;</span>
      return <span class="main">1</span>
   <span class="keyword1">od</span> <span class="main">=</span>
   <span class="keyword1">do</span> <span class="bound">y</span> <span class="main">←</span> modify <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">D</span> <span class="main">(</span><span class="free">C</span> <span class="main">(</span><span class="free">B</span> <span class="main">(</span><span class="free">A</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
      return <span class="main">1</span>
   <span class="keyword1">od</span>  "</span></span></span>
   <span class="keyword1"><span class="command">unfolding</span></span>  modify_def return_def get_def put_def NonDetMonad.bind_def 
   <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
  

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹whileLoop invariant verfication›</span></span></span>




<span class="keyword1"><span class="command">lemma</span></span> corres_whileLoopE<span class="main">:</span>
 <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⟦</span> <span class="main">⋀</span><span class="bound">r</span> <span class="bound">r'</span> <span class="bound">s</span> <span class="bound">s'</span><span class="main">.</span> <span class="main">⟦</span><span class="main">(</span><span class="free">f</span><span class="main">⊕</span><span class="free">rrel</span><span class="main">)</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">;</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span><span class="main">;</span> <span class="free">P</span> <span class="bound">s</span><span class="main">;</span> <span class="free">P'</span> <span class="bound">s'</span><span class="main">⟧</span> <span class="main">⟹</span>
      <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span>
        Inl <span class="bound">e</span> <span class="main">⇒</span>  <span class="main">(</span><span class="main">∃</span><span class="bound">e'</span><span class="main">.</span> <span class="bound">r'</span> <span class="main">=</span> Inl <span class="bound">e'</span><span class="main">)</span> <span class="main">|</span>
        Inr <span class="bound">a</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">∃</span><span class="bound">a'</span><span class="main">.</span> <span class="bound">r'</span> <span class="main">=</span>  Inr <span class="bound">a'</span> <span class="main">∧</span>  <span class="free">C</span> <span class="bound">a</span> <span class="bound">s</span> <span class="main">=</span> <span class="free">C'</span> <span class="bound">a'</span> <span class="bound">s'</span> <span class="main">)</span><span class="main">;</span>
    <span class="main">⋀</span><span class="bound">r</span> <span class="bound">r'</span><span class="main">.</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span> 
      <span class="main">⟹</span> corres_underlying <span class="free">srel</span> False <span class="free">nf'</span> <span class="main">(</span><span class="free">f</span><span class="main">⊕</span><span class="free">rrel</span><span class="main">)</span> <span class="main">(</span><span class="free">P</span> <span class="keyword1">and</span> <span class="free">C</span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="free">P'</span> <span class="keyword1">and</span> <span class="free">C'</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">(</span><span class="free">B</span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="free">B'</span> <span class="bound">r'</span><span class="main">)</span><span class="main">;</span>
    <span class="main">⋀</span><span class="bound">r</span><span class="main">.</span> <span class="main">⦃</span><span class="free">P</span> <span class="keyword1">and</span> <span class="free">C</span> <span class="bound">r</span><span class="main">⦄</span> <span class="free">B</span> <span class="bound">r</span> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">P</span><span class="main">⦄</span><span class="main">;</span>
    <span class="main">⋀</span><span class="bound">r'</span><span class="main">.</span> <span class="main">⦃</span><span class="free">P'</span> <span class="keyword1">and</span> <span class="free">C'</span> <span class="bound">r'</span><span class="main">⦄</span> <span class="free">B'</span> <span class="bound">r'</span> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">P'</span><span class="main">⦄</span><span class="main">;</span>
    <span class="free">rrel</span> <span class="free">r</span> <span class="free">r'</span><span class="main">;</span>
    <span class="main">⋀</span><span class="bound">r'</span><span class="main">.</span> no_fail <span class="main">(</span><span class="free">P'</span> <span class="keyword1">and</span> <span class="free">C'</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">(</span><span class="free">B'</span> <span class="bound">r'</span><span class="main">)</span><span class="main">;</span>
    <span class="main">⋀</span><span class="bound">r'</span> <span class="bound">s'</span><span class="main">.</span> <span class="free">P'</span> <span class="bound">s'</span> <span class="main">⟹</span> whileLoop_terminatesE <span class="free">C'</span> <span class="free">B'</span> <span class="bound">r'</span> <span class="bound">s'</span><span class="main">⟧</span> <span class="main">⟹</span>
   corres_underlying <span class="free">srel</span> False <span class="free">nf'</span> <span class="main">(</span><span class="free">f</span><span class="main">⊕</span><span class="free">rrel</span><span class="main">)</span> <span class="free">P</span> <span class="free">P'</span> <span class="main">(</span>whileLoopE <span class="free">C</span> <span class="free">B</span> <span class="free">r</span><span class="main">)</span> <span class="main">(</span>whileLoopE <span class="free">C'</span> <span class="free">B'</span> <span class="free">r'</span> <span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> whileLoopE_def validE_def<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">rule</span> corres_whileLoop<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> ra r'a s s' 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="language"><span class="skolem">ra</span></span></span><span class="main">)</span></span>  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="language"><span class="skolem">r'a</span></span></span><span class="main">)</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">smt</span> old.sum.simps<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span><span class="main">)</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> ra r'a  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="language"><span class="skolem">ra</span></span></span><span class="main">)</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> ra  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="language"><span class="skolem">ra</span></span></span><span class="main">)</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> r'a
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="language"><span class="skolem">r'a</span></span></span><span class="main">)</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">simp</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">smt</span> no_fail_def old.sum.simps<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span> pred_conj_app snd_lift<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> r'a s'
    <span class="keyword1"><span class="command">unfolding</span></span> whileLoop_terminatesE_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="language"><span class="skolem">r'a</span></span></span><span class="main">)</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> whileLoop_terminates.intros<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span> 



<span class="keyword1"><span class="command">lemma</span></span> corres_whileLoop<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cond<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⋀</span><span class="bound">r</span> <span class="bound">r'</span> <span class="bound">s</span> <span class="bound">s'</span><span class="main">.</span> <span class="main">⟦</span><span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">;</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span><span class="main">;</span> <span class="free">P</span> <span class="bound">s</span><span class="main">;</span> <span class="free">P'</span> <span class="bound">s'</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">C</span> <span class="bound">r</span> <span class="bound">s</span> <span class="main">=</span> <span class="free">C'</span> <span class="bound">r'</span> <span class="bound">s'</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> body_corres<span class="main">:</span> 
           <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⋀</span><span class="bound">r</span> <span class="bound">r'</span><span class="main">.</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span> 
                    <span class="main">⟹</span> corres_underlying <span class="free">srel</span> False <span class="free">nf'</span> <span class="free">rrel</span> <span class="main">(</span><span class="free">P</span> <span class="keyword1">and</span> <span class="free">C</span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="free">P'</span> <span class="keyword1">and</span> <span class="free">C'</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">(</span><span class="free">B</span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="free">B'</span> <span class="bound">r'</span><span class="main">)</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> body_guard<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⋀</span><span class="bound">r</span><span class="main">.</span> <span class="main">⦃</span><span class="free">P</span> <span class="keyword1">and</span> <span class="free">C</span> <span class="bound">r</span><span class="main">⦄</span> <span class="free">B</span> <span class="bound">r</span> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">P</span><span class="main">⦄</span>"</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⋀</span><span class="bound">r'</span><span class="main">.</span> <span class="main">⦃</span><span class="free">P'</span> <span class="keyword1">and</span> <span class="free">C'</span> <span class="bound">r'</span><span class="main">⦄</span> <span class="free">B'</span> <span class="bound">r'</span> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">P'</span><span class="main">⦄</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> rel<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">rrel</span> <span class="free">r</span> <span class="free">r'</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> nf'<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⋀</span><span class="bound">r'</span><span class="main">.</span> no_fail <span class="main">(</span><span class="free">P'</span> <span class="keyword1">and</span> <span class="free">C'</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">(</span><span class="free">B'</span> <span class="bound">r'</span><span class="main">)</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> termin<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⋀</span><span class="bound">r'</span> <span class="bound">s'</span><span class="main">.</span> <span class="free">P'</span> <span class="bound">s'</span> <span class="main">⟹</span> whileLoop_terminates <span class="free">C'</span> <span class="free">B'</span> <span class="bound">r'</span> <span class="bound">s'</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">srel</span> False <span class="free">nf'</span> <span class="free">rrel</span> <span class="free">P</span> <span class="free">P'</span> <span class="main">(</span>whileLoop <span class="free">C</span> <span class="free">B</span> <span class="free">r</span><span class="main">)</span> <span class="main">(</span>whileLoop <span class="free">C'</span> <span class="free">B'</span> <span class="free">r'</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">rule</span> corres_no_failI<span class="main">)</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> no_fail_def<span class="main">)</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">intro</span> allI impI<span class="main">)</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">insert</span> assms<span class="main">)</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">rule</span> corres_whileLoop_no_fail_helper<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">clarsimp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">frule_tac</span> C<span class="main"><span class="main">=</span></span><span class="quoted"><span class="language"><span class="free">C</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> P<span class="main"><span class="main">=</span></span><span class="quoted"><span class="language"><span class="free">P</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> P'<span class="main"><span class="main">=</span></span><span class="quoted"><span class="language"><span class="free">P'</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> rrel<span class="main"><span class="main">=</span></span><span class="quoted"><span class="language"><span class="free">rrel</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> srel<span class="main"><span class="main">=</span></span><span class="quoted"><span class="language"><span class="free">srel</span></span></span>
                <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> corres_whileLoop_results_helper<span class="main"><span class="main">[</span></span><span class="language"><span class="operator">rotated</span> 4</span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>



<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹call aux›</span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> corres_callL<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cor<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">srel</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">rrel</span> <span class="free">G</span> <span class="free">G'</span> <span class="free">m1</span> <span class="free">m2</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> strel<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span> <span class="bound">t</span><span class="main">.</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">srel'</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="free">v</span> <span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> urel<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span> <span class="bound">s'</span> <span class="bound">t</span> <span class="bound">t''</span><span class="main">.</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">s'</span><span class="main">)</span><span class="main">∈</span><span class="free">srel'</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span><span class="bound">t''</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span> <span class="main">⟶</span> <span class="free">w</span> <span class="bound">s</span> <span class="main">=</span> <span class="free">w</span> <span class="bound">t</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span><span class="free">u</span> <span class="bound">s'</span> <span class="bound">t''</span><span class="main">)</span><span class="main">∈</span><span class="free">srel'</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">I</span><span class="main">.</span>  <span class="free">m1</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">w</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">I</span><span class="main">⦄</span>"</span></span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span><span class="main">.</span> <span class="free">G''</span> <span class="bound">s</span> <span class="main">⟶</span> <span class="free">G'</span> <span class="main">(</span><span class="free">v</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">srel'</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">rrel</span> <span class="free">G</span> <span class="free">G''</span> <span class="free">m1</span> <span class="main">(</span>NonDetMonad_call.call <span class="free">m2</span> <span class="free">v</span> <span class="free">u</span><span class="main">)</span>"</span></span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="language"><span class="operator">-</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="language"><span class="var">?m</span></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted"><span class="language">"NonDetMonad_call.call <span class="free">m2</span> <span class="free">v</span> <span class="free">u</span>"</span></span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">s'</span>
    <span class="keyword3"><span class="command">assume</span></span> sr<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">s</span><span class="main">,</span><span class="skolem">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> g1<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G</span> <span class="skolem">s</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> g2<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G''</span> <span class="skolem">s'</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> nf<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">nf</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m1</span> <span class="skolem">s</span><span class="main">)</span>"</span></span></span>

    <span class="keyword1"><span class="command">from</span></span> cor <span class="keyword1"><span class="command">have</span></span> cor'<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span><span class="main">.</span> <span class="free">G</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">G'</span> <span class="bound">s'</span> <span class="main">⟶</span>
           <span class="main">(</span><span class="free">nf</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m1</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span>
           <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m2</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">∧</span>
           <span class="main">(</span><span class="free">nf'</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m2</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>corres_underlying_def<span class="main">)</span></span>
    <span class="keyword1"><span class="command">from</span></span> strel sr <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">s</span><span class="main">,</span><span class="free">v</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> g2 G <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G'</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s'</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">simp</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> tg1<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">)</span>
      <span class="main">∧</span> <span class="main">(</span><span class="free">nf'</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> g1 cor' nf <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fast</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> nf2<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">nf'</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="var">?m</span> <span class="skolem">s'</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad_call.call_def<span class="main">)</span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r'</span> <span class="skolem">t'</span>
      <span class="keyword3"><span class="command">assume</span></span> rt<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r'</span><span class="main">,</span> <span class="skolem">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="var">?m</span> <span class="skolem">s'</span><span class="main">)</span>"</span></span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t''</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r'</span><span class="main">,</span><span class="skolem">t''</span><span class="main">)</span><span class="main">∈</span>fst <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">t'</span> <span class="main">=</span> <span class="free">u</span> <span class="skolem">s'</span> <span class="skolem">t''</span>"</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad_call.call_def<span class="main"><span class="keyword3">,</span></span><span class="operator">fastforce</span><span class="main">)</span></span>
      <span class="keyword1"><span class="command">with</span></span> tg1 <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> tr<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r</span><span class="main">,</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">t</span><span class="main">,</span> <span class="skolem">t''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="skolem">r</span> <span class="skolem">r'</span>"</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fast</span></span>
      <span class="keyword1"><span class="command">with</span></span> I<span class="main">[</span><span class="language"><span class="operator">rule_format</span></span><span class="main">,</span> <span class="language"><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">w</span> <span class="skolem">s</span>"</span></span></span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> wst<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">w</span> <span class="skolem">s</span> <span class="main">=</span> <span class="free">w</span> <span class="skolem">t</span>"</span></span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad.valid_def<span class="main">)</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fastforce</span></span>
      <span class="keyword1"><span class="command">with</span></span> tr sr z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">t</span><span class="main">,</span> <span class="skolem">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span>"</span></span></span> <span class="keyword1"><span class="command">using</span></span> urel <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
      <span class="keyword1"><span class="command">with</span></span> tr <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="skolem">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="skolem">r'</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">with</span></span> nf2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="var">?m</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">∧</span>
           <span class="main">(</span><span class="free">nf'</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="var">?m</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="language"><span class="var">?thesis</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>corres_underlying_def<span class="main">)</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">force</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> corres_callR<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cor<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">srel</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">rrel</span> <span class="free">G'</span> <span class="free">G</span> <span class="free">m2</span> <span class="free">m1</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> strel<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span> <span class="bound">t</span><span class="main">.</span> <span class="free">G''</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">srel'</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">v</span> <span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> urel<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span> <span class="bound">s''</span> <span class="bound">t'</span> <span class="bound">t''</span><span class="main">.</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">s''</span><span class="main">)</span><span class="main">∈</span><span class="free">srel'</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">t'</span><span class="main">,</span><span class="bound">t''</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span> <span class="main">⟶</span> <span class="free">w</span> <span class="bound">s''</span> <span class="main">=</span> <span class="bound">t''</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">u</span> <span class="bound">s</span> <span class="bound">t'</span><span class="main">,</span><span class="bound">t''</span><span class="main">)</span><span class="main">∈</span><span class="free">srel'</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s'</span><span class="main">.</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">s'</span><span class="main">⦄</span> <span class="free">m1</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">s</span><span class="main">.</span> <span class="free">w</span> <span class="bound">s'</span> <span class="main">=</span> <span class="bound">s</span><span class="main">⦄</span>"</span></span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span><span class="main">.</span> <span class="free">G''</span> <span class="bound">s</span> <span class="main">⟶</span> <span class="free">G'</span> <span class="main">(</span><span class="free">v</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">srel'</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">rrel</span> <span class="free">G''</span> <span class="free">G</span> <span class="main">(</span>NonDetMonad_call.call <span class="free">m2</span> <span class="free">v</span> <span class="free">u</span><span class="main">)</span> <span class="free">m1</span>"</span></span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="language"><span class="operator">-</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="language"><span class="var">?m</span></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted"><span class="language">"NonDetMonad_call.call <span class="free">m2</span> <span class="free">v</span> <span class="free">u</span>"</span></span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">s''</span>
    <span class="keyword3"><span class="command">assume</span></span> sr<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G''</span> <span class="skolem">s</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">s</span><span class="main">,</span><span class="skolem">s''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> g1<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G''</span> <span class="skolem">s</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> g2<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G</span> <span class="skolem">s''</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> nf<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">nf</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="var">?m</span> <span class="skolem">s</span><span class="main">)</span>"</span></span></span>

    <span class="keyword1"><span class="command">from</span></span> cor <span class="keyword1"><span class="command">have</span></span> cor'<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span><span class="main">.</span> <span class="free">G'</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">G</span> <span class="bound">s'</span> <span class="main">⟶</span>
           <span class="main">(</span><span class="free">nf</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m2</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span>
           <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m2</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">∧</span>
           <span class="main">(</span><span class="free">nf'</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m1</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>corres_underlying_def<span class="main">)</span></span>
    <span class="keyword1"><span class="command">from</span></span> strel sr <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">,</span><span class="skolem">s''</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> g1 G <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G'</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">simp</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> nf <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">nf</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad_call.call_def<span class="main">)</span></span> 
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> tg1<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r'</span><span class="main">,</span> <span class="bound">t''</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s''</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t'</span><span class="main">,</span> <span class="bound">t''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">)</span>
      <span class="main">∧</span> <span class="main">(</span><span class="free">nf'</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m1</span> <span class="skolem">s''</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> g1 g2 cor' <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fast</span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r''</span> <span class="skolem">t''</span>
      <span class="keyword3"><span class="command">assume</span></span> rt<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r''</span><span class="main">,</span> <span class="skolem">t''</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s''</span><span class="main">)</span>"</span></span></span>
      <span class="keyword1"><span class="command">with</span></span> tg1 <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r'</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem"><span class="skolem">t'</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r'</span><span class="main">,</span><span class="skolem">t'</span><span class="main">)</span><span class="main">∈</span>fst <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">t'</span><span class="main">,</span> <span class="skolem">t''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="skolem">r'</span> <span class="skolem">r''</span>"</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fast</span></span>
      <span class="keyword1"><span class="command">with</span></span> I rt <span class="keyword1"><span class="command">have</span></span> wst<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">w</span> <span class="skolem">s''</span> <span class="main">=</span> <span class="skolem">t''</span>"</span></span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad.valid_def<span class="main">)</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fastforce</span></span>

      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> rt<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r</span><span class="main">,</span><span class="skolem">t</span><span class="main">)</span><span class="main">∈</span>fst <span class="main">(</span><span class="var">?m</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">t</span> <span class="main">=</span> <span class="free">u</span> <span class="skolem">s</span> <span class="skolem">t'</span>"</span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad_call.call_def<span class="main">)</span></span>
        <span class="keyword1"><span class="command">using</span></span> z <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fastforce</span></span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">t</span><span class="main">,</span> <span class="skolem">t''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span>"</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> rt sr urel wst z <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
      <span class="keyword1"><span class="command">with</span></span> rt z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="var">?m</span> <span class="skolem">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="skolem">t''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="skolem">r''</span>"</span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad_call.call_def<span class="main">)</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fastforce</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">with</span></span> tg1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r''</span><span class="main">,</span> <span class="bound">t''</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s''</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="var">?m</span> <span class="skolem">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">t''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r''</span><span class="main">)</span> <span class="main">∧</span>
           <span class="main">(</span><span class="free">nf'</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m1</span> <span class="skolem">s''</span><span class="main">)</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="language"><span class="var">?thesis</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>corres_underlying_def<span class="main">)</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">force</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> corres_callL_nr <span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cor<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">srel</span> <span class="free">nf1</span> <span class="free">nf2</span> <span class="free">rrel</span> <span class="free">G1</span> <span class="free">G2</span> <span class="free">m1</span> <span class="free">m2</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> strel<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span> <span class="bound">t</span><span class="main">.</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">srel'</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="free">v</span> <span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> urel<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span> <span class="bound">t</span><span class="main">.</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">r</span><span class="main">.</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="free">u</span> <span class="bound">r</span> <span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">srel'</span><span class="main">)</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span><span class="main">.</span> <span class="free">G2'</span> <span class="bound">s</span> <span class="main">⟶</span> <span class="free">G2</span> <span class="main">(</span><span class="free">v</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">srel'</span> <span class="free">nf1</span> <span class="free">nf2</span> <span class="free">rrel</span> <span class="free">G1</span> <span class="free">G2'</span> <span class="free">m1</span> <span class="main">(</span>NonDetMonad_call.call <span class="free">m2</span> <span class="free">v</span> <span class="free">u</span><span class="main">)</span>"</span></span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="language"><span class="operator">-</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="language"><span class="var">?m</span></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted"><span class="language">"NonDetMonad_call.call <span class="free">m2</span> <span class="free">v</span> <span class="free">u</span>"</span></span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">s'</span>
    <span class="keyword3"><span class="command">assume</span></span> sr<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">s</span><span class="main">,</span><span class="skolem">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> g1<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G1</span> <span class="skolem">s</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> g2<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G2'</span> <span class="skolem">s'</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> nf<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">nf1</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m1</span> <span class="skolem">s</span><span class="main">)</span>"</span></span></span>

    <span class="keyword1"><span class="command">from</span></span> cor <span class="keyword1"><span class="command">have</span></span> cor'<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span><span class="main">.</span> <span class="free">G1</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">G2</span> <span class="bound">s'</span> <span class="main">⟶</span>
           <span class="main">(</span><span class="free">nf1</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m1</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span>
           <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m2</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">∧</span>
           <span class="main">(</span><span class="free">nf2</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m2</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>corres_underlying_def<span class="main">)</span></span>

    <span class="keyword1"><span class="command">from</span></span> strel sr <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">s</span><span class="main">,</span><span class="free">v</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> g2 G <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s'</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">simp</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> nf <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">nf1</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m1</span> <span class="skolem">s</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad_call.call_def<span class="main">)</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> tg1<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">)</span>
      <span class="main">∧</span> <span class="main">(</span><span class="free">nf2</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> g1 cor' <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fast</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> nf2<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">nf2</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="var">?m</span> <span class="skolem">s'</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad_call.call_def<span class="main">)</span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r'</span> <span class="skolem">t'</span>
      <span class="keyword3"><span class="command">assume</span></span> rt<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r'</span><span class="main">,</span> <span class="skolem">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="var">?m</span> <span class="skolem">s'</span><span class="main">)</span>"</span></span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">z</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r'</span><span class="main">,</span><span class="skolem">z</span><span class="main">)</span><span class="main">∈</span>fst <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">t'</span> <span class="main">=</span> <span class="free">u</span> <span class="skolem">s'</span> <span class="skolem">z</span>"</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad_call.call_def<span class="main"><span class="keyword3">,</span></span><span class="operator">fastforce</span><span class="main">)</span></span>
      <span class="keyword1"><span class="command">with</span></span> tg1 <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> tr<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r</span><span class="main">,</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">t</span><span class="main">,</span> <span class="skolem">z</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="skolem">r</span> <span class="skolem">r'</span>"</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fast</span></span>
      <span class="keyword1"><span class="command">with</span></span> urel z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="skolem">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="skolem">r'</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">with</span></span> nf2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="var">?m</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">∧</span>
           <span class="main">(</span><span class="free">nf2</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="var">?m</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="language"><span class="var">?thesis</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>corres_underlying_def<span class="main">)</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">force</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemma</span></span> corres_callR_nr <span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cor<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">srel</span> <span class="free">nf1</span> <span class="free">nf2</span> <span class="free">rrel</span> <span class="free">Gx</span> <span class="free">G2</span> <span class="free">m2</span> <span class="free">m1</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> strel<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span> <span class="bound">t</span><span class="main">.</span> <span class="free">G1'</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">srel'</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">v</span> <span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> urel<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span> <span class="bound">t</span><span class="main">.</span> <span class="free">G1'</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">srel'</span> <span class="main">∧</span> <span class="main">(</span><span class="free">v</span> <span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">u</span> <span class="bound">s</span> <span class="main">(</span><span class="free">v</span> <span class="bound">s</span><span class="main">)</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span><span class="main">.</span> <span class="free">G1'</span> <span class="bound">s</span> <span class="main">⟶</span> <span class="free">Gx</span> <span class="main">(</span><span class="free">v</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">srel'</span> <span class="free">nf1</span> <span class="free">nf2</span> <span class="free">rrel</span> <span class="free">G1'</span> <span class="free">G2</span> <span class="main">(</span>NonDetMonad_call.call <span class="free">m2</span> <span class="free">v</span> <span class="free">u</span><span class="main">)</span> <span class="free">m1</span>"</span></span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="language"><span class="operator">-</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="language"><span class="var">?m</span></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted"><span class="language">"NonDetMonad_call.call <span class="free">m2</span> <span class="free">v</span> <span class="free">u</span>"</span></span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">s'</span>
    <span class="keyword3"><span class="command">assume</span></span> sr<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">s</span><span class="main">,</span><span class="skolem">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> g1<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G1'</span> <span class="skolem">s</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> g2<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G2</span> <span class="skolem">s'</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> nf<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">nf1</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="var">?m</span> <span class="skolem">s</span><span class="main">)</span>"</span></span></span>
    <span class="keyword1"><span class="command">from</span></span> cor <span class="keyword1"><span class="command">have</span></span> cor'<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span><span class="main">.</span> <span class="free">Gx</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">G2</span> <span class="bound">s'</span> <span class="main">⟶</span>
           <span class="main">(</span><span class="free">nf1</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m2</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span>
           <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m2</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">∧</span>
           <span class="main">(</span><span class="free">nf2</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m1</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>corres_underlying_def<span class="main">)</span></span>
    <span class="keyword1"><span class="command">from</span></span> g1 strel sr <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">,</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span>"</span></span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">simp</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> g1 G <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">Gx</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">simp</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> nf <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">nf1</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad_call.call_def<span class="main">)</span></span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> tg1<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">)</span>
      <span class="main">∧</span> <span class="main">(</span><span class="free">nf2</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m1</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> g2 cor' <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fast</span></span>
    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r'</span> <span class="skolem">t'</span>
      <span class="keyword3"><span class="command">assume</span></span> rt<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r'</span><span class="main">,</span> <span class="skolem">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s'</span><span class="main">)</span>"</span></span></span>
      <span class="keyword1"><span class="command">from</span></span> tg1 rt <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="skolem">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="skolem">r'</span>"</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fast</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="keyword2"><span class="keyword">where</span></span> rt<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r</span><span class="main">,</span> <span class="skolem">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">t</span><span class="main">,</span> <span class="skolem">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="skolem">r</span> <span class="skolem">r'</span>"</span></span></span> 
        <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r</span><span class="main">,</span><span class="free">u</span> <span class="skolem">s</span> <span class="skolem">t</span><span class="main">)</span><span class="main">∈</span>fst <span class="main">(</span><span class="var">?m</span> <span class="skolem">s</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad_call.call_def<span class="main"><span class="keyword3">,</span></span><span class="operator">force</span><span class="main">)</span></span>
      <span class="keyword1"><span class="command">with</span></span> rt urel <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="var">?m</span> <span class="skolem">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="skolem">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="skolem">r'</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">with</span></span> tg1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="var">?m</span> <span class="skolem">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">∧</span>
           <span class="main">(</span><span class="free">nf2</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m1</span> <span class="skolem">s'</span><span class="main">)</span><span class="main">)</span>"</span></span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="language"><span class="var">?thesis</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>corres_underlying_def<span class="main">)</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">force</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹no fail aux›</span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> non_fail_condition <span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">" no_fail <span class="main">(</span><span class="free">P</span> <span class="keyword1">and</span> <span class="free">C</span><span class="main">)</span> <span class="free">A</span> <span class="main">∧</span> no_fail <span class="main">(</span><span class="free">P</span> <span class="keyword1">and</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span> <span class="free">C</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="free">B</span>  <span class="main">⟹</span> 
      no_fail <span class="free">P</span> <span class="main">(</span>condition <span class="free">C</span> <span class="free">A</span> <span class="free">B</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> no_fail_def condition_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>

<span class="keyword1"><span class="command">lemma</span></span> non_fail_seq <span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">" no_fail <span class="free">P</span> <span class="free">A</span> <span class="main">∧</span> no_fail <span class="free">Q</span> <span class="free">B</span> <span class="main">∧</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">A</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">s</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">s</span><span class="main">⦄</span> <span class="main">⟹</span> 
      no_fail <span class="free">P</span> <span class="main">(</span><span class="keyword1">do</span> <span class="free">A</span><span class="main">;</span> <span class="free">B</span>  <span class="keyword1">od</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> no_fail_def NonDetMonad.valid_def<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> case_prodD snd_bind<span class="main">)</span></span>

<span class="keyword1"><span class="command">lemma</span></span> non_fail_condition2<span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">" no_fail <span class="main">(</span><span class="free">P</span> <span class="keyword1">and</span> <span class="free">C</span><span class="main">)</span> <span class="free">A</span> <span class="main">∧</span> no_fail <span class="main">(</span><span class="free">P</span> <span class="keyword1">and</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="main">¬</span> <span class="free">C</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="free">B</span>  <span class="main">⟹</span> 
      no_fail <span class="free">P</span> <span class="main">(</span>condition <span class="free">C</span> <span class="free">A</span> <span class="free">B</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> no_fail_def condition_def 
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>

<span class="keyword1"><span class="command">lemma</span></span> non_fail_seq2 <span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">" <span class="main">(</span><span class="main">∀</span><span class="bound">s</span><span class="main">.</span> <span class="free">P</span> <span class="bound">s</span> <span class="main">⟶</span> <span class="free">t</span> <span class="bound">s</span><span class="main">)</span> <span class="main">⟹</span> no_fail <span class="free">P</span> <span class="free">m</span>  <span class="main">⟹</span> 
      no_fail <span class="free">P</span> <span class="main">(</span><span class="keyword1">do</span> <span class="bound">f</span> <span class="main">&lt;-</span> guard <span class="free">t</span><span class="main">;</span> <span class="free">m</span> <span class="keyword1">od</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> guard_def no_fail_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> snd_bind<span class="main">)</span></span>
<span class="keyword1"><span class="command">lemma</span></span> non_fail_seq3 <span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">" no_fail <span class="free">P</span> <span class="free">A</span> <span class="main">∧</span> no_fail <span class="free">Q</span> <span class="free">B</span> <span class="main">∧</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span> <span class="free">A</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">s</span><span class="main">.</span> <span class="free">Q</span> <span class="bound">s</span><span class="main">⦄</span> <span class="main">⟹</span> 
      no_fail <span class="free">P</span> <span class="main">(</span><span class="keyword1">do</span> <span class="bound">f</span> <span class="main">&lt;-</span><span class="free">A</span><span class="main">;</span> <span class="free">B</span>  <span class="keyword1">od</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> no_fail_def NonDetMonad.valid_def<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> case_prodD snd_bind<span class="main">)</span></span>
<span class="keyword1"><span class="command">lemma</span></span> non_fail_seq4 <span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">" <span class="main">(</span><span class="main">∀</span><span class="bound">s</span><span class="main">.</span> <span class="free">P</span> <span class="bound">s</span> <span class="main">⟶</span> <span class="free">t</span> <span class="bound">s</span><span class="main">)</span> <span class="main">⟹</span> no_fail <span class="free">P</span> <span class="free">m</span>  <span class="main">⟹</span> 
      no_fail <span class="free">P</span> <span class="main">(</span><span class="keyword1">do</span> guard <span class="free">t</span><span class="main">;</span> <span class="free">m</span> <span class="keyword1">od</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> guard_def no_fail_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> snd_bind<span class="main">)</span></span>
<span class="keyword1"><span class="command">lemma</span></span> non_fail_skip <span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">"no_fail <span class="free">P</span> skip"</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> skip_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">lemma</span></span> non_fail_gets2<span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">"no_fail <span class="free">P</span> <span class="free">m</span>  <span class="main">⟹</span> 
      no_fail <span class="free">P</span> <span class="main">(</span><span class="keyword1">do</span> <span class="bound">f</span> <span class="main">&lt;-</span> gets <span class="free">t</span><span class="main">;</span> <span class="free">m</span> <span class="keyword1">od</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹bus invariant›</span></span></span>

<span class="keyword1"><span class="command">definition</span></span> Bus_invariant_1_2 <span class="main">::</span> <span class="quoted"><span class="quoted"><span class="language">"bus <span class="main">⇒</span>bool"</span></span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">Bus_invariant_1_2</span> <span class="free"><span class="bound">b</span></span> <span class="main">≡</span> 
              nRegisteredPlugin <span class="free"><span class="bound">b</span></span> <span class="main">=</span> int <span class="main">(</span>length <span class="main">(</span>pluginList <span class="free"><span class="bound">b</span></span><span class="main">)</span><span class="main">)</span>"</span></span></span>

<span class="keyword1"><span class="command">definition</span></span> Bus_variant <span class="main">::</span> <span class="quoted"><span class="quoted"><span class="language">"bus <span class="main">⇒</span>bool"</span></span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">Bus_variant</span> <span class="free"><span class="bound">a</span></span> <span class="main">≡</span> 
             nRegisteredPlugin <span class="free"><span class="bound">a</span></span> <span class="main">=</span> int <span class="main">(</span>length <span class="main">(</span>pluginList <span class="free"><span class="bound">a</span></span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span> <span class="main">∧</span> <span class="main">0</span> <span class="main">≤</span> nRegisteredPlugin <span class="free"><span class="bound">a</span></span>"</span></span></span>

<span class="keyword1"><span class="command">definition</span></span> Bus_invariant_2_2 <span class="main">::</span> <span class="quoted"><span class="quoted"><span class="language">"bus <span class="main">⇒</span>bool"</span></span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">Bus_invariant_2_2</span> <span class="free"><span class="bound">bus</span></span> <span class="main">≡</span> 
              nRegisteredPlugin <span class="free"><span class="bound">bus</span></span> <span class="main">=</span> int <span class="main">(</span>length <span class="main">(</span>pluginOwner <span class="free"><span class="bound">bus</span></span><span class="main">)</span><span class="main">)</span>"</span></span></span>

<span class="keyword1"><span class="command">definition</span></span> Bus_invariant_3_2 <span class="main">::</span> <span class="quoted"><span class="quoted"><span class="language">"bus <span class="main">⇒</span>bool"</span></span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">Bus_invariant_3_2</span> <span class="free"><span class="bound">bus</span></span> <span class="main">≡</span> 
              nRegisteredPlugin <span class="free"><span class="bound">bus</span></span> <span class="main">=</span> int <span class="main">(</span>length <span class="main">(</span>pluginName <span class="free"><span class="bound">bus</span></span><span class="main">)</span><span class="main">)</span>"</span></span></span>


<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹bus refinement›</span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹initializeBus verify›</span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> des_impl_initializeBus <span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"
    <span class="main">⦃</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span>  int64ListEqual <span class="main">[]</span> <span class="main">(</span>pluginOwner_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
          stringListEqual <span class="main">[]</span> <span class="main">(</span>pluginName_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
          pluginListEqual <span class="main">[]</span> <span class="main">(</span>pluginList_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
          stringEqual <span class="free">na</span> <span class="free">naC</span><span class="main">⦄</span>
      Impl_initializeBus <span class="free">busPtr</span> <span class="free">naC</span>
    <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">s</span><span class="main">.</span> busEqual <span class="free">busPtr</span> <span class="bound">s</span> <span class="main">(</span>busInitialize <span class="free">na</span><span class="main">)</span> <span class="main">⦄</span>"</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Impl_initializeBus_def busInitialize_def Let_def  busEqual_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> BusName_C_update1 GeneralBus_C.exhaust GeneralBus_C.name_C.simps nRegisteredPlugin_C_update.simps<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> GeneralBus_C.exhaust Word_Lemmas.sint_0 int32Equal_def nRegisteredPlugin_C.simps nRegisteredPlugin_C_update.simps<span class="main">)</span></span>
  <span class="keyword1"><span class="command">using</span></span> stringListEqual_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">blast</span></span>
  <span class="keyword1"><span class="command">using</span></span> int64ListEqual_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">blast</span></span>
  <span class="keyword1"><span class="command">using</span></span> pluginListEqual_def <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹createInstance verify›</span></span></span>


<span class="keyword1"><span class="command">axiomatization</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> addPlugin_func <span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"
  pluginNoPtrEqual <span class="free">plugC</span> <span class="free">plu</span> <span class="main">⟹</span>
    <span class="main">⦃</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span>  busPtrEqual <span class="free">busPtr</span> <span class="bound">s</span> <span class="free">bus</span><span class="main">⦄</span>
      Impl_addPlugin <span class="free">busPtr</span> <span class="free">plugC</span>
    <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">s</span><span class="main">.</span> busPtrEqual <span class="free">busPtr</span> <span class="bound">s</span> <span class="main">(</span><span class="free">bus</span><span class="main">⦇</span>pluginList <span class="main">:=</span> <span class="main">(</span>pluginList <span class="free">bus</span><span class="main">)</span> <span class="main">@</span> <span class="main">[</span><span class="free">plu</span><span class="main">]</span><span class="main">⦈</span><span class="main">)</span> <span class="main">⦄</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> addPlugin_valid <span class="main">:</span> 
   <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⦃</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">⦄</span> Impl_addPlugin <span class="free">busPtr</span> <span class="free">plug</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">xa</span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">⦄</span>"</span></span></span>

<span class="keyword1"><span class="command">axiomatization</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span> add_plugin_sem <span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"Impl_addPlugin <span class="free">busPtr</span> <span class="free">pluginNameA</span>  <span class="main">=</span> skip "</span></span></span>
  <span class="keyword2"><span class="keyword">and</span></span> sint_add_1 <span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">" sint <span class="free">a</span> <span class="main">&lt;</span> <span class="numeral">128</span> <span class="main">∧</span>  <span class="main">0</span>  <span class="main">≤</span> sint <span class="main">(</span><span class="free">a</span><span class="main">::</span> <span class="numeral">32</span> signed word<span class="main">)</span> <span class="main">⟹</span>  <span class="main">0</span>  <span class="main">≤</span> sint <span class="main">(</span><span class="free">a</span><span class="main">+</span><span class="main">1</span><span class="main">)</span>  "</span></span></span>
  <span class="keyword2"><span class="keyword">and</span></span> sint_add_2 <span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">" sint <span class="free">a</span> <span class="main">&lt;</span> <span class="numeral">127</span> <span class="main">⟹</span> sint <span class="main">(</span><span class="free">a</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">128</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">and</span></span> sint_add_3 <span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">" sint <span class="main">(</span><span class="free">a</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">-</span><span class="main">1</span> <span class="main">=</span>  sint <span class="free">a</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">and</span></span> sint_add_4 <span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">" sint <span class="free">a</span> <span class="main">&lt;</span> <span class="numeral">128</span> <span class="main">⟹</span> sint <span class="main">(</span><span class="free">a</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="main">&lt;</span> <span class="numeral">128</span>"</span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> des_impl_createInstance <span class="main">:</span>
    <span class="quoted"><span class="quoted"><span class="language">"stringEqual <span class="free">na</span> <span class="free">nameC</span> <span class="main">⟹</span>
     corres_underlying <span class="main">(</span><span class="main">{</span><span class="main">(</span><span class="bound">t</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> busPtrEqual <span class="free">busPtr</span> <span class="bound">s</span> <span class="main">(</span>fst <span class="bound">t</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> False False
       <span class="main">(</span><span class="main">λ</span><span class="bound">retDes</span> <span class="bound">resImpl</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">retDes</span> <span class="keyword1">of</span> Inl <span class="bound">e</span> <span class="main">⇒</span> <span class="bound">e</span> <span class="main">=</span> <span class="inner_quoted">''emptyNameError''</span> <span class="main">∧</span> <span class="bound">resImpl</span> <span class="main">=</span> <span class="main">0</span> 
                                      <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> <span class="bound">b</span> <span class="main">=</span> True <span class="main">∧</span> <span class="bound">resImpl</span> <span class="main">=</span> <span class="main">1</span><span class="main">)</span> 
        <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> fst <span class="bound">s</span> <span class="main">=</span> <span class="free">sd</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">=</span> <span class="free">si</span> <span class="main">∧</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span>  
        <span class="main">(</span>Des_createInstance <span class="free">na</span><span class="main">)</span> <span class="main">(</span>Impl_createInstance <span class="free">busPtr</span> <span class="free">nameC</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> Let_def Des_createInstance_def Impl_createInstance_def<span class="main">)</span></span>                                   
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">λ</span><span class="bound">r</span> <span class="bound">v</span><span class="main">.</span> <span class="bound">v</span><span class="main">=</span><span class="free">si</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">unfold</span> K_bind_def<span class="main">)</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> stringEqual_def<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> throwError_def corres_underlying_def return_def<span class="main">)</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">force</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">rule</span> corres_split'<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> r' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">λ</span><span class="bound">rd</span> <span class="bound">ri</span><span class="main">.</span> True"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> Q <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">λ</span><span class="bound">r</span> <span class="bound">v</span><span class="main">.</span> fst <span class="bound">v</span> <span class="main">=</span> <span class="free">sd</span><span class="main">⦇</span>pluginList <span class="main">:=</span> <span class="main">(</span>pluginList <span class="free">sd</span><span class="main">)</span> <span class="main">@</span> <span class="main">[</span>nullPlugin<span class="main">⦇</span>plugin.name <span class="main">:=</span> <span class="free">na</span><span class="main">⦈</span><span class="main">]</span><span class="main">⦈</span>"</span></span></span> 
                                <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">λ</span><span class="bound">r</span> <span class="bound">v</span><span class="main">.</span> True"</span></span></span></span> <span class="main"><span class="main">]</span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> returnOk_def corres_underlying_def return_def<span class="main">)</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fastforce</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> nullPlugin_def<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted"><span class="language">"pluginNoPtrEqual <span class="main">(</span>GeneralPlugin_C <span class="main">(</span><span class="main">-</span> <span class="main">1</span><span class="main">)</span> impl_ACTOR_STATE_noValid <span class="main">(</span><span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="free">nameC</span><span class="main">)</span> 
                                <span class="main">(</span><span class="main">⦇</span>plugin.name <span class="main">=</span> <span class="inner_quoted">''null''</span><span class="main">,</span> actorID <span class="main">=</span> <span class="main">-</span> <span class="main">1</span><span class="main">,</span> state <span class="main">=</span> pluginState.NOT_VALID<span class="main">,</span> duration <span class="main">=</span> <span class="main">-</span> <span class="main">1</span><span class="main">⦈</span><span class="main">⦇</span>plugin.name <span class="main">:=</span> <span class="free">na</span><span class="main">⦈</span><span class="main">)</span>"</span></span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">insert</span> addPlugin_func<span class="main">)</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> gets_def modify_def get_def put_def bind_def NonDetMonad.bind_def NonDetMonad.valid_def corres_underlying_def<span class="main">)</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> pluginNoPtrEqual_def int64Equal_def  int32Equal_def stringEqual_def statePluginEqual_def<span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ded_imp_pluginNoValid<span class="main">)</span></span> 


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹loadPlugin verify›</span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> des_impl_loadPlugin_aux1 <span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"stringEqual <span class="free">pName</span> <span class="free">pluginName1</span> <span class="main">⟹</span>
  <span class="main">⦃</span>bus_valid <span class="free">busPtr</span><span class="main">⦄</span> Impl_createInstance <span class="free">busPtr</span> <span class="free">pluginName1</span> <span class="main">⦃</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> bus_valid <span class="free">busPtr</span><span class="main">⦄</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> Impl_createInstance_def<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> addPlugin_valid<span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> plugin_update<span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⦇</span>plugin.name <span class="main">=</span> <span class="free">pName</span><span class="main">,</span> actorID <span class="main">=</span> <span class="free">actID</span><span class="main">,</span> state <span class="main">=</span> pluginState.ACTOR_STATE_PAUSE<span class="main">,</span> duration <span class="main">=</span> <span class="main">1</span><span class="main">⦈</span><span class="main">=</span> 
   <span class="free">plu</span><span class="main">⦇</span>plugin.name <span class="main">:=</span> <span class="free">pName</span><span class="main">,</span> plugin.actorID <span class="main">:=</span> <span class="free">actID</span><span class="main">,</span> plugin.state <span class="main">:=</span> pluginState.ACTOR_STATE_PAUSE<span class="main">,</span> duration <span class="main">:=</span> <span class="main">1</span><span class="main">⦈</span> "</span></span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">simp</span></span>


<span class="keyword1"><span class="command">lemma</span></span> des_impl_loadPlugin_aux3 <span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">"stringEqual <span class="free">pName</span> <span class="free">pluginName1</span> <span class="main">⟹</span>
    int64Equal <span class="free">actID</span> <span class="free">actorID1</span> <span class="main">⟹</span>
    <span class="main">⦃</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> Bus_invariant_2_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> Bus_invariant_3_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> Bus_invariant_1_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span><span class="main">⦄</span> 
      Des_createInstance <span class="free">pName</span> 
    <span class="main">⦃</span><span class="main">λ</span><span class="bound">ret</span> <span class="bound">s</span><span class="main">.</span>
        <span class="main">(</span><span class="bound">ret</span> <span class="main">⟶</span> Bus_invariant_2_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> Bus_invariant_3_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> Bus_variant <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
        <span class="main">(</span><span class="main">¬</span> <span class="bound">ret</span> <span class="main">⟶</span> Bus_invariant_2_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> Bus_invariant_3_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> Bus_invariant_1_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">⦄,</span>
    <span class="main">⦃</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">a</span><span class="main">.</span> Bus_invariant_2_2 <span class="main">(</span>fst <span class="bound">a</span><span class="main">)</span> <span class="main">∧</span> Bus_invariant_3_2 <span class="main">(</span>fst <span class="bound">a</span><span class="main">)</span> <span class="main">∧</span> Bus_invariant_1_2 <span class="main">(</span>fst <span class="bound">a</span><span class="main">)</span><span class="main">⦄</span>"</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Des_createInstance_def throwError_def returnOk_def Bus_invariant_2_2_def 
            Bus_invariant_3_2_def Bus_variant_def Bus_invariant_1_2_def  validE_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> des_impl_loadPlugin <span class="main">:</span> 
  <span class="quoted"><span class="quoted"><span class="language">"stringEqual <span class="free">pName</span> <span class="free">pluginName1</span> <span class="main">⟹</span> 
   int64Equal <span class="free">actID</span> <span class="free">actorID1</span> <span class="main">⟹</span>
    corres_underlying <span class="main">(</span><span class="main">{</span><span class="main">(</span><span class="bound">t</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> busPtrEqual <span class="free">busPtr</span> <span class="bound">s</span> <span class="main">(</span>fst <span class="bound">t</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> False False 
      <span class="main">(</span><span class="main">λ</span><span class="bound">retDes</span> <span class="bound">retImpl</span><span class="main">.</span> <span class="main">(</span><span class="bound">retDes</span> <span class="main">=</span> False <span class="main">∧</span> <span class="bound">retImpl</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span><span class="main">∨</span><span class="main">(</span><span class="bound">retDes</span> <span class="main">=</span> True <span class="main">∧</span> <span class="bound">retImpl</span> <span class="main">=</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>
       <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> Bus_invariant_2_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span>  Bus_invariant_3_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span>  <span class="main">∧</span> Bus_invariant_1_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span><span class="main">)</span>
       <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span> 
      <span class="main">(</span>Des_loadPlugin <span class="free">pName</span> <span class="free">actID</span><span class="main">)</span> <span class="main">(</span>Impl_loadPlugin <span class="free">busPtr</span> <span class="free">pluginName1</span> <span class="free">actorID1</span><span class="main">)</span> "</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Des_loadPlugin_def Impl_loadPlugin_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_l<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">ret</span> <span class="bound">s</span><span class="main">.</span> <span class="bound">ret</span> <span class="main">=</span> nRegisteredPlugin <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span>  Bus_invariant_2_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span><span class="main">∧</span> 
                                                 Bus_invariant_3_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span>  <span class="main">∧</span> Bus_invariant_1_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_if_condition<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> pluginNum
    <span class="keyword1"><span class="command">unfolding</span></span> busPtrEqual_def int32Equal_def PLUGIN_NUM_MAX_def
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">corres</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">simp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_underlying_split
        <span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> r' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">retDes</span> <span class="bound">resImpl</span><span class="main">.</span> <span class="main">(</span><span class="main">¬</span> <span class="bound">retDes</span> <span class="main">∧</span> <span class="bound">resImpl</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span><span class="bound">retDes</span> <span class="main">∧</span> <span class="bound">resImpl</span> <span class="main">=</span> <span class="main">1</span><span class="main">)</span> <span class="main">)</span> "</span></span></span>
           <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">ret</span> <span class="bound">s</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">ret</span> <span class="keyword1">then</span> Bus_invariant_2_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span>  Bus_invariant_3_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> Bus_variant <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span>
                             <span class="keyword1">else</span> Bus_invariant_2_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span>  Bus_invariant_3_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> Bus_invariant_1_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span></span>  
           <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span> "</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> pluginNum <span class="comment1">(* createInstance  *)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> catch_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_underlying_split_l<span class="main"><span class="main">[</span></span>
          <span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> r' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">retDes</span> <span class="bound">resImpl</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">retDes</span> <span class="keyword1">of</span> Inl <span class="bound">e</span> <span class="main">⇒</span> <span class="bound">e</span> <span class="main">=</span> <span class="inner_quoted">''emptyNameError''</span> <span class="main">∧</span> <span class="bound">resImpl</span> <span class="main">=</span> <span class="main">0</span><span class="main">|</span>
                                                       Inr <span class="bound">b</span> <span class="main">⇒</span> <span class="bound">b</span> <span class="main">=</span> True <span class="main">∧</span> <span class="bound">resImpl</span> <span class="main">=</span> <span class="main">1</span> <span class="main">)</span> "</span></span></span>
           <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">retDes</span> <span class="bound">s</span><span class="main">.</span>  <span class="keyword1">case</span> <span class="bound">retDes</span> <span class="keyword1">of</span> Inl <span class="bound">e</span> <span class="main">⇒</span> Bus_invariant_2_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span>  Bus_invariant_3_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> Bus_invariant_1_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span><span class="main">|</span>
                                                Inr <span class="bound">b</span> <span class="main">⇒</span> Bus_invariant_2_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span>  Bus_invariant_3_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span> Bus_variant <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">)</span>"</span></span></span>
           <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span> "</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> Des_createInstance_def throwError_def returnOk_def Bus_invariant_2_2_def Bus_invariant_3_2_def Bus_variant_def Bus_invariant_1_2_def 
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> Impl_createInstance_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">wpsimp</span> <span class="quasi_keyword">wp</span><span class="main"><span class="main">:</span></span>addPlugin_valid<span class="main">)</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="improper">rv</span>"</span></span></span><span class="main">)</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_underlying_symb_exec_l<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span>  Bus_invariant_2_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span>  <span class="main">∧</span> Bus_invariant_1_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> corres_underlying_def modify_def get_def put_def NonDetMonad.bind_def return_def
        <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">corres</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">wpsimp</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">insert</span> des_impl_createInstance<span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> corres_underlying_def<span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> pluginNum
    <span class="keyword1"><span class="command">unfolding</span></span> Impl_createInstance_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">wpsimp</span> <span class="quasi_keyword">wp</span><span class="main"><span class="main">:</span></span>des_impl_loadPlugin_aux3<span class="main">)</span><span class="main"><span class="keyword3">+</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
   <span class="keyword1"><span class="command">using</span></span>  des_impl_loadPlugin_aux1 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">simp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_underlying_split<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> r' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">r'</span><span class="main">.</span> True<span class="main">)</span> "</span></span></span> 
                                       <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span>   Bus_invariant_3_2 <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span> <span class="main">∧</span>  Bus_variant <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
                                       <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span> "</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>  <span class="comment1">(* modify  *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_modify_ret<span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> busPtrEqual_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> stringPtrListEqual_def<span class="main">)</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> pluginPtrListEqual_def pluginEqual_def<span class="main">)</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> a s'
      <span class="keyword1"><span class="command">unfolding</span></span> int64PtrListEqual_def int32Equal_def int64Equal_def Bus_invariant_2_2_def
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> r
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted"><span class="language">" <span class="skolem">r</span> <span class="main">=</span> <span class="main">(</span>length <span class="main">(</span>pluginOwner <span class="skolem">a</span><span class="main">)</span><span class="main">)</span>"</span></span></span><span class="main">)</span></span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> nth_append_length sint_scast<span class="main">)</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted"><span class="language">" <span class="skolem">r</span> <span class="main">=</span> nat <span class="main">(</span>sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="skolem">s'</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span></span><span class="main">)</span></span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span> 
        <span class="keyword1"><span class="command">using</span></span> ptr_equal
        <span class="keyword1"><span class="command">using</span></span> nat_int.Rep_eqD ptr_coerce_eq <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span>pluginOwner <span class="skolem">a</span> <span class="main">@</span> <span class="main">[</span>sint  <span class="free">actorID1</span><span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="improper">r</span>  <span class="main">=</span>  <span class="main">(</span>pluginOwner <span class="skolem">a</span> <span class="main">!</span> <span class="improper">r</span><span class="main">)</span> "</span></span></span><span class="main">)</span></span>  
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted"><span class="language">" <span class="improper">r</span> <span class="main">&lt;</span> <span class="main">(</span>length <span class="main">(</span>pluginOwner <span class="skolem">a</span><span class="main">)</span><span class="main">)</span>"</span></span></span><span class="main">)</span></span> 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> of_nat_less_imp_less owner_ptr_not_equal<span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> bus_valid_def pluginOwner_valid_def pluginList_valid_def pluginName_valid_def 
              Bus_invariant_3_2_def  Bus_variant_def
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> bus_valid_def pluginOwner_valid_def pluginList_valid_def pluginName_valid_def Bus_invariant_3_2_def
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>  
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_underlying_split<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> r' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">r'</span><span class="main">.</span> True<span class="main">)</span> "</span></span></span> 
                                       <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span>   Bus_variant <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span></span> 
                                       <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span> <span class="main">∧</span> heap_w8'ptr <span class="bound">s</span>
          <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span><span class="numeral">8</span> word ptr<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginName_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
         <span class="free">pluginName1</span><span class="main">)</span> "</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="comment1">(* modify  *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_modify_ret<span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> busPtrEqual_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> pluginPtrListEqual_def int64PtrListEqual_def<span class="main">)</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> pluginPtrListEqual_def stringPtrListEqual_def  int64PtrListEqual_def pluginEqual_def<span class="main">)</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">simp</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> a s'
      <span class="keyword1"><span class="command">unfolding</span></span> stringPtrListEqual_def int32Equal_def  Bus_invariant_3_2_def 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> r
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted"><span class="language">" <span class="skolem">r</span> <span class="main">=</span> <span class="main">(</span>length <span class="main">(</span>pluginName <span class="skolem">a</span><span class="main">)</span><span class="main">)</span>"</span></span></span><span class="main">)</span></span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> nth_append_length<span class="main">)</span></span> <span class="keyword1"><span class="command">using</span></span> ptr_equal <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fastforce</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span>pluginName <span class="skolem">a</span> <span class="main">@</span> <span class="main">[</span><span class="free">pName</span><span class="main">]</span><span class="main">)</span> <span class="main">!</span> <span class="improper">r</span>  <span class="main">=</span>  <span class="main">(</span>pluginName <span class="skolem">a</span> <span class="main">!</span> <span class="improper">r</span><span class="main">)</span> "</span></span></span><span class="main">)</span></span>  
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted"><span class="language">" <span class="improper">r</span> <span class="main">&lt;</span> <span class="main">(</span>length <span class="main">(</span>pluginName <span class="skolem">a</span><span class="main">)</span><span class="main">)</span>"</span></span></span><span class="main">)</span></span> 
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nth_append<span class="main">)</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> name_ptr_not_equal of_nat_less_imp_less<span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> bus_valid_def pluginOwner_valid_def pluginList_valid_def pluginName_valid_def Bus_variant_def
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> bus_valid_def pluginOwner_valid_def pluginList_valid_def pluginName_valid_def Bus_variant_def
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> Let_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_underlying_symb_exec_l<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span>  Bus_variant <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> corres_underlying_def gets_def get_def return_def NonDetMonad.bind_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_underlying_symb_exec_l<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> Bus_variant <span class="main">(</span>fst <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> corres_underlying_def gets_def get_def return_def NonDetMonad.bind_def modify_def put_def
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">ret</span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span> <span class="main">∧</span> <span class="bound">ret</span> <span class="main">=</span> 
                                 <span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> 
                                 sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span><span class="main">∧</span>heap_w8'ptr <span class="bound">s</span>
          <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span><span class="numeral">8</span> word ptr<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginName_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
         <span class="free">pluginName1</span>  <span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> plugin_ptr
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">ret</span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span> <span class="main">∧</span> <span class="skolem">plugin_ptr</span> <span class="main">=</span> 
                                 <span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> 
                                 sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> heap_w8'ptr <span class="bound">s</span>
          <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span><span class="numeral">8</span> word ptr<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginName_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
         <span class="free">pluginName1</span> <span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">ret</span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span> <span class="main">∧</span> <span class="bound">ret</span> <span class="main">=</span> 
                                 heap_w8'ptr <span class="bound">s</span> <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span><span class="numeral">8</span> word ptr<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginName_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span>
                                 sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> 
                                 <span class="skolem">plugin_ptr</span> <span class="main">=</span>  <span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> 
                                 sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> heap_w8'ptr <span class="bound">s</span>
          <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span><span class="numeral">8</span> word ptr<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginName_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
         <span class="free">pluginName1</span> <span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> aPluginName_ptr
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_underlying_split<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> r' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">r'</span><span class="main">.</span> True<span class="main">)</span> "</span></span></span> 
                                       <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span> "</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
        <span class="keyword1"><span class="command">unfolding</span></span> initializePlugin'_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span> <span class="keyword1"><span class="command">unfolding</span></span> bus_valid_def pluginOwner_valid_def pluginList_valid_def pluginName_valid_def 
        <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>  <span class="comment1">(* modify and initializePlugin'*)</span>
        <span class="keyword1"><span class="command">unfolding</span></span> initializePlugin'_def pluInitialize_def
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">ret</span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span> <span class="main">∧</span> <span class="skolem">aPluginName_ptr</span> <span class="main">=</span> <span class="free">pluginName1</span> <span class="main">∧</span>
          <span class="skolem">aPluginName_ptr</span> <span class="main">=</span> heap_w8'ptr <span class="bound">s</span> <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span><span class="numeral">8</span> word ptr<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginName_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span>
          <span class="skolem">plugin_ptr</span> <span class="main">=</span> <span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span> <span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">subst</span> bind_modify<span class="main">)</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_underlying_split_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> r' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">r'</span><span class="main">.</span> True<span class="main">)</span> "</span></span></span> 
                                       <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span>  True<span class="main">)</span>"</span></span></span> 
                                       <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">ret</span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> s
          <span class="keyword1"><span class="command">unfolding</span></span> bus_valid_def pluginOwner_valid_def pluginList_valid_def pluginName_valid_def 
          <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_modify_ret<span class="main">)</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> busPtrEqual_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> stringPtrListEqual_def 
          <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> int64PtrListEqual_def 
          <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> a s' 
          <span class="keyword1"><span class="command">unfolding</span></span>  pluginPtrListEqual_def
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">rule</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted"><span class="language">"nRegisteredPlugin <span class="skolem">a</span> <span class="main">=</span> int <span class="main">(</span>length <span class="main">(</span>pluginList <span class="skolem">a</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span> <span class="main">∧</span> nRegisteredPlugin <span class="skolem">a</span> <span class="main">≥</span> <span class="main">0</span>"</span></span></span><span class="main">)</span></span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="improper">r</span> <span class="main">=</span> nat <span class="main">(</span>nRegisteredPlugin <span class="skolem">a</span><span class="main">)</span>"</span></span></span><span class="main">)</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> r
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted"><span class="language">"
              <span class="main">(</span>pluginList <span class="skolem">a</span><span class="main">)</span>
                <span class="main">[</span>nat <span class="main">(</span>nRegisteredPlugin <span class="skolem">a</span><span class="main">)</span> <span class="main">:=</span> <span class="main">(</span>pluginList <span class="skolem">a</span> <span class="main">!</span> nat <span class="main">(</span>nRegisteredPlugin <span class="skolem">a</span><span class="main">)</span><span class="main">)</span>
                  <span class="main">⦇</span>plugin.name <span class="main">:=</span> <span class="free">pName</span><span class="main">,</span> plugin.actorID <span class="main">:=</span> <span class="free">actID</span><span class="main">,</span> plugin.state <span class="main">:=</span> pluginState.ACTOR_STATE_PAUSE<span class="main">,</span> duration <span class="main">:=</span> <span class="main">1</span><span class="main">⦈</span><span class="main">]</span> <span class="main">!</span> <span class="skolem">r</span> <span class="main">=</span> 
                  <span class="main">⦇</span>plugin.name <span class="main">=</span> <span class="free">pName</span><span class="main">,</span> plugin.actorID <span class="main">=</span> <span class="free">actID</span><span class="main">,</span> plugin.state <span class="main">=</span> pluginState.ACTOR_STATE_PAUSE<span class="main">,</span> duration <span class="main">=</span> <span class="main">1</span><span class="main">⦈</span> "</span></span></span><span class="main">)</span></span>
             <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> 
             <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span>nRegisteredPlugin <span class="skolem">a</span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span></span><span class="main">)</span></span>
                <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> plugin_update last_conv_nth last_list_update length_list_update list_update_nonempty nat_minus_as_int of_nat_1<span class="main">)</span></span>
            <span class="keyword1"><span class="command">unfolding</span></span> int32Equal_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>   <span class="keyword1"><span class="command">unfolding</span></span> pluginEqual_def int64Equal_def  statePluginEqual_def int32Equal_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
               <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">smt</span> name_ptr_not_equal ptr_equal<span class="main">)</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> 
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">subst</span> Pluduration_C_update2_2<span class="main">)</span></span>
            <span class="keyword1"><span class="command">using</span></span> Plustate_C_update1_2 ded_imp_pluginPAUSE <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">presburger</span></span>
            <span class="keyword1"><span class="command">using</span></span> Pluduration_C_update1_2 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span></span> 
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">subst</span> Pluduration_C_update4_2<span class="main">)</span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">subst</span> Plustate_C_update3_2<span class="main">)</span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">subst</span> Pluname_C_update1_2<span class="main">)</span></span> 
            <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> r 
            <span class="keyword1"><span class="command">unfolding</span></span> int32Equal_def
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
            <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="main">(</span><span class="operator">smt</span> name_ptr_not_equal ptr_equal<span class="main">)</span></span>
          <span class="keyword1"><span class="command">unfolding</span></span> Bus_variant_def 
          <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="comment1">(* modify *)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_underlying_split<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> r' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">r'</span><span class="main">.</span> True<span class="main">)</span> "</span></span></span> 
                                       <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> True<span class="main">)</span> "</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>      
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_modify_ret<span class="main">)</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> busPtrEqual_def 
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">metis</span> BusNRegisteredPlugin_C_update5<span class="main">)</span></span> 
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> int32Equal_def bus_valid_def<span class="main">)</span></span> 
      <span class="keyword1"><span class="command">using</span></span> word_axio1 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">simp</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> stringPtrListEqual_def stringEqual_def<span class="main">)</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> int64PtrListEqual_def stringEqual_def<span class="main">)</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> pluginPtrListEqual_def pluginEqual_def<span class="main">)</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>            
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>




<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="document"><span class="plain_text">‹startPlugin verify›</span></span></span>



<span class="keyword1"><span class="command">lemma</span></span> corres_callR_1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> cor<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">srel</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">rrel</span> <span class="free">G'</span> <span class="free">G</span> <span class="free">m2</span> <span class="free">m1</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> strel<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span> <span class="bound">t</span><span class="main">.</span> <span class="free">G''</span> <span class="bound">s</span> <span class="main">∧</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">srel'</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">v</span> <span class="bound">s</span><span class="main">,</span><span class="bound">t</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> urel<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span> <span class="bound">s''</span> <span class="bound">t'</span> <span class="bound">t''</span><span class="main">.</span> <span class="main">(</span><span class="bound">s</span><span class="main">,</span><span class="bound">s''</span><span class="main">)</span><span class="main">∈</span><span class="free">srel'</span> <span class="main">⟶</span> <span class="main">(</span><span class="bound">t'</span><span class="main">,</span><span class="bound">t''</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span> <span class="main">⟶</span> <span class="free">w</span> <span class="bound">s''</span> <span class="bound">t''</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">u</span> <span class="bound">s</span> <span class="bound">t'</span><span class="main">,</span><span class="bound">t''</span><span class="main">)</span><span class="main">∈</span><span class="free">srel'</span>"</span></span></span>
    <span class="keyword2"><span class="keyword">and</span></span> I<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s'</span><span class="main">.</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">s</span> <span class="main">=</span> <span class="bound">s'</span><span class="main">⦄</span>  <span class="free">m1</span> <span class="main">⦃</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">s</span><span class="main">.</span> <span class="free">w</span> <span class="bound">s'</span> <span class="bound">s</span><span class="main">⦄</span>"</span></span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> G<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">s</span><span class="main">.</span> <span class="free">G''</span> <span class="bound">s</span> <span class="main">⟶</span> <span class="free">G'</span> <span class="main">(</span><span class="free">v</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted"><span class="language">"corres_underlying <span class="free">srel'</span> <span class="free">nf</span> <span class="free">nf'</span> <span class="free">rrel</span> <span class="free">G''</span> <span class="free">G</span> <span class="main">(</span>NonDetMonad_call.call <span class="free">m2</span> <span class="free">v</span> <span class="free">u</span><span class="main">)</span> <span class="free">m1</span>"</span></span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="language"><span class="operator">-</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="language"><span class="var">?m</span></span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted"><span class="language">"NonDetMonad_call.call <span class="free">m2</span> <span class="free">v</span> <span class="free">u</span>"</span></span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">s</span> <span class="skolem">s''</span>
    <span class="keyword3"><span class="command">assume</span></span> sr<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G''</span> <span class="skolem">s</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">s</span><span class="main">,</span><span class="skolem">s''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> g1<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G''</span> <span class="skolem">s</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> g2<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G</span> <span class="skolem">s''</span>"</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> nf<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">nf</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="var">?m</span> <span class="skolem">s</span><span class="main">)</span>"</span></span></span>

    <span class="keyword1"><span class="command">from</span></span> cor <span class="keyword1"><span class="command">have</span></span> cor'<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="main">(</span><span class="bound">s</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span><span class="main">.</span> <span class="free">G'</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">G</span> <span class="bound">s'</span> <span class="main">⟶</span>
           <span class="main">(</span><span class="free">nf</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m2</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span>
           <span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r'</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m2</span> <span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">)</span> <span class="main">∧</span>
           <span class="main">(</span><span class="free">nf'</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m1</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>corres_underlying_def<span class="main">)</span></span>
    <span class="keyword1"><span class="command">from</span></span> strel sr <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">,</span><span class="skolem">s''</span><span class="main">)</span><span class="main">∈</span><span class="free">srel</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> g1 G <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">G'</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">simp</span></span>
    <span class="keyword1"><span class="command">moreover</span></span>
    <span class="keyword1"><span class="command">from</span></span> nf <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">nf</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad_call.call_def<span class="main">)</span></span> 
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> tg1<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r'</span><span class="main">,</span> <span class="bound">t''</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s''</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t'</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t'</span><span class="main">,</span> <span class="bound">t''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r'</span><span class="main">)</span>
      <span class="main">∧</span> <span class="main">(</span><span class="free">nf'</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m1</span> <span class="skolem">s''</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> g1 g2 cor' <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fast</span></span>

    <span class="keyword1"><span class="command">{</span></span>
      <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">r''</span> <span class="skolem">t''</span>
      <span class="keyword3"><span class="command">assume</span></span> rt<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r''</span><span class="main">,</span> <span class="skolem">t''</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s''</span><span class="main">)</span>"</span></span></span>
      <span class="keyword1"><span class="command">with</span></span> tg1 <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r'</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem"><span class="skolem">t'</span></span> <span class="keyword2"><span class="keyword">where</span></span> z<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r'</span><span class="main">,</span><span class="skolem">t'</span><span class="main">)</span><span class="main">∈</span>fst <span class="main">(</span><span class="free">m2</span> <span class="main">(</span><span class="free">v</span> <span class="skolem">s</span><span class="main">)</span><span class="main">)</span> <span class="main">∧</span> <span class="main">(</span><span class="skolem">t'</span><span class="main">,</span> <span class="skolem">t''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="skolem">r'</span> <span class="skolem">r''</span>"</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fast</span></span>
      <span class="keyword1"><span class="command">with</span></span> I rt <span class="keyword1"><span class="command">have</span></span> wst<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">w</span> <span class="skolem">s''</span> <span class="skolem">t''</span>"</span></span></span> 
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad.valid_def<span class="main">)</span></span>  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fastforce</span></span>

      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> rt<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">r</span><span class="main">,</span><span class="skolem">t</span><span class="main">)</span><span class="main">∈</span>fst <span class="main">(</span><span class="var">?m</span> <span class="skolem">s</span><span class="main">)</span> <span class="main">∧</span> <span class="skolem">t</span> <span class="main">=</span> <span class="free">u</span> <span class="skolem">s</span> <span class="skolem">t'</span>"</span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad_call.call_def<span class="main">)</span></span>
        <span class="keyword1"><span class="command">using</span></span> z <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fastforce</span></span> 
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="skolem">t</span><span class="main">,</span> <span class="skolem">t''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span>"</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> rt sr urel wst z <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
      <span class="keyword1"><span class="command">with</span></span> rt z <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="var">?m</span> <span class="skolem">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="skolem">t''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="skolem">r''</span>"</span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>NonDetMonad_call.call_def<span class="main">)</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">fastforce</span></span>
    <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">with</span></span> tg1 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">∀</span><span class="main">(</span><span class="bound">r''</span><span class="main">,</span> <span class="bound">t''</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="free">m1</span> <span class="skolem">s''</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">t</span><span class="main">)</span> <span class="main">∈</span> fst <span class="main">(</span><span class="var">?m</span> <span class="skolem">s</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">t</span><span class="main">,</span> <span class="bound">t''</span><span class="main">)</span> <span class="main">∈</span> <span class="free">srel'</span> <span class="main">∧</span> <span class="free">rrel</span> <span class="bound">r</span> <span class="bound">r''</span><span class="main">)</span> <span class="main">∧</span>
           <span class="main">(</span><span class="free">nf'</span> <span class="main">⟶</span> <span class="main">¬</span> snd <span class="main">(</span><span class="free">m1</span> <span class="skolem">s''</span><span class="main">)</span><span class="main">)</span>"</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">blast</span></span>
  <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="language"><span class="var">?thesis</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>corres_underlying_def<span class="main">)</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">force</span></span>
<span class="keyword1"><span class="command">qed</span></span>



<span class="keyword1"><span class="command">lemma</span></span> des_impl_startPlugin_aux0 <span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="free">P</span> <span class="keyword1">&lt;catch&gt;</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">global_exn_var</span><span class="main">,</span> <span class="bound">i</span><span class="main">,</span> <span class="bound">ret</span><span class="main">)</span><span class="main">.</span> return <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
      <span class="main">(</span><span class="keyword1">do</span> <span class="bound">x</span> <span class="main">&lt;-</span> <span class="free">P</span><span class="main">;</span>
       <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> Inl <span class="main">(</span><span class="bound">global_exn_var</span><span class="main">,</span> <span class="bound">i</span><span class="main">,</span> <span class="bound">ret</span><span class="main">)</span> <span class="main">⇒</span> return <span class="bound">i</span> <span class="main">|</span> Inr <span class="bound">b</span> <span class="main">⇒</span> return <span class="bound">b</span>
    <span class="keyword1">od</span> <span class="main">)</span>
     "</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> catch_def<span class="main">)</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">wpsimp</span></span>
<span class="keyword1"><span class="command">lemma</span></span> des_impl_startPlugin_aux1 <span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⋀</span><span class="bound">ret'</span><span class="main">.</span>
       stringEqual <span class="free">pName</span> <span class="free">pNameC</span> <span class="main">⟹</span>
       no_fail <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">r'</span><span class="main">≥</span><span class="main">0</span> <span class="main">∧</span> <span class="free">r'</span> <span class="main">&lt;</span> sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span> <span class="main">)</span>
        <span class="main">(</span>condition <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> compare' <span class="bound">s</span> <span class="free">pNameC</span> <span class="bound">ret'</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>
          <span class="main">(</span><span class="keyword1">do</span> <span class="bound">ret'</span> <span class="main">&lt;-</span>
              <span class="keyword1">do</span> <span class="bound">y</span> <span class="main">&lt;-</span>
                 guard <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> is_valid_GeneralPlugin_C <span class="bound">s</span> <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="free">r'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                 gets
                  <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> sint <span class="main">(</span>GeneralPlugin_C.actorID_C
                               <span class="main">(</span>heap_GeneralPlugin_C <span class="bound">s</span> <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="free">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
              <span class="keyword1">od</span><span class="main">;</span>
              return <span class="main">(</span><span class="keyword1">if</span> <span class="free">actID</span> <span class="main">=</span> <span class="bound">ret'</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>
           <span class="keyword1">od</span><span class="main">)</span>
          <span class="main">(</span>return <span class="main">0</span><span class="main">)</span>
        <span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">rule</span> non_fail_condition<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> bus_valid_def pluginList_valid_def
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">wpsimp</span></span>
<span class="keyword1"><span class="command">lemma</span></span> des_impl_startPlugin_aux21 <span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⋀</span><span class="bound">ret</span><span class="main">.</span> stringEqual <span class="free">pName</span> <span class="free">pNameC</span> <span class="main">⟹</span>
           <span class="bound">ret</span> <span class="main">≠</span> <span class="main">0</span> <span class="main">⟹</span>
           no_fail <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">r'</span><span class="main">≥</span><span class="main">0</span> <span class="main">∧</span> <span class="free">r'</span> <span class="main">&lt;</span> sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
            <span class="main">(</span>condition <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> GeneralPlugin_C.state_C
                             <span class="main">(</span>heap_GeneralPlugin_C <span class="bound">s</span> <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="free">r'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
                            impl_ACTOR_STATE_FINISH<span class="main">)</span>
              skip
              <span class="main">(</span><span class="keyword1">do</span> <span class="bound">y</span> <span class="main">&lt;-</span>
                  guard <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> is_valid_GeneralPlugin_C <span class="bound">s</span> <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="free">r'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                  modify
                   <span class="main">(</span>heap_GeneralPlugin_C_update
                     <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span><span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="free">r'</span> <span class="main">:=</span>
                               GeneralPlugin_C.state_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> impl_ACTOR_STATE_RUNNING<span class="main">)</span>
                                <span class="main">(</span><span class="bound">a</span> <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="free">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
               <span class="keyword1">od</span><span class="main">)</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">rule</span> non_fail_condition<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">∀</span><span class="bound">P</span><span class="main">.</span> no_fail <span class="bound">P</span> skip"</span></span></span><span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">fast</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> skip_def no_fail_def<span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> snd_return<span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> bus_valid_def pluginList_valid_def
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">simp</span></span>
<span class="keyword1"><span class="command">lemma</span></span> des_impl_startPlugin_aux2<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">⋀</span><span class="bound">y</span> <span class="bound">ret'</span> <span class="bound">ret</span><span class="main">.</span>
       stringEqual <span class="free">pName</span> <span class="free">pNameC</span> <span class="main">⟹</span>
       no_fail <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span> <span class="main">∧</span> <span class="free">r'</span><span class="main">≥</span><span class="main">0</span> <span class="main">∧</span> <span class="free">r'</span> <span class="main">&lt;</span> sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
        <span class="main">(</span><span class="keyword1">if</span> <span class="bound">ret</span> <span class="main">≠</span> <span class="main">0</span>
         <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="bound">y</span> <span class="main">&lt;-</span>
                 <span class="keyword1">do</span> guard
                     <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> is_valid_GeneralPlugin_C <span class="bound">s</span> <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="free">r'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                    condition <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> GeneralPlugin_C.state_C
                                     <span class="main">(</span>heap_GeneralPlugin_C <span class="bound">s</span>
                                       <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="free">r'</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
                                    impl_ACTOR_STATE_FINISH<span class="main">)</span>
                      skip
                      <span class="main">(</span><span class="keyword1">do</span> guard
                           <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> is_valid_GeneralPlugin_C <span class="bound">s</span>
                                  <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="free">r'</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                          modify
                           <span class="main">(</span>heap_GeneralPlugin_C_update
                             <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span><span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="free">r'</span> <span class="main">:=</span>
                                       GeneralPlugin_C.state_C_update <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> impl_ACTOR_STATE_RUNNING<span class="main">)</span>
                                        <span class="main">(</span><span class="bound">a</span> <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="free">r'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                       <span class="keyword1">od</span><span class="main">)</span>
                 <span class="keyword1">od</span><span class="main">;</span>
                 throwError <span class="main">(</span>Break<span class="main">,</span> <span class="free">r'</span><span class="main">,</span> <span class="bound">ret</span><span class="main">)</span>
              <span class="keyword1">od</span>
         <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="bound">y</span> <span class="main">&lt;-</span> guard <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> is_valid_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">;</span>
                 returnOk <span class="main">(</span><span class="free">r'</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>
              <span class="keyword1">od</span><span class="main">)</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="improper">ret</span> <span class="main">=</span> <span class="main">0</span>"</span></span></span><span class="main">)</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> bus_valid_def
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">rule</span> des_impl_startPlugin_aux21<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> pName <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">pName</span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> pNameC <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">pNameC</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">fast</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> bus_valid_def pluginList_valid_def
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
<span class="keyword1"><span class="command">lemma</span></span> des_impl_startPlugin_aux3<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">c</span> <span class="main">=</span> <span class="free">c'</span> <span class="main">⟹</span>
            <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span><span class="free">c</span><span class="main">⦃</span><span class="free">Q</span><span class="main">⦄</span> <span class="main">⟹</span> <span class="main">⦃</span><span class="free">P</span><span class="main">⦄</span><span class="free">c'</span><span class="main">⦃</span><span class="free">Q</span><span class="main">⦄</span>"</span></span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">simp</span></span>
<span class="keyword1"><span class="command">lemma</span></span> des_impl_startPlugin_aux4<span class="main">:</span> <span class="quoted"><span class="quoted"><span class="language">"stringEqual <span class="free">pName</span> <span class="free">pNameC</span> <span class="main">⟹</span>
    <span class="main">⦃</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">⦄</span>
    whileLoopE <span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">s</span><span class="main">.</span> <span class="main">0</span> <span class="main">≤</span> <span class="bound">r</span> <span class="main">∧</span> <span class="bound">r</span> <span class="main">&lt;</span> sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">do</span> <span class="bound">y</span> <span class="main">&lt;-</span> guard <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">r</span> <span class="main">&lt;</span> <span class="numeral">128</span><span class="main">)</span><span class="main">;</span>
              <span class="bound">ret'</span> <span class="main">&lt;-</span> getName' <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="bound">r</span><span class="main">)</span><span class="main">;</span>
              <span class="bound">ret</span> <span class="main">&lt;-</span> condition <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> compare' <span class="bound">s</span> <span class="free">pNameC</span> <span class="bound">ret'</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>
                       <span class="main">(</span><span class="keyword1">do</span> <span class="bound">ret'</span> <span class="main">&lt;-</span> getActorID' <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="bound">r</span><span class="main">)</span><span class="main">;</span>
                           return <span class="main">(</span><span class="keyword1">if</span> <span class="free">actID</span> <span class="main">=</span> <span class="bound">ret'</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>
                        <span class="keyword1">od</span><span class="main">)</span>
                       <span class="main">(</span>return <span class="main">0</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">if</span> <span class="bound">ret</span> <span class="main">≠</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="bound">y</span> <span class="main">&lt;-</span> resume' <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="bound">r</span><span class="main">)</span><span class="main">;</span>
                                  throwError <span class="main">(</span>Break<span class="main">,</span> <span class="bound">r</span><span class="main">,</span> <span class="bound">ret</span><span class="main">)</span>
                               <span class="keyword1">od</span>
              <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="bound">y</span> <span class="main">&lt;-</span> guard <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> is_valid_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">;</span>
                      returnOk <span class="main">(</span><span class="bound">r</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>
                   <span class="keyword1">od</span>
           <span class="keyword1">od</span><span class="main">)</span>
     <span class="main">0</span>  <span class="keyword1">&lt;catch&gt;</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">global_exn_var</span><span class="main">,</span> <span class="bound">i</span><span class="main">,</span> <span class="bound">ret</span><span class="main">)</span><span class="main">.</span> return <span class="bound">i</span><span class="main">)</span>
    <span class="main">⦃</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">⦄</span>"</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">subst</span> whileLoopE_add_inv
          <span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">λ</span><span class="bound">i</span> <span class="bound">s</span><span class="main">.</span>  bus_valid <span class="free">busPtr</span> <span class="bound">s</span>"</span></span></span> 
            <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> M<span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> nat <span class="main">(</span>sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="bound">i</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">unfold</span> validE_def getName'_def resume'_def getActorID'_def throwError_def bus_valid_def setState'_def returnOk_def pluginList_valid_def pluginOwner_valid_def pluginName_valid_def<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">blast</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>



<span class="keyword1"><span class="command">lemma</span></span> des_impl_startPlugin <span class="main">:</span>
  <span class="quoted"><span class="quoted"><span class="language">"stringEqual <span class="free">pName</span> <span class="free">pNameC</span> <span class="main">⟹</span>
    corres_underlying <span class="main">(</span><span class="main">{</span><span class="main">(</span><span class="bound">t</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> busPtrEqual <span class="free">busPtr</span> <span class="bound">s</span> <span class="main">(</span>fst <span class="bound">t</span><span class="main">)</span><span class="main">}</span><span class="main">)</span> False False 
      <span class="main">(</span><span class="main">λ</span><span class="bound">retDes</span> <span class="bound">retImpl</span><span class="main">.</span> <span class="main">(</span><span class="bound">retDes</span> <span class="main">=</span> False <span class="main">∧</span> <span class="bound">retImpl</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span><span class="main">∨</span><span class="main">(</span><span class="bound">retDes</span> <span class="main">=</span> True <span class="main">∧</span> <span class="bound">retImpl</span> <span class="main">=</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span> 
      <span class="main">(</span>Des_startPlugin <span class="free">pName</span> <span class="free">actID</span><span class="main">)</span> <span class="main">(</span>Impl_startPlugin <span class="free">busPtr</span> <span class="free">pNameC</span> <span class="free">actID</span><span class="main">)</span> "</span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">unfold</span> Des_startPlugin_def Impl_startPlugin_def<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> K_bind_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_underlying_split<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> r' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">desi</span> <span class="bound">impli</span><span class="main">.</span> int <span class="bound">desi</span> <span class="main">=</span> <span class="bound">impli</span> <span class="main">)</span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span> "</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> i
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_symb_exec_r<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span> bus_valid <span class="free">busPtr</span> <span class="bound">s</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_condition<span class="main">)</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_underlying_symb_exec_l<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Q <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> busEqual_def corres_underlying_def modify_def get_def put_def return_def NonDetMonad.bind_def 
      <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> busEqual_def corres_underlying_def modify_def get_def put_def return_def NonDetMonad.bind_def gets_def
      <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> busPtrEqual_def int32Equal_def <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">simp</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> catch_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_underlying_split<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> r' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="bound">e</span> <span class="bound">e'</span><span class="main">.</span> int <span class="bound">e</span> <span class="main">=</span> <span class="main">(</span>fst <span class="main">(</span>snd <span class="bound">e'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">⊕</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span> <span class="bound">b'</span><span class="main">.</span> int <span class="bound">b</span> <span class="main">=</span> <span class="bound">b'</span><span class="main">)</span> "</span></span></span> 
                                       <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> True<span class="main">)</span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> P' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span>  is_valid_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span> "</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">subst</span> whileLoopE_add_inv
          <span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I<span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">λ</span><span class="bound">i</span> <span class="bound">s</span><span class="main">.</span>  bus_valid <span class="free">busPtr</span> <span class="bound">s</span>"</span></span></span> 
            <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> M<span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">λ</span><span class="main">(</span><span class="bound">i</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> nat <span class="main">(</span>sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="bound">i</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>  <span class="keyword1"><span class="command">unfolding</span></span> validE_def throwError_def resume'_def setState'_def returnOk_def getActorID'_def getName'_def bus_valid_def
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span> 
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="language"><span class="improper">xa</span></span></span><span class="main">)</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">rule</span> des_impl_startPlugin_aux3<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> c<span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"whileLoopE <span class="main">(</span><span class="main">λ</span><span class="bound">r</span> <span class="bound">s</span><span class="main">.</span> <span class="main">0</span> <span class="main">≤</span> <span class="bound">r</span> <span class="main">∧</span> <span class="bound">r</span> <span class="main">&lt;</span> sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="keyword1">do</span> <span class="bound">y</span> <span class="main">&lt;-</span> guard <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">r</span> <span class="main">&lt;</span> <span class="numeral">128</span><span class="main">)</span><span class="main">;</span>
              <span class="bound">ret'</span> <span class="main">&lt;-</span> getName' <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="bound">r</span><span class="main">)</span><span class="main">;</span>
              <span class="bound">ret</span> <span class="main">&lt;-</span> condition <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> compare' <span class="bound">s</span> <span class="free">pNameC</span> <span class="bound">ret'</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span>
                       <span class="main">(</span><span class="keyword1">do</span> <span class="bound">ret'</span> <span class="main">&lt;-</span> getActorID' <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="bound">r</span><span class="main">)</span><span class="main">;</span>
                           return <span class="main">(</span><span class="keyword1">if</span> <span class="free">actID</span> <span class="main">=</span> <span class="bound">ret'</span> <span class="keyword1">then</span> <span class="main">1</span> <span class="keyword1">else</span> <span class="main">0</span><span class="main">)</span>
                        <span class="keyword1">od</span><span class="main">)</span>
                       <span class="main">(</span>return <span class="main">0</span><span class="main">)</span><span class="main">;</span>
              <span class="keyword1">if</span> <span class="bound">ret</span> <span class="main">≠</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="keyword1">do</span> <span class="bound">y</span> <span class="main">&lt;-</span> resume' <span class="main">(</span><span class="keyword1">PTR</span><span class="main">(</span>GeneralPlugin_C<span class="main">)</span> <span class="main">&amp;(</span><span class="free">busPtr</span><span class="main">→</span><span class="main">[</span><span class="inner_quoted">''pluginList_C''</span><span class="main">]</span><span class="main">)</span> <span class="keyword1">+<span class="hidden">⇩</span><sub>p</sub></span> <span class="bound">r</span><span class="main">)</span><span class="main">;</span>
                                  throwError <span class="main">(</span>Break<span class="main">,</span> <span class="bound">r</span><span class="main">,</span> <span class="bound">ret</span><span class="main">)</span>
                               <span class="keyword1">od</span>
              <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="bound">y</span> <span class="main">&lt;-</span> guard <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> is_valid_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">;</span>
                      returnOk <span class="main">(</span><span class="bound">r</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>
                   <span class="keyword1">od</span>
           <span class="keyword1">od</span><span class="main">)</span>
     <span class="main">0</span>  <span class="keyword1">&lt;catch&gt;</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">global_exn_var</span><span class="main">,</span> <span class="bound">i</span><span class="main">,</span> <span class="bound">ret</span><span class="main">)</span><span class="main">.</span> return <span class="bound">i</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">rule</span> des_impl_startPlugin_aux0<span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">rule</span> des_impl_startPlugin_aux4<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> pName <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">pName</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">simp</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">rule</span> corres_whileLoopE<span class="main">)</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> r r' s s'
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="language"><span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="language"><span class="skolem">r</span></span></span><span class="main">)</span></span>  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> busPtrEqual_def int32Equal_def <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">defer</span></span></span></span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> r'
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>  <span class="keyword1"><span class="command">unfolding</span></span> validE_def 
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span> <span class="keyword1"><span class="command">unfolding</span></span> resume'_def setState'_def getActorID'_def getName'_def returnOk_def bus_valid_def
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pluginOwner_valid_def  pluginList_valid_def pluginName_valid_def
    <span class="keyword1"><span class="command">by</span></span> <span class="language"><span class="operator">wpsimp</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> r' <span class="comment1">(*no fail*)</span>
    <span class="keyword1"><span class="command">unfolding</span></span> getName'_def resume'_def setState'_def getActorID'_def bus_valid_def pluginOwner_valid_def pluginList_valid_def
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">rule</span> des_impl_startPlugin_aux1<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> pName <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">pName</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">simp</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">rule</span> des_impl_startPlugin_aux2<span class="main"><span class="main">[</span></span><span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> pName <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="free">pName</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">simp</span></span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span><span class="main"><span class="keyword3">+</span></span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> bus_valid_def 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span> 
    <span class="keyword1"><span class="command">unfolding</span></span> pluginOwner_valid_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> pluginList_valid_def <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span> 
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> r' s' <span class="comment1">(*terminates*)</span>
     <span class="keyword1"><span class="command">unfolding</span></span> whileLoop_terminatesE_def throwError_def returnOk_def
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="main">(</span><span class="operator">rule</span> whileLoop_terminates_inv<span class="main"><span class="main">[</span></span>
                <span class="language"><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"<span class="main">λ</span><span class="main"><span class="bound">_</span></span> <span class="bound">s</span><span class="main">.</span>  bus_valid <span class="free">busPtr</span> <span class="bound">s</span>  "</span></span></span> 
                  <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> R <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="language">"measure' <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">r</span><span class="main">,</span><span class="bound">s</span><span class="main">)</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">r</span> <span class="keyword1">of</span> Inl <span class="bound">a</span> <span class="main">⇒</span> <span class="main">0</span> <span class="main">|</span>
                             Inr <span class="bound">v</span> <span class="main">⇒</span> nat <span class="main">(</span>sint <span class="main">(</span>nRegisteredPlugin_C <span class="main">(</span>heap_GeneralBus_C <span class="bound">s</span> <span class="free">busPtr</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> nat <span class="bound">v</span><span class="main">)</span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span> <span class="keyword1"><span class="command">unfolding</span></span> NonDetMonad.lift_def getName'_def resume'_def setState'_def getActorID'_def  bus_valid_def
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">wpsimp</span></span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="language"><span class="operator">auto</span></span>
     unfolding pluginOwner_valid_def  pluginList_valid_def pluginName_valid_def
     apply simp
     by auto 
  subgoal for r 
    apply(rule corres_symb_exec_r[where Q' = "(λ_ s. bus_valid busPtr s )"])
       apply(rule corres_symb_exec_r[where Q' = "(λret s. bus_valid busPtr s ∧ 
          ret = GeneralPlugin_C.name_C (heap_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r)) )"])
    defer unfolding getName'_def  apply wpsimp+
  subgoal for ret'
    apply (rule corres_symb_exec_l[where Q = "(λrdes sdes. rdes = pluginList (fst sdes) ! r)"])
    defer apply wpsimp apply wpsimp apply wpsimp
    subgoal for p
      apply (rule corres_symb_exec_r
              [where Q' = "λrimpl simpl.  (if rimpl = 0
                             then  (compare' simpl pNameC ret' ≠ 0 ∨
                                actID ≠ sint (GeneralPlugin_C.actorID_C (heap_GeneralPlugin_C simpl (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r))))  
                              else  (rimpl = 1 ∧  compare' simpl pNameC ret' = 0 ∧ 
                                actID = sint (GeneralPlugin_C.actorID_C (heap_GeneralPlugin_C simpl (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r))))) ∧
                ret' = GeneralPlugin_C.name_C (heap_GeneralPlugin_C simpl (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r))"])
      subgoal for ret
      apply (rule corres_if_simple)
        subgoal (*need to proof compare'*)
          apply auto
          unfolding busPtrEqual_def pluginPtrListEqual_def getPlugName_def pluginEqual_def getPlugActorID_def int64Equal_def
          using compare_string compare_string_1
          by blast+
       defer 
      subgoal 
         apply(rule corres_symb_exec_r[where Q' = "(λ_ _. True)"])
           apply corres
        by wpsimp+
      subgoal (*need to proof call des_resume and impl_resume*)
        apply(rule corres_underlying_split[where r' = "(λ_ _. True)" and P = "(λ_ _. True)" and P' = "(λ_ _. True) "])
        defer
        apply wpsimp+
        apply (rule corres_callR_nr[where srel = "({(ds,is). pluginEqual (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r) is (fst ds)})" 
          and Gx = "λds. fst ds = p" ])
        subgoal 
          using des_imp_resume[where plu = "(PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r)"]
          unfolding corres_underlying_def 
          by auto
        subgoal unfolding busPtrEqual_def pluginPtrListEqual_def apply auto done
        subgoal unfolding busPtrEqual_def pluginPtrListEqual_def  apply auto done
        apply auto
        done
      done
    subgoal 
      unfolding getActorID'_def
      by wpsimp
    subgoal for s
      apply wpsimp 
      unfolding getActorID'_def
        apply wpsimp+
      done
    unfolding getActorID'_def
    by wpsimp
    done
    done
  done


  
subsection ‹pausePlugin verify›

lemma des_impl_pausePlugin_aux1: "stringEqual pName pNameC ⟹
    ⦃λs. bus_valid busPtr s⦄
    whileLoopE (λr s. 0 ≤ r ∧ r &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)))
      (λr. do y &lt;- guard (λs. r &lt; 128);
              ret' &lt;- getName' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r);
              ret &lt;- condition (λs. compare' s pNameC ret' = 0)
                       (do ret' &lt;- getActorID' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r);
                           return (if actID = ret' then 1 else 0)
                        od)
                       (return 0);
              if ret ≠ 0 then do y &lt;- pause' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r);
                                  throwError (Break, r, ret)
                               od
              else do y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
                      returnOk (r + 1)
                   od
           od)
     0  &lt;catch&gt; (λ(global_exn_var, i, ret). return i)
    ⦃λx s. bus_valid busPtr s⦄"
  apply(subst whileLoopE_add_inv
          [where I= "λi s.  bus_valid busPtr s" 
            and M= "λ(i,s). nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) - i)"])
  apply wp
  apply (unfold validE_def getName'_def pause'_def getActorID'_def throwError_def bus_valid_def setState'_def returnOk_def pluginList_valid_def pluginOwner_valid_def pluginName_valid_def)
  apply wpsimp
   apply blast
  by auto

lemma des_impl_pausePlugin_aux21 : "⋀ret. stringEqual pName pNameC ⟹
           ret ≠ 0 ⟹
           no_fail (λs. bus_valid busPtr s ∧ r'≥0 ∧ r' &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)))
            (condition (λs. GeneralPlugin_C.state_C
                             (heap_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r')) =
                            impl_ACTOR_STATE_FINISH)
              skip
              (condition (λs. GeneralPlugin_C.state_C
                               (heap_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r')) =
                              impl_ACTOR_STATE_PAUSE)
                skip
                (do y &lt;- guard (λs. is_valid_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r'));
                    modify
                     (heap_GeneralPlugin_C_update
                       (λa. a(PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r' :=
                                 GeneralPlugin_C.state_C_update (λa. impl_ACTOR_STATE_PAUSE)
                                  (a (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r')))))
                 od)))"
  apply (rule non_fail_condition)
  apply auto
  subgoal
   apply (subgoal_tac "∀P. no_fail P skip")
    apply fast
    apply (unfold skip_def no_fail_def)
    apply (simp add: snd_return)
    done
  apply (rule non_fail_condition)
  apply auto unfolding skip_def
  apply wpsimp+
  unfolding bus_valid_def pluginList_valid_def
  by simp


lemma des_impl_pausePlugin_aux2: "⋀y ret' ret.
       stringEqual pName pNameC ⟹
       no_fail (λs. bus_valid busPtr s ∧ r'≥0 ∧ r' &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)))
        (if ret ≠ 0
         then do y &lt;-
                 do guard (λs. is_valid_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r'));
                    condition (λs. GeneralPlugin_C.state_C
                                     (heap_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r')) =
                                    impl_ACTOR_STATE_FINISH)
                      skip
                      (condition (λs. GeneralPlugin_C.state_C
                                       (heap_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r')) =
                                      impl_ACTOR_STATE_PAUSE)
                        skip
                        (do guard (λs. is_valid_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r'));
                            modify
                             (heap_GeneralPlugin_C_update
                               (λa. a(PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r' :=
                                         GeneralPlugin_C.state_C_update (λa. impl_ACTOR_STATE_PAUSE)
                                          (a (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r')))))
                         od))
                 od;
                 throwError (Break, r', ret)
              od
         else do y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
                 returnOk (r' + 1)
              od)"
  apply (case_tac "ret = 0")
   apply auto
  subgoal 
    unfolding bus_valid_def
    by wpsimp
  apply wpsimp
  apply (rule des_impl_pausePlugin_aux21[where pName = "pName" and pNameC = "pNameC"])
  apply wpsimp+
  apply fast
  apply wpsimp+
  unfolding bus_valid_def pluginList_valid_def
  by auto


lemma des_impl_pausePlugin :
  "stringEqual pName pNameC ⟹
    corres_underlying ({(t,s). busPtrEqual busPtr s (fst t)}) False False 
      (λretDes retImpl. (retDes = False ∧ retImpl = 0)∨(retDes = True ∧ retImpl = 1)) (λ_. True) (λs. bus_valid busPtr s) 
      (Des_pausePlugin pName actID) (Impl_pausePlugin busPtr pNameC actID) "
  apply(unfold Des_pausePlugin_def Impl_pausePlugin_def)
  apply(rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s)"])
     defer apply wpsimp+ unfolding K_bind_def
  apply(rule corres_underlying_split[where r' = "(λdesi impli. int desi = impli )" and P = "(λ_ _. True)" and P' = "(λ_ s. bus_valid busPtr s) "])
     defer apply wpsimp defer  apply auto
  subgoal for i
    apply(rule corres_symb_exec_r[where Q' = "(λ_ s. bus_valid busPtr s)"])
       defer apply wpsimp+
    apply(rule corres_condition)
      defer 
    subgoal
      unfolding busEqual_def corres_underlying_def modify_def get_def put_def return_def NonDetMonad.bind_def 
      by auto
    apply wpsimp+
    unfolding busPtrEqual_def int32Equal_def by simp
 unfolding catch_def
  apply(rule corres_underlying_split[where r' = "(λe e'. int e = (fst (snd e'))) ⊕ (λb b'. int b = b') " 
                                       and P = "(λ_ _. True)" and P' = "(λ_ s.  is_valid_GeneralBus_C s busPtr) "])
      defer apply wpsimp 
  subgoal 
    apply(subst whileLoopE_add_inv
          [where I= "λi s.  bus_valid busPtr s" 
            and M= "λ(i,s). nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) - i)"])
    apply wpsimp  unfolding validE_def throwError_def pause'_def setState'_def returnOk_def getActorID'_def getName'_def bus_valid_def
    by wpsimp+ 
  subgoal apply auto apply(case_tac xa) by auto
 subgoal
    apply (rule des_impl_startPlugin_aux3[where c= "whileLoopE (λr s. 0 ≤ r ∧ r &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)))
      (λr. do y &lt;- guard (λs. r &lt; 128);
              ret' &lt;- getName' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r);
              ret &lt;- condition (λs. compare' s pNameC ret' = 0)
                       (do ret' &lt;- getActorID' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r);
                           return (if actID = ret' then 1 else 0)
                        od)
                       (return 0);
              if ret ≠ 0 then do y &lt;- pause' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r);
                                  throwError (Break, r, ret)
                               od
              else do y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
                      returnOk (r + 1)
                   od
           od)
     0  &lt;catch&gt; (λ(global_exn_var, i, ret). return i)"])
    apply (rule des_impl_startPlugin_aux0)
    apply (rule des_impl_pausePlugin_aux1[where pName = "pName"])
    apply simp
    done
 apply(rule corres_whileLoopE)
  subgoal for r r' s s'
    apply(case_tac r)  apply auto
    unfolding busPtrEqual_def int32Equal_def by auto
  defer apply wpsimp
  subgoal for r'
    apply wpsimp  unfolding validE_def 
     apply wpsimp unfolding pause'_def setState'_def getActorID'_def getName'_def returnOk_def bus_valid_def
         apply wpsimp+
    unfolding pluginOwner_valid_def  pluginList_valid_def pluginName_valid_def
    by wpsimp
  apply auto
  subgoal for r' (*no fail*)
    unfolding getName'_def pause'_def setState'_def getActorID'_def bus_valid_def pluginOwner_valid_def pluginList_valid_def
    apply wpsimp
    apply (rule des_impl_startPlugin_aux1[where pName = "pName"])
    apply simp
    apply (rule des_impl_pausePlugin_aux2[where pName = "pName"])
        apply simp
       apply wpsimp+
    unfolding bus_valid_def 
    apply auto 
    unfolding pluginOwner_valid_def apply auto
    unfolding pluginList_valid_def apply auto 
    done
 subgoal for r' s' (*terminates*)
    unfolding whileLoop_terminatesE_def throwError_def returnOk_def
     apply (rule whileLoop_terminates_inv[
                where I = "λ_ s.  bus_valid busPtr s  " 
                  and R = "measure' (λ(r,s). case r of Inl a ⇒ 0 |
                             Inr v ⇒ nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr))) - nat v)"])
     apply auto unfolding NonDetMonad.lift_def getName'_def pause'_def setState'_def getActorID'_def  bus_valid_def
     apply wpsimp
     apply auto
     unfolding pluginOwner_valid_def  pluginList_valid_def pluginName_valid_def
     apply simp
     by auto 
  subgoal for r 
    apply(rule corres_symb_exec_r[where Q' = "(λ_ s. bus_valid busPtr s )"])
       apply(rule corres_symb_exec_r[where Q' = "(λret s. bus_valid busPtr s ∧ 
          ret = GeneralPlugin_C.name_C (heap_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r)) )"])
    defer unfolding getName'_def  apply wpsimp+
  subgoal for ret'
    apply (rule corres_symb_exec_l[where Q = "(λrdes sdes. rdes = pluginList (fst sdes) ! r)"])
    defer apply wpsimp apply wpsimp apply wpsimp
    subgoal for p
     apply (rule corres_symb_exec_r
              [where Q' = "λrimpl simpl.  (if rimpl = 0
                             then  (compare' simpl pNameC ret' ≠ 0 ∨
                                actID ≠ sint (GeneralPlugin_C.actorID_C (heap_GeneralPlugin_C simpl (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r))))  
                              else  (rimpl = 1 ∧  compare' simpl pNameC ret' = 0 ∧ 
                                actID = sint (GeneralPlugin_C.actorID_C (heap_GeneralPlugin_C simpl (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r))))) ∧
                ret' = GeneralPlugin_C.name_C (heap_GeneralPlugin_C simpl (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r))"])
    subgoal for ret
      apply (rule corres_if_simple)
        subgoal (*need to proof compare'*)
          apply auto
          unfolding busPtrEqual_def pluginPtrListEqual_def getPlugName_def pluginEqual_def getPlugActorID_def int64Equal_def
          using compare_string compare_string_1
          by blast+
       defer 
      subgoal 
         apply(rule corres_symb_exec_r[where Q' = "(λ_ _. True)"])
           apply corres
        by wpsimp+
    subgoal (*need to proof call des_pasue and impl_pasue*)
        apply(rule corres_underlying_split[where r' = "(λ_ _. True)" and P = "(λ_ _. True)" and P' = "(λ_ _. True) "])
        defer
         apply wpsimp+
        apply (rule corres_callR_nr[where srel = "({(ds,is). pluginEqual (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r) is (fst ds)})" 
          and Gx = "λds. fst ds = p" ])
        subgoal 
          using des_imp_pause[where plu = "(PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r)"]
          unfolding corres_underlying_def 
          by auto
        subgoal unfolding busPtrEqual_def pluginPtrListEqual_def apply auto done
        subgoal unfolding busPtrEqual_def pluginPtrListEqual_def  apply auto done
        apply auto
        done
    done
  subgoal 
      unfolding getActorID'_def
      by wpsimp
    subgoal for s
      apply wpsimp 
      unfolding getActorID'_def
        apply wpsimp+
      done
    unfolding getActorID'_def
    by wpsimp
    done
    done
  done


subsection ‹stopPlugin verify›


lemma des_impl_stopPlugin_aux1: "stringEqual pName pNameC ⟹
    ⦃λs. bus_valid busPtr s⦄
    whileLoopE (λr s. 0 ≤ r ∧ r &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)))
      (λr. do y &lt;- guard (λs. r &lt; 128);
               ret' &lt;- getName' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r);
               ret &lt;- condition (λs. compare' s pNameC ret' = 0)
                        (do ret' &lt;- getActorID' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r);
                            return (if actID = ret' then 1 else 0)
                         od)
                        (return 0);
               if ret ≠ 0 then do y &lt;- stop' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r);
                                   throwError (Break, r, ret)
                                od
               else do y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
                       returnOk (r + 1)
                    od
            od)
     0 &lt;catch&gt;
    (λ(global_exn_var, i, ret). return i) 
    ⦃λx s. bus_valid busPtr s⦄"
  apply(subst whileLoopE_add_inv
          [where I= "λi s.  bus_valid busPtr s" 
            and M= "λ(i,s). nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) - i)"])
  apply wp
  apply (unfold validE_def getName'_def stop'_def getActorID'_def throwError_def bus_valid_def setState'_def returnOk_def pluginList_valid_def pluginOwner_valid_def pluginName_valid_def)
  apply wpsimp
   apply blast
  by auto

lemma des_impl_stopPlugin_aux21 : "⋀ret. stringEqual pName pNameC ⟹
           ret ≠ 0 ⟹
           no_fail (λs. bus_valid busPtr s ∧ r'≥0 ∧ r' &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)))
            (condition (λs. GeneralPlugin_C.state_C
                             (heap_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r')) =
                            impl_ACTOR_STATE_FINISH)
              skip
              (do y &lt;- guard (λs. is_valid_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r'));
                  modify
                   (heap_GeneralPlugin_C_update
                     (λa. a(PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r' :=
                               GeneralPlugin_C.state_C_update (λa. impl_ACTOR_STATE_FINISH)
                                (a (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r')))))
               od))"
  apply (rule non_fail_condition)
  apply auto
  subgoal
   apply (subgoal_tac "∀P. no_fail P skip")
    apply fast
    apply (unfold skip_def no_fail_def)
    apply (simp add: snd_return)
    done
  apply wpsimp+
  unfolding bus_valid_def pluginList_valid_def
  by simp


lemma des_impl_stopPlugin_aux2: "⋀y ret' ret.
       stringEqual pName pNameC ⟹
       no_fail (λs. bus_valid busPtr s ∧ r'≥0 ∧ r' &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)))
        (if ret ≠ 0
         then do y &lt;-
                 do guard (λs. is_valid_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r'));
                    condition (λs. GeneralPlugin_C.state_C
                                     (heap_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r')) =
                                    impl_ACTOR_STATE_FINISH)
                      skip
                      (do guard (λs. is_valid_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r'));
                          modify
                           (heap_GeneralPlugin_C_update
                             (λa. a(PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r' :=
                                       GeneralPlugin_C.state_C_update (λa. impl_ACTOR_STATE_FINISH)
                                        (a (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r')))))
                       od)
                 od;
                 throwError (Break, r', ret)
              od
         else do y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
                 returnOk (r' + 1)
              od)"
  apply (case_tac "ret = 0")
   apply auto
  subgoal 
    unfolding bus_valid_def
    by wpsimp
  apply wpsimp
  apply (rule des_impl_stopPlugin_aux21[where pName = "pName" and pNameC = "pNameC"])
  apply wpsimp+
  apply fast
  apply wpsimp+
  unfolding bus_valid_def pluginList_valid_def
  by auto


lemma des_impl_stopPlugin :
  "stringEqual pName pNameC ⟹
    corres_underlying ({(t,s). busPtrEqual busPtr s (fst t)}) False False 
      (λretDes retImpl. (retDes = False ∧ retImpl = 0)∨(retDes = True ∧ retImpl = 1)) (λ_. True) (λs. bus_valid busPtr s) 
      (Des_stopPlugin pName actID) (Impl_stopPlugin busPtr pNameC actID) "
  apply(unfold Des_stopPlugin_def Impl_stopPlugin_def)
  apply(rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s)"])
     defer apply wpsimp+ unfolding K_bind_def
  apply(rule corres_underlying_split[where r' = "(λdesi impli. int desi = impli )" and P = "(λ_ _. True)" and P' = "(λ_ s. bus_valid busPtr s) "])
     defer apply wpsimp defer  apply auto
  subgoal for i
    apply(rule corres_symb_exec_r[where Q' = "(λ_ s. bus_valid busPtr s)"])
       defer apply wpsimp+
    apply(rule corres_condition)
      defer
      apply(rule corres_underlying_symb_exec_l[where Q = "(λ_ _. True)"])
    subgoal
      unfolding busEqual_def corres_underlying_def modify_def get_def put_def return_def NonDetMonad.bind_def 
      by auto
    apply wpsimp+
    subgoal
      unfolding busEqual_def corres_underlying_def modify_def get_def put_def return_def NonDetMonad.bind_def gets_def
      by auto
    unfolding busPtrEqual_def int32Equal_def by simp
 unfolding catch_def
  apply(rule corres_underlying_split[where r' = "(λe e'. int e = (fst (snd e'))) ⊕ (λb b'. int b = b') " 
                                       and P = "(λ_ _. True)" and P' = "(λ_ s.  is_valid_GeneralBus_C s busPtr) "])
      defer apply wpsimp 
  subgoal 
    apply(subst whileLoopE_add_inv
          [where I= "λi s.  bus_valid busPtr s" 
            and M= "λ(i,s). nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) - i)"])
    apply wpsimp  unfolding validE_def throwError_def stop'_def setState'_def returnOk_def getActorID'_def getName'_def bus_valid_def
    by wpsimp+ 
  subgoal apply auto apply(case_tac xa) by auto
 subgoal
    apply (rule des_impl_startPlugin_aux3[where c= "whileLoopE (λr s. 0 ≤ r ∧ r &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)))
      (λr. do y &lt;- guard (λs. r &lt; 128);
              ret' &lt;- getName' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r);
              ret &lt;- condition (λs. compare' s pNameC ret' = 0)
                       (do ret' &lt;- getActorID' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r);
                           return (if actID = ret' then 1 else 0)
                        od)
                       (return 0);
              if ret ≠ 0 then do y &lt;- stop' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r);
                                  throwError (Break, r, ret)
                               od
              else do y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
                      returnOk (r + 1)
                   od
           od)
     0  &lt;catch&gt; (λ(global_exn_var, i, ret). return i)"])
    apply (rule des_impl_startPlugin_aux0)
    apply (rule des_impl_stopPlugin_aux1[where pName = "pName"])
    apply simp
    done
 apply(rule corres_whileLoopE)
  subgoal for r r' s s'
    apply(case_tac r)  apply auto
    unfolding busPtrEqual_def int32Equal_def by auto
  defer apply wpsimp
  subgoal for r'
    apply wpsimp  unfolding validE_def 
     apply wpsimp unfolding stop'_def setState'_def getActorID'_def getName'_def returnOk_def bus_valid_def
         apply wpsimp+
    unfolding pluginOwner_valid_def  pluginList_valid_def pluginName_valid_def
    by wpsimp
  apply auto
  subgoal for r' (*no fail*)
    unfolding getName'_def stop'_def setState'_def getActorID'_def bus_valid_def pluginOwner_valid_def pluginList_valid_def
    apply wpsimp
    apply (rule des_impl_startPlugin_aux1[where pName = "pName"])
    apply simp
    apply (rule des_impl_stopPlugin_aux2[where pName = "pName"])
        apply simp
       apply wpsimp+
    unfolding bus_valid_def 
    apply auto 
    unfolding pluginOwner_valid_def apply auto
    unfolding pluginList_valid_def apply auto 
    done
 subgoal for r' s' (*terminates*)
     unfolding whileLoop_terminatesE_def throwError_def returnOk_def
     apply (rule whileLoop_terminates_inv[
                where I = "λ_ s.  bus_valid busPtr s  " 
                  and R = "measure' (λ(r,s). case r of Inl a ⇒ 0 |
                             Inr v ⇒ nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr))) - nat v)"])
     apply auto unfolding NonDetMonad.lift_def getName'_def stop'_def setState'_def getActorID'_def  bus_valid_def
     apply wpsimp
     apply auto
     unfolding pluginOwner_valid_def  pluginList_valid_def pluginName_valid_def
     apply simp
     by auto 
  subgoal for r 
    apply(rule corres_symb_exec_r[where Q' = "(λ_ s. bus_valid busPtr s )"])
       apply(rule corres_symb_exec_r[where Q' = "(λret s. bus_valid busPtr s ∧ 
          ret = GeneralPlugin_C.name_C (heap_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r)) )"])
    defer unfolding getName'_def  apply wpsimp+
  subgoal for ret'
    apply (rule corres_symb_exec_l[where Q = "(λrdes sdes. rdes = pluginList (fst sdes) ! r)"])
    defer apply wpsimp apply wpsimp apply wpsimp
    subgoal for p
     apply (rule corres_symb_exec_r
              [where Q' = "λrimpl simpl.  (if rimpl = 0
                             then  (compare' simpl pNameC ret' ≠ 0 ∨
                                actID ≠ sint (GeneralPlugin_C.actorID_C (heap_GeneralPlugin_C simpl (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r))))  
                              else  (rimpl = 1 ∧  compare' simpl pNameC ret' = 0 ∧ 
                                actID = sint (GeneralPlugin_C.actorID_C (heap_GeneralPlugin_C simpl (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r))))) ∧
                ret' = GeneralPlugin_C.name_C (heap_GeneralPlugin_C simpl (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r))"])
    subgoal for ret
      apply (rule corres_if_simple)
        subgoal (*need to proof compare'*)
          apply auto
          unfolding busPtrEqual_def pluginPtrListEqual_def getPlugName_def pluginEqual_def getPlugActorID_def int64Equal_def
          using compare_string compare_string_1
          by blast+
       defer 
      subgoal 
         apply(rule corres_symb_exec_r[where Q' = "(λ_ _. True)"])
           apply corres
        by wpsimp+
    subgoal  (*need to proof call des_stop and impl_stop*)
        apply(rule corres_underlying_split[where r' = "(λ_ _. True)" and P = "(λ_ _. True)" and P' = "(λ_ _. True) "])
        defer
         apply wpsimp+
          apply (rule corres_callR_nr[where srel = "({(ds,is). pluginEqual (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r) is (fst ds)})" 
          and Gx = "λds. fst ds = p" ])
        subgoal 
          using des_imp_stop[where plu = "(PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r)"]
          unfolding corres_underlying_def 
          by auto
        subgoal unfolding busPtrEqual_def pluginPtrListEqual_def apply auto done
        subgoal unfolding busPtrEqual_def pluginPtrListEqual_def  apply auto done
        apply auto
        done
    done
  subgoal 
      unfolding getActorID'_def
      by wpsimp
    subgoal for s
      apply wpsimp 
      unfolding getActorID'_def
        apply wpsimp+
      done
    unfolding getActorID'_def
    by wpsimp
    done
    done
  done



subsection ‹startActorPlugins verify›


lemma des_impl_startActorPlugins_aux0:
  "⦃λs. is_valid_GeneralBus_C s busPtr ⟶ bus_valid busPtr s⦄ 
    resume' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r') 
  ⦃λya s. is_valid_GeneralBus_C s busPtr ⟶ bus_valid busPtr s⦄"
  unfolding resume'_def setState'_def 
  apply wpsimp
  unfolding bus_valid_def pluginOwner_valid_def pluginList_valid_def pluginName_valid_def
  by auto 

lemma des_impl_startActorPlugins_aux1: "no_fail (λs. bus_valid busPtr s ∧ r' &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) ∧ r' ≥ 0)
       (condition (λs. sint (heap_w64 s
                     (PTR_COERCE(64 signed word → 64 word) (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub> r'))) =
                     actID)
       (resume' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r'))
       skip
       )"
  apply (rule non_fail_condition) 
  apply auto 
   defer 
  subgoal
    apply (unfold no_fail_def skip_def return_def) apply simp
    done
  apply (insert nofail_resume)
  apply (unfold bus_valid_def pluginList_valid_def)
  apply auto
  unfolding no_fail_def 
  by auto
  
lemma des_impl_startActorPlugins_aux2: " no_fail (λs. is_valid_GeneralBus_C s busPtr)
                     (do y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
                          return (r' + 1)
                     od)"
  by wpsimp

lemma des_impl_startActorPlugins : 
  " corres_underlying ({(t,s). busPtrEqual busPtr s (fst t)}) False False 
      (λretDes retImpl. retDes = True ∧ retImpl = 1) (λ_. True) (λs. bus_valid busPtr s) 
      (Des_startActorPlugins actID) (Impl_startActorPlugins busPtr actID)"
  unfolding Des_startActorPlugins_def Impl_startActorPlugins_def
  apply(rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s"])
     defer apply wpsimp+
  apply(rule corres_underlying_split[where r' = "(λdesr implr. int desr = implr)"
        and P = "(λ_ _. True)" and P' = "(λ_ _. True)"]) 
     defer apply wpsimp+
  apply (rule corres_whileLoop)
        apply auto          
  subgoal unfolding busPtrEqual_def int32Equal_def by auto
  subgoal unfolding busPtrEqual_def int32Equal_def by auto
      defer apply wpsimp
  subgoal for r' (*try to instead ?P*)
    apply wpsimp
    apply(rule des_impl_startActorPlugins_aux0)
    by wpsimp+
    defer 
  subgoal for r' s'
    apply (rule whileLoop_terminates_inv[
      where I = "λ_ _. True " 
        and R = "measure' (λ(r,t). nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C t busPtr)) - r))"])
      apply auto
    apply wpsimp 
    apply (unfold resume'_def setState'_def)
    by wpsimp+
  subgoal for r  (* prove between if and condition*)
    apply(rule corres_symb_exec_r[where Q' = "(λ_ _. True)"]) defer apply wpsimp+
    apply(rule corres_symb_exec_r[where Q' = "(λ_ _. True)"]) defer apply wpsimp+
    apply(rule corres_symb_exec_l[where Q = "(λowner σ. owner = pluginOwner (fst σ) ! r)"])
       defer apply wpsimp apply wpsimp apply wpsimp 
    apply(rule corres_underlying_split_r[where P = "λ_ _. True" and P' = "λ_ _. True" 
              and r' = "λrDes rImpl. rDes = r + 1" ])
    subgoal for owner
      apply(rule corres_if_condition)
      subgoal         
        unfolding busPtrEqual_def int64PtrListEqual_def
        by auto        
      subgoal 
        apply(rule corres_underlying_split_l[where P = "λ_ _. True" and P' = "λ_ _. True" 
              and r' = "λrDes rImpl. True" ]) defer
           apply wpsimp+
            (*need to prove call and resume*)
           apply (rule corres_callR_nr[where srel = "({(ds,is). pluginEqual (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r) is (fst ds)})" 
          and Gx = "λ_. True" ])
        subgoal 
          using des_imp_resume[where plu = "(PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r)"]
          unfolding corres_underlying_def 
          by auto
        subgoal unfolding busPtrEqual_def pluginPtrListEqual_def apply auto done
        subgoal unfolding busPtrEqual_def pluginPtrListEqual_def  apply auto done
        apply auto 
        done
      apply(unfold skip_def,corres,auto)
      done
       defer apply wpsimp+ 
    apply(rule corres_symb_exec_r[where Q' = "(λ_ s. True )"])
    by wpsimp+
  subgoal for r'
    apply wpsimp
    apply (rule des_impl_startActorPlugins_aux1)
    apply (rule des_impl_startActorPlugins_aux2)
    apply (rule condition_wp[where Q = "λs.  is_valid_GeneralBus_C s busPtr" and R = "λs.  is_valid_GeneralBus_C s busPtr"])
    apply (unfold resume'_def setState'_def)
         apply wpsimp+ apply (unfold bus_valid_def pluginOwner_valid_def pluginList_valid_def)
    by wpsimp
  done

subsection ‹pauseActorPlugins verify›

lemma nofail_pause :
  "no_fail (λs. is_valid_GeneralPlugin_C s pluPtr) (pause' pluPtr)"
  apply (unfold no_fail_def)
  apply (unfold pause'_def) apply auto
  apply (unfold pause'_def setState'_def) apply wpsimp
  apply (unfold modify_def get_def put_def valid_def skip_def guard_def condition_def return_def NonDetMonad.bind_def)
  by auto

lemma des_impl_pauseActorPlugins_aux0:
  "⦃λs. is_valid_GeneralBus_C s busPtr ⟶ bus_valid busPtr s⦄ 
    pause' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r') 
  ⦃λya s. is_valid_GeneralBus_C s busPtr ⟶ bus_valid busPtr s⦄"
  unfolding pause'_def setState'_def 
  apply wpsimp
  unfolding bus_valid_def pluginOwner_valid_def pluginList_valid_def pluginName_valid_def
  by auto 

lemma des_impl_pauseActorPlugins_aux1: "
  no_fail (λs. bus_valid busPtr s ∧ r' &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) ∧ r' ≥ 0)
       (condition (λs. sint (heap_w64 s
                            (PTR_COERCE(64 signed word → 64 word) (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub> r'))) =
                     actID)
       (pause' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r'))
       skip  )"
  apply (rule non_fail_condition) 
  apply auto 
   defer 
  subgoal
    apply (unfold no_fail_def skip_def return_def) apply simp
    done
  apply (insert nofail_pause)
  apply (unfold bus_valid_def pluginList_valid_def)
  apply auto
  unfolding no_fail_def 
  by auto

lemma des_impl_pauseActorPlugins : 
  " corres_underlying ({(t,s). busPtrEqual busPtr s (fst t)}) False False 
      (λretDes retImpl. retDes = True ∧ retImpl = 1) (λ_. True) (λs. bus_valid busPtr s) 
      (Des_pauseActorPlugins actID) (Impl_pauseActorPlugins busPtr actID)"
  unfolding Des_pauseActorPlugins_def Impl_pauseActorPlugins_def
  apply(rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s"])
     defer apply wpsimp+
  apply(rule corres_underlying_split[where r' = "(λdesr implr. int desr = implr)"
        and P = "(λ_ _. True)" and P' = "(λ_ _. True)"]) 
     defer apply wpsimp+          
  apply(rule corres_underlying_symb_exec_l[where Q = "(λ_ s.  True)"])
  subgoal unfolding modify_def return_def get_def put_def  NonDetMonad.bind_def corres_underlying_def by auto
   apply wpsimp+
  apply (rule corres_whileLoop)
        apply auto          
  subgoal unfolding busPtrEqual_def int32Equal_def by auto
  subgoal unfolding busPtrEqual_def int32Equal_def by auto
      defer apply wpsimp
  subgoal for r' (*try to instead ?P*)
    apply wpsimp
    apply(rule des_impl_pauseActorPlugins_aux0)
    by wpsimp+
    defer 
  subgoal for r' s'
    apply (rule whileLoop_terminates_inv[
      where I = "λ_ _. True " 
        and R = "measure' (λ(r,t). nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C t busPtr)) - r))"])
      apply auto
    apply wpsimp 
    apply (unfold pause'_def setState'_def)
    by wpsimp+
  subgoal for r  (* prove between if and condition*)
    apply(rule corres_symb_exec_r[where Q' = "(λ_ _. True)"]) defer apply wpsimp+
    apply(rule corres_symb_exec_r[where Q' = "(λ_ _. True)"]) defer apply wpsimp+
    apply(rule corres_symb_exec_l[where Q = "(λowner σ. owner = pluginOwner (fst σ) ! r)"])
       defer apply wpsimp apply wpsimp apply wpsimp 
    apply(rule corres_underlying_split_r[where P = "λ_ _. True" and P' = "λ_ _. True" 
              and r' = "λrDes rImpl. rDes = r + 1" ])
    subgoal for owner
      apply(rule corres_if_condition)
      subgoal         
        unfolding busPtrEqual_def int64PtrListEqual_def
        by auto        
      subgoal 
        apply(rule corres_underlying_symb_exec_l[where Q = "(λ_ σ. owner = pluginOwner (fst σ) ! r)"]) defer 
        apply(rule corres_underlying_symb_exec_l[where Q = "(λ_ σ. owner = pluginOwner (fst σ) ! r)"]) defer unfolding K_bind_def
        apply(rule corres_underlying_split_l[where P = "λ_ _. True" and P' = "λ_ _. True" 
              and r' = "λrDes rImpl. True" ]) defer
               apply wpsimp+
        subgoal unfolding gets_def modify_def return_def get_def put_def  NonDetMonad.bind_def corres_underlying_def by auto
            apply wpsimp+
        subgoal unfolding gets_def modify_def return_def get_def put_def  NonDetMonad.bind_def corres_underlying_def by auto
        subgoal unfolding  modify_def return_def get_def put_def  NonDetMonad.bind_def corres_underlying_def by auto
            (*need to prove call and pause*)
                   apply (rule corres_callR_nr[where srel = "({(ds,is). pluginEqual (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r) is (fst ds)})" 
          and Gx = "λ_. True" ])
        subgoal 
          using des_imp_pause[where plu = "(PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r)"]
          unfolding corres_underlying_def 
          by auto
        subgoal unfolding busPtrEqual_def pluginPtrListEqual_def apply auto done
        subgoal unfolding busPtrEqual_def pluginPtrListEqual_def  apply auto done
        apply auto 
        done
      apply(unfold skip_def,corres,auto)
      done
       defer apply wpsimp+ 
    apply(rule corres_symb_exec_r[where Q' = "(λ_ s. True )"])
    by wpsimp+
  subgoal for r'
    apply wpsimp
    apply (rule des_impl_pauseActorPlugins_aux1)
    apply (rule des_impl_startActorPlugins_aux2)
    apply (rule condition_wp[where Q = "λs.  is_valid_GeneralBus_C s busPtr" and R = "λs.  is_valid_GeneralBus_C s busPtr"])
    apply (unfold pause'_def setState'_def)
        apply wpsimp+ apply (unfold bus_valid_def pluginOwner_valid_def pluginList_valid_def) 
    by auto
  done


subsection ‹stopActorPlugins verify›
  
lemma nofail_stop :
  "no_fail (λs. is_valid_GeneralPlugin_C s pluPtr) (stop' pluPtr)"
  apply (unfold no_fail_def)
  apply (unfold stop'_def) apply auto
  apply (unfold stop'_def setState'_def) apply wpsimp
  apply (unfold modify_def get_def put_def valid_def skip_def guard_def condition_def return_def NonDetMonad.bind_def)
  by auto

lemma des_impl_stopActorPlugins_aux0:
  "⦃λs. is_valid_GeneralBus_C s busPtr ⟶ bus_valid busPtr s⦄ 
    stop' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r') 
  ⦃λya s. is_valid_GeneralBus_C s busPtr ⟶ bus_valid busPtr s⦄"
  unfolding stop'_def setState'_def 
  apply wpsimp
  unfolding bus_valid_def pluginOwner_valid_def pluginList_valid_def pluginName_valid_def
  by auto 

lemma des_impl_stopActorPlugins_aux1: "
  no_fail (λs. bus_valid busPtr s ∧ r' &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) ∧ r' ≥ 0)
       (condition (λs. sint (heap_w64 s
                            (PTR_COERCE(64 signed word → 64 word) (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub> r'))) =
                     actID)
       (stop' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r'))
       skip  )"
  apply (rule non_fail_condition) 
  apply auto 
   defer 
  subgoal
    apply (unfold no_fail_def skip_def return_def) apply simp
    done
  apply (insert nofail_stop)
  apply (unfold bus_valid_def pluginList_valid_def)
  apply auto
  unfolding no_fail_def 
  by auto

lemma des_impl_stopActorPlugins : 
  " corres_underlying ({(t,s). busPtrEqual busPtr s (fst t)}) False False 
      (λretDes retImpl. retDes = True ∧ retImpl = 1) (λ_. True) (λs. bus_valid busPtr s) 
      (Des_stopActorPlugins actID) (Impl_stopActorPlugins busPtr actID)"
  unfolding Des_stopActorPlugins_def Impl_stopActorPlugins_def
  apply(rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s"])
     defer apply wpsimp+
  apply(rule corres_underlying_split[where r' = "(λdesr implr. int desr = implr)"
        and P = "(λ_ _. True)" and P' = "(λ_ _. True)"]) 
     defer apply wpsimp+          
  apply (rule corres_whileLoop)
        apply auto          
  subgoal unfolding busPtrEqual_def int32Equal_def by auto
  subgoal unfolding busPtrEqual_def int32Equal_def by auto
      defer apply wpsimp
  subgoal for r' (*try to instead ?P*)
    apply wpsimp
    apply(rule des_impl_stopActorPlugins_aux0)
    by wpsimp+
    defer 
  subgoal for r' s'
    apply (rule whileLoop_terminates_inv[
      where I = "λ_ _. True " 
        and R = "measure' (λ(r,t). nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C t busPtr)) - r))"])
      apply auto
    apply wpsimp 
    apply (unfold stop'_def setState'_def)
    by wpsimp+
  subgoal for r  (* prove between if and condition*)
    apply(rule corres_symb_exec_r[where Q' = "(λ_ _. True)"]) defer apply wpsimp+
    apply(rule corres_symb_exec_r[where Q' = "(λ_ _. True)"]) defer apply wpsimp+
    apply(rule corres_symb_exec_l[where Q = "(λowner σ. owner = pluginOwner (fst σ) ! r)"])
       defer apply wpsimp apply wpsimp apply wpsimp 
    apply(rule corres_underlying_split_r[where P = "λ_ _. True" and P' = "λ_ _. True" 
              and r' = "λrDes rImpl. rDes = r + 1" ])
    subgoal for owner
      apply(rule corres_if_condition)
      subgoal         
        unfolding busPtrEqual_def int64PtrListEqual_def
        by auto        
      subgoal 
        apply(rule corres_underlying_split_l[where P = "λ_ _. True" and P' = "λ_ _. True" 
              and r' = "λrDes rImpl. True" ]) defer
               apply wpsimp+
            (*need to prove call and stop*)
                   apply (rule corres_callR_nr[where srel = "({(ds,is). pluginEqual (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r) is (fst ds)})" 
          and Gx = "λ_. True" ])
        subgoal 
          using des_imp_stop[where plu = "(PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> int r)"]
          unfolding corres_underlying_def 
          by auto
        subgoal unfolding busPtrEqual_def pluginPtrListEqual_def apply auto done
        subgoal unfolding busPtrEqual_def pluginPtrListEqual_def  apply auto done
        apply auto 
        done
      apply(unfold skip_def,corres,auto)
      done
       defer apply wpsimp+ 
    apply(rule corres_symb_exec_r[where Q' = "(λ_ s. True )"])
    by wpsimp+
  subgoal for r'
    apply wpsimp
    apply (rule des_impl_stopActorPlugins_aux1)
    apply (rule des_impl_startActorPlugins_aux2)
    apply (rule condition_wp[where Q = "λs.  is_valid_GeneralBus_C s busPtr" and R = "λs.  is_valid_GeneralBus_C s busPtr"])
    apply (unfold stop'_def setState'_def)
        apply wpsimp+ apply (unfold bus_valid_def pluginOwner_valid_def pluginList_valid_def) 
    by auto
  done


subsection ‹loadPluginInfoList verify›

lemma des_impl_loadPluginInfoList_aux1 : 
      "⦃λs. bus_valid busPtr s ∧
            is_valid_ActorPluginInfo_C s anActorPtr ∧
            actorPluginInfoEqual anActor anActorPtr s ∧
            pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
            ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧ 
            pluginName___ptr_to_char'param = PluginInfo_C.name_C (heap_PluginInfo_C s (PluginInfoVector_C.data_C
                     (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub> fst r')) ∧
            actorID___longlong'param = ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s anActorPtr)⦄
       Impl_loadPlugin busPtr pluginName___ptr_to_char'param actorID___longlong'param 
       ⦃λret'a a.
           (ret'a = 0 ⟶
            bus_valid busPtr a ∧
            is_valid_ActorPluginInfo_C a anActorPtr ∧
            actorPluginInfoEqual anActor anActorPtr a ∧
            pluginInfoPtr = plugins_C (heap_TaskInfo_C a (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
            ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C a pluginInfoPtr))) ∧
           (ret'a ≠ 0 ⟶
            0 ≤ 2147483649 + fst r' ⟶
            fst r' ≤ 2147483646 ⟶
            is_valid_TaskInfo_C a (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])) ⟶
            bus_valid busPtr a ∧
            is_valid_ActorPluginInfo_C a anActorPtr ∧
            actorPluginInfoEqual anActor anActorPtr a ∧
            pluginInfoPtr = plugins_C (heap_TaskInfo_C a (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
            ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C a pluginInfoPtr)))⦄"
  unfolding Impl_loadPlugin_def initializePlugin'_def Impl_createInstance_def
  apply(subst add_plugin_sem)
  apply wpsimp
  apply auto 
  unfolding bus_valid_def apply auto
  apply (simp add: sint_add_1)
  apply (simp add: sint_add_2)
  subgoal for s
    unfolding pluginOwner_valid_def
    by auto
   subgoal for s
    unfolding pluginList_valid_def
    by auto
 subgoal for s
    unfolding pluginName_valid_def
    by auto
  unfolding actorPluginInfoEqual_def taskInfoPtrEqual_def pluginInfoListEqual_def pluginInfoEqual_def
  by auto


lemma des_impl_loadPluginInfoList_aux211: "no_fail (λs. bus_valid busPtr s) (Impl_createInstance busPtr pluginName1)"
  apply (insert add_plugin_sem)
  apply (unfold Impl_createInstance_def bus_valid_def)
  apply (unfold no_fail_def gets_def return_def get_def put_def NonDetMonad.bind_def)
  apply auto
  apply (simp add: snd_state_assert)
  apply (simp add: skip_def return_def) 
  by (simp add: snd_state_assert)
lemma des_impl_loadPluginInfoList_aux213: "⦃λs. bus_valid busPtr s⦄ Impl_createInstance busPtr pluginName1 ⦃λrv. bus_valid busPtr⦄"
  apply (unfold Impl_createInstance_def)
  apply wpsimp
  apply (rule addPlugin_valid)
  by wpsimp+
lemma des_impl_loadPluginInfoList_aux212: "no_fail (bus_valid busPtr)
           (condition (λs. rv = 1)
             (do y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
                 y &lt;- guard (λs. sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) &lt; 128);
                 y &lt;- guard (λs. 0 ≤ sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)));
                 y &lt;- guard (λs. ∀a∈set (array_addrs (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C''])) 128). is_valid_w64 s (PTR_COERCE(64 signed word → 64 word) a));
                 y &lt;-
                 modify
                  (λs. heap_w64_update
                         (λa. a(PTR_COERCE(64 signed word → 64 word) (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub> sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr))) :=
                                   SCAST(64 signed → 64) actorID1))
                         s);
                 y &lt;- guard (λs. ∀x∈set (array_addrs (PTR(8 word ptr) &amp;(busPtr→[''pluginName_C''])) 128). is_valid_w8'ptr s x);
                 y &lt;- modify (λs. heap_w8'ptr_update (λa. a(PTR(8 word ptr) &amp;(busPtr→[''pluginName_C'']) +<span class="hidden">⇩</span><sub>p</sub> sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) := pluginName1)) s);
                 plugin_ptr &lt;- gets (λs. PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)));
                 y &lt;- guard (λs. is_valid_w8'ptr s (PTR(8 word ptr) &amp;(busPtr→[''pluginName_C'']) +<span class="hidden">⇩</span><sub>p</sub> sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr))));
                 aPluginName_ptr &lt;- gets (λs. heap_w8'ptr s (PTR(8 word ptr) &amp;(busPtr→[''pluginName_C'']) +<span class="hidden">⇩</span><sub>p</sub> sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr))));
                 ret' &lt;- initializePlugin' plugin_ptr actorID1 aPluginName_ptr;
                 y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
                 y &lt;- guard (λs. 0 ≤ 2147483649 + sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)));
                 y &lt;- guard (λs. sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) ≤ 2147483646);
                 y &lt;- modify (λs. heap_GeneralBus_C_update (λa. a(busPtr := nRegisteredPlugin_C_update (λa. nRegisteredPlugin_C (heap_GeneralBus_C s busPtr) + 1) (a busPtr))) s);
                 return 1
              od)
             (return 0) )"
  apply (rule non_fail_condition)
  apply (unfold initializePlugin'_def bus_valid_def)
  apply auto
   defer apply wp
  apply wpsimp
  apply (unfold pluginList_valid_def pluginOwner_valid_def pluginName_valid_def)
  apply simp
  done
  
lemma des_impl_loadPluginInfoList_aux21: " no_fail (λs. bus_valid busPtr s) (Impl_loadPlugin busPtr pluginName1 actorID1)" 
  apply (unfold Impl_loadPlugin_def)
  apply (rule non_fail_seq[where Q ="λs. bus_valid busPtr s"]) 
  apply auto
    apply wpsimp
  subgoal
    apply (unfold bus_valid_def bus_valid_def)
    by simp
   defer
  subgoal 
    apply (unfold bus_valid_def )
    apply wpsimp
    done
   apply (rule non_fail_condition)
   apply auto
   defer apply wp
  apply wp
  apply (rule des_impl_loadPluginInfoList_aux211)
  apply (rule des_impl_loadPluginInfoList_aux212)
  apply (rule des_impl_loadPluginInfoList_aux213)
  apply simp
  done
lemma des_impl_loadPluginInfoList_aux2: "no_fail 
      ((λs. bus_valid busPtr s ∧
            is_valid_ActorPluginInfo_C s anActorPtr ∧
            actorPluginInfoEqual anActor anActorPtr s ∧
            pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧ ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr))) and
      (λs. 0 ≤ fst r' ∧ fst r' &lt; ret'))
        (condition (λs. compare' s tBusName str2___ptr_to_char'param = 0)
          (do ret &lt;-
              condition (λs. snd (snd r') ≠ 0)
                (do y &lt;- guard (λs. is_valid_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])));
                    y &lt;- guard (λs. is_valid_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])))));
                    y &lt;-
                    guard
                     (λs. is_valid_PluginInfo_C s (PluginInfoVector_C.data_C (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub> fst r'));
                    pluginName___ptr_to_char'param &lt;-
                    gets
                     (λs. PluginInfo_C.name_C
                            (heap_PluginInfo_C s (PluginInfoVector_C.data_C (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub> fst r')));
                    y &lt;- guard (λs. is_valid_ActorPluginInfo_C s anActorPtr);
                    actorID___longlong'param &lt;- gets (λs. ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s anActorPtr));
                    ret' &lt;- Impl_loadPlugin busPtr pluginName___ptr_to_char'param actorID___longlong'param;
                    return (if ret' ≠ 0 then 1 else 0)
                 od)
                (return 0);
              return (ret, ret)
           od)
          (return (ret', snd (snd r'))) )"
  apply (insert des_impl_loadPluginInfoList_aux21)
  apply (unfold condition_def throwError_def returnOk_def no_fail_def gets_def return_def get_def put_def NonDetMonad.bind_def)
  apply auto
    unfolding actorPluginInfoEqual_def
    apply (metis snd_state_assert)
    apply (unfold bus_valid_def)
    apply (simp add: snd_state_assert)
    apply (simp add: snd_state_assert)
    by (simp add: snd_state_assert)


lemma des_impl_loadPluginInfoList_aux3: "⦃(λs. bus_valid busPtr s ∧
            is_valid_ActorPluginInfo_C s anActorPtr ∧
            actorPluginInfoEqual anActor anActorPtr s ∧
            pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧ ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr))) and
      (λs. 0 ≤ fst r' ∧ fst r' &lt; ret')⦄
       condition (λs. compare' s tBusName str2___ptr_to_char'param = 0)
         (do ret &lt;-
             condition (λs. snd (snd r') ≠ 0)
               (do y &lt;- guard (λs. is_valid_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])));
                   y &lt;- guard (λs. is_valid_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])))));
                   y &lt;-
                   guard
                    (λs. is_valid_PluginInfo_C s (PluginInfoVector_C.data_C (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub> fst r'));
                   pluginName___ptr_to_char'param &lt;-
                   gets
                    (λs. PluginInfo_C.name_C
                           (heap_PluginInfo_C s (PluginInfoVector_C.data_C (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub> fst r')));
                   y &lt;- guard (λs. is_valid_ActorPluginInfo_C s anActorPtr);
                   actorID___longlong'param &lt;- gets (λs. ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s anActorPtr));
                   ret' &lt;- Impl_loadPlugin busPtr pluginName___ptr_to_char'param actorID___longlong'param;
                   return (if ret' ≠ 0 then 1 else 0)
                od)
               (return 0);
             return (ret, ret)
          od)
         (return (ret', snd (snd r'))) 
       ⦃λp. if snd p = 0 then λ_. True
             else (λs. 0 ≤ 2147483649 + fst r') and
                  (λs. 0 ≤ 2147483649 + fst r' ⟶
                        ((λa. fst r' ≤ 2147483646) and
                         (λa. fst r' ≤ 2147483646 ⟶
                               ((λs. is_valid_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) and
                                (λs. is_valid_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])) ⟶ ((λ_. True) and ((λ_. True) and (λs. True))) s))
                                a))
                         s)⦄"
  apply (unfold actorPluginInfoEqual_def Impl_loadPlugin_def initializePlugin'_def Impl_createInstance_def)
  apply wpsimp using add_plugin_sem
  by wpsimp+


lemma des_impl_loadPluginInfoList_aux4:
    "¬ snd r ∧ snd (snd r') = 0 ∨ snd r ∧ snd (snd r') = 1 ⟹
       fst r' = int (fst r) ⟹
        ⦃λs. bus_valid busPtr s ∧
            is_valid_ActorPluginInfo_C s anActorPtr ∧
            actorPluginInfoEqual anActor anActorPtr s ∧
            pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
            pluginName___ptr_to_char'param = PluginInfo_C.name_C (heap_PluginInfo_C s (PluginInfoVector_C.data_C
                     (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub> fst r')) ∧
            actorID___longlong'param = ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s anActorPtr)⦄
          Impl_loadPlugin busPtr pluginName___ptr_to_char'param actorID___longlong'param 
        ⦃λret' a.
           bus_valid busPtr a ∧
           is_valid_ActorPluginInfo_C a anActorPtr ∧
           actorPluginInfoEqual anActor anActorPtr a ∧
           pluginInfoPtr = plugins_C (heap_TaskInfo_C a (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])))⦄"
  unfolding Impl_loadPlugin_def initializePlugin'_def Impl_createInstance_def
  apply(subst add_plugin_sem)
  apply wpsimp apply auto
  subgoal 
  unfolding bus_valid_def 
  apply auto
  apply (simp add: sint_add_1)
  apply (meson sint_add_2)
  unfolding pluginOwner_valid_def pluginList_valid_def pluginName_valid_def
  by auto  defer 
  subgoal 
  unfolding bus_valid_def 
  apply auto
  apply (simp add: sint_add_1)
  apply (meson sint_add_2)
  unfolding pluginOwner_valid_def pluginList_valid_def pluginName_valid_def
  by auto
  subgoal
  unfolding actorPluginInfoEqual_def apply auto
  unfolding taskInfoPtrEqual_def apply auto
  unfolding pluginInfoListEqual_def apply auto
  unfolding pluginInfoEqual_def
   by auto 
  subgoal
  unfolding actorPluginInfoEqual_def
    apply auto
    unfolding taskInfoPtrEqual_def
    apply auto
    unfolding pluginInfoListEqual_def
    apply auto
    unfolding pluginInfoEqual_def
    by auto 
  done

lemma des_impl_loadPluginInfoList_aux5:
  "¬ snd r ∧ snd (snd r') = 0 ∨ snd r ∧ snd (snd r') = 1 ⟹
   fst r' = int (fst r) ⟹
      ⦃λs. bus_valid busPtr s ∧
            is_valid_ActorPluginInfo_C s anActorPtr ∧
            actorPluginInfoEqual anActor anActorPtr s ∧
            pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
            ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧ int (fst r) &lt; ret' ∧
            pluginName___ptr_to_char'param = PluginInfo_C.name_C (heap_PluginInfo_C s (PluginInfoVector_C.data_C
                     (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub> fst r')) ∧
            actorID___longlong'param = ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s anActorPtr)⦄
        Impl_loadPlugin busPtr pluginName___ptr_to_char'param actorID___longlong'param 
      ⦃λret'a a.
           bus_valid busPtr a ∧
           is_valid_ActorPluginInfo_C a anActorPtr ∧
           ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C a pluginInfoPtr)) ∧
           int (fst r) &lt; ret' ∧
           actorPluginInfoEqual anActor anActorPtr a ∧
           pluginInfoPtr = plugins_C (heap_TaskInfo_C a (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])))⦄"
  unfolding Impl_loadPlugin_def initializePlugin'_def Impl_createInstance_def
  apply(subst add_plugin_sem)
  apply wpsimp
  apply auto
   subgoal 
    unfolding bus_valid_def 
    apply auto
    apply (simp add: sint_add_1)
    apply (meson sint_add_2)
    unfolding pluginOwner_valid_def pluginList_valid_def pluginName_valid_def
    by auto
    defer 
   subgoal 
    unfolding bus_valid_def 
    apply auto
    apply (simp add: sint_add_1)
    apply (meson sint_add_2)
    unfolding pluginOwner_valid_def pluginList_valid_def pluginName_valid_def
    by auto
    subgoal
      unfolding actorPluginInfoEqual_def  apply auto
      unfolding taskInfoPtrEqual_def  apply auto
      unfolding pluginInfoListEqual_def  apply auto
      unfolding pluginInfoEqual_def  by auto 
    subgoal
      unfolding actorPluginInfoEqual_def  apply auto
      unfolding taskInfoPtrEqual_def apply auto
      unfolding pluginInfoListEqual_def  apply auto
      unfolding pluginInfoEqual_def   by auto
    done

lemma sint_compare :
  "0≤a ⟹ a &lt; sint b ⟹ 0 &lt; sint b"
  by simp

lemma des_impl_loadPluginInfoList_aux6:
  "bus_valid busPtr s' ⟹
       is_valid_ActorPluginInfo_C s' anActorPtr ⟹
       actorPluginInfoEqual anActor anActorPtr s' ⟹
       ret' =
       sint
        (PluginInfoVector_C.length_C
          (heap_PluginInfoVector_C s'
            (plugins_C (heap_TaskInfo_C s' (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])))))) ⟹
       pluginInfoPtr = plugins_C (heap_TaskInfo_C s' (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ⟹
       ⦃λs1. bus_valid busPtr s1 ∧
            pluginInfoPtr = plugins_C (heap_TaskInfo_C s1 (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
            ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧  a &lt; ret' ∧ a ≥ 0 ∧
            actorPluginInfoEqual anActor anActorPtr s1 ∧
            pluginName___ptr_to_char'param = PluginInfo_C.name_C (heap_PluginInfo_C s (PluginInfoVector_C.data_C
                     (heap_PluginInfoVector_C s1 (plugins_C (heap_TaskInfo_C s1 (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>  a)) ∧
            actorID___longlong'param = ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s anActorPtr) ∧ s = s1 ∧  
            is_valid_ActorPluginInfo_C s1 anActorPtr  ⦄
            Impl_loadPlugin busPtr pluginName___ptr_to_char'param actorID___longlong'param 
       ⦃λret' b.
           (ret' = 0 ⟶
            bus_valid busPtr b ∧
            actorPluginInfoEqual anActor anActorPtr b ∧
            plugins_C (heap_TaskInfo_C s' (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) =
            plugins_C (heap_TaskInfo_C b (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
            PluginInfoVector_C.length_C
             (heap_PluginInfoVector_C s'
               (plugins_C (heap_TaskInfo_C s' (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) =
            PluginInfoVector_C.length_C
             (heap_PluginInfoVector_C b
               (plugins_C (heap_TaskInfo_C s' (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) ∧
            is_valid_ActorPluginInfo_C b anActorPtr ∧
            0 &lt; sint
                 (PluginInfoVector_C.length_C
                   (heap_PluginInfoVector_C s
                     (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])))))) ∧
            a &lt; sint
                 (PluginInfoVector_C.length_C
                   (heap_PluginInfoVector_C s
                     (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))))) ∧
           (ret' ≠ 0 ⟶
            0 ≤ 2147483649 + a ⟶
            a ≤ 2147483646 ⟶
            is_valid_TaskInfo_C b (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])) ⟶
            bus_valid busPtr b ∧
            actorPluginInfoEqual anActor anActorPtr b ∧
            plugins_C (heap_TaskInfo_C s' (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) =
            plugins_C (heap_TaskInfo_C b (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
            PluginInfoVector_C.length_C
             (heap_PluginInfoVector_C s'
               (plugins_C (heap_TaskInfo_C s' (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) =
            PluginInfoVector_C.length_C
             (heap_PluginInfoVector_C b
               (plugins_C (heap_TaskInfo_C s' (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) ∧
            is_valid_ActorPluginInfo_C b anActorPtr ∧
            nat (sint
                  (PluginInfoVector_C.length_C
                    (heap_PluginInfoVector_C b
                      (plugins_C (heap_TaskInfo_C b (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))))) -
            nat (a + 1)
            &lt; nat (sint
                    (PluginInfoVector_C.length_C
                      (heap_PluginInfoVector_C s
                        (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))))) -
              nat a)⦄"
  unfolding Impl_loadPlugin_def initializePlugin'_def Impl_createInstance_def
  apply(subst add_plugin_sem)
  apply wpsimp
  apply auto
  subgoal 
  unfolding bus_valid_def
  apply auto
  unfolding bus_valid_def
      defer
      apply (meson sint_add_2)
  subgoal  unfolding pluginOwner_valid_def   by auto
  subgoal  unfolding pluginList_valid_def  by auto
  subgoal  unfolding pluginName_valid_def    by auto
    proof -
      assume a1: "0 ≤ sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr))"
      assume "sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) &lt; 127"
      then have "¬ 127 ≤ sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr))"
        by linarith
      then show "0 ≤ sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr) + 1)"
        using a1 sint_add_1 by force
    qed
  subgoal 
    unfolding actorPluginInfoEqual_def apply rule
    subgoal by auto apply rule
    subgoal unfolding stringEqual_def by auto apply rule
    subgoal by auto apply rule
    subgoal unfolding taskInfoPtrEqual_def  pluginInfoListEqual_def  apply rule
      subgoal by auto unfolding pluginInfoEqual_def by auto 
    by auto
  done


lemma des_impl_loadPluginInfoList_aux71: "⦃λs.  Bus_invariant_1_2 (fst s) ∧ Bus_invariant_2_2 (fst s) ∧ Bus_invariant_3_2 (fst s)⦄
              Des_loadPlugin pName actID
              ⦃λsetResult s. Bus_invariant_1_2 (fst s) ∧ Bus_invariant_2_2 (fst s) ∧ Bus_invariant_3_2 (fst s)⦄"
  unfolding Des_loadPlugin_def Des_createInstance_def Let_def
  unfolding Bus_invariant_1_2_def Bus_invariant_2_2_def Bus_invariant_3_2_def catch_def throwError_def returnOk_def condition_def gets_def validE_def case_prod_unfold
  apply auto
  apply wpsimp 
  apply wpsimp
  done
lemma des_impl_loadPluginInfoList_aux72: "⦃λs. Bus_invariant_2_2 (fst s) ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)⦄
           λs. if bus.name (fst s) = busName (plugins (ActorPluginInfo.taskInfo anActor) ! a)
               then (do tmpRes &lt;-
                        Des_loadPlugin (PluginInfo.name (plugins (ActorPluginInfo.taskInfo anActor) ! a))
                         (ActorPluginInfo.actorID anActor);
                        return (b ∧ tmpRes)
                     od)
                     s
               else return b s 
           ⦃λsetResult s. Bus_invariant_2_2 (fst s) ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)⦄"
  apply (insert des_impl_loadPluginInfoList_aux71)
  apply (unfold return_def gets_def get_def put_def NonDetMonad.bind_def NonDetMonad.valid_def)
  apply simp
  using finish_puase_apiList
  by fast
lemma des_impl_loadPluginInfoList_aux7: " ⦃λs. Bus_invariant_2_2 (fst s) ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s) ∧ a &lt; length (plugins (ActorPluginInfo.taskInfo anActor))⦄
          do setResult &lt;-
              condition (λσ. bus.name (fst σ) = busName (plugins (ActorPluginInfo.taskInfo anActor) ! a))
                (do tmpRes &lt;-
                    Des_loadPlugin (PluginInfo.name (plugins (ActorPluginInfo.taskInfo anActor) ! a))
                     (ActorPluginInfo.actorID anActor);
                    return (b ∧ tmpRes)
                 od)
                (return b);
              if ¬ setResult then throwError a else returnOk (a + 1, setResult)
           od 
           ⦃λ_ s. Bus_invariant_2_2 (fst s) ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)⦄,
           ⦃λ_ s. Bus_invariant_2_2 (fst s) ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)⦄"
  apply (unfold validE_def condition_def)
  apply wpsimp
  apply (rule des_impl_loadPluginInfoList_aux72)
  by simp
lemma des_impl_loadPluginInfoList_aux8 :"
    ⦃λs. Bus_invariant_2_2 (fst s) ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)⦄
    whileLoopE (λr s. fst r &lt; length (plugins (ActorPluginInfo.taskInfo anActor)))
      (λr. do setResult &lt;-
              condition (λσ. bus.name (fst σ) = busName (plugins (ActorPluginInfo.taskInfo anActor) ! fst r))
                (do tmpRes &lt;-
                    Des_loadPlugin (PluginInfo.name (plugins (ActorPluginInfo.taskInfo anActor) ! fst r))
                     (ActorPluginInfo.actorID anActor);
                    return (snd r ∧ tmpRes)
                 od)
                (return (snd r));
              if ¬ setResult then throwError (fst r) else returnOk (fst r + 1, setResult)
           od)
     (0, True) &lt;catch&gt;
    (λe. return (e, False)) 
    ⦃λdr s. Bus_invariant_2_2 (fst s) ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)⦄"
    apply(subst whileLoopE_add_inv
            [where I="λr s. Bus_invariant_2_2 (fst s) 
                      ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)" 
              and M="λ((i,st),s). nat (length (plugins (ActorPluginInfo.taskInfo anActor))) - i"])
  apply wpsimp
  defer apply simp+
  apply (unfold validE_def condition_def)
  apply wpsimp
  apply (rule des_impl_loadPluginInfoList_aux72)
  by simp


lemma des_impl_loadPluginInfoList : 
  "corres_underlying {(t, s). busPtrEqual busPtr s (fst t)} False False (λdr ir. dr ∧ ir = 1 ∨ ¬ dr ∧ ir = 0)
     (λs. Bus_invariant_2_2 (fst s) ∧  Bus_invariant_3_2 (fst s)  ∧ Bus_invariant_1_2 (fst s))
     (λs. bus_valid busPtr s ∧
           is_valid_ActorPluginInfo_C s anActorPtr ∧
           actorPluginInfoEqual anActor anActorPtr s ∧
           pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))
     (Des_loadPluginInfoList (plugins (ActorPluginInfo.taskInfo anActor)) (ActorPluginInfo.actorID anActor))
     (Impl_loadPluginInfoList 1 busPtr pluginInfoPtr anActorPtr)"
  unfolding Des_loadPluginInfoList_def Impl_loadPluginInfoList_def
  apply (rule corres_underlying_symb_exec_l[where Q = "λdr s. Bus_invariant_2_2 (fst s) ∧  Bus_invariant_3_2 (fst s)  ∧ Bus_invariant_1_2 (fst s)"])
    apply auto
  unfolding case_prod_unfold
  apply (rule corres_symb_exec_r[where Q' = "λret s. bus_valid busPtr s ∧
          is_valid_ActorPluginInfo_C s anActorPtr ∧
          actorPluginInfoEqual anActor anActorPtr s ∧
          pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
          ret = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) "])
     defer  unfolding pluginInfoVectorSize'_def 
     apply wpsimp+ 
  subgoal for ret'
  apply (rule corres_underlying_split[where P = "λdr s. Bus_invariant_2_2 (fst s) ∧  Bus_invariant_3_2 (fst s)  ∧ Bus_invariant_1_2 (fst s)" and P' = "λir s. True" 
              and r' = "λdes impl. ((snd des = False ∧ snd (snd impl) = 0)∨(snd des = True ∧ snd (snd impl) = 1)) "])
       defer  apply (rule des_impl_loadPluginInfoList_aux8) apply wpsimp+
    unfolding catch_def
    apply(rule corres_underlying_split[where r' = "(λe e'. int e = (fst (snd e')) ∧ (snd (snd e')) = 0 ) ⊕ 
             (λdes impl. ((snd des = False ∧ snd (snd impl) = 0)∨(snd des = True ∧ snd (snd impl) = 1)) ∧ 
                          fst impl = int (fst des ))" 
                       and P = "(λ_ _. True)" and P' = "(λ_ s.  True) "])
       defer apply wpsimp+
    subgoal for x xa
      apply (case_tac "x") 
      by auto            
    apply(rule corres_whileLoopE)
       subgoal for r r' s s'
         apply(case_tac r)  apply auto
         unfolding actorPluginInfoEqual_def taskInfoPtrEqual_def pluginInfoListEqual_def  
         by auto
            defer apply wpsimp
         apply (rule des_impl_loadPluginInfoList_aux7)
       subgoal 
         by simp
       subgoal for r'
         apply wpsimp+
         unfolding validE_def
          apply wpsimp+
          apply (wpsimp wp:des_impl_loadPluginInfoList_aux1)
         by wpsimp+
          apply auto[1]
        subgoal for r'(*fail*)
          apply wpsimp
          apply (rule des_impl_loadPluginInfoList_aux2[where anActor = "anActor" and anActorPtr = "anActorPtr" and pluginInfoPtr = "pluginInfoPtr"])
          apply wpsimp
          apply (rule des_impl_loadPluginInfoList_aux3[where anActor = "anActor" and anActorPtr = "anActorPtr" and pluginInfoPtr = "pluginInfoPtr"])
          apply wpsimp+ 
          apply (unfold bus_valid_def actorPluginInfoEqual_def)
         by auto
       subgoal for r' s' (*terminates*)
         unfolding whileLoop_terminatesE_def throwError_def returnOk_def
         apply (rule whileLoop_terminates_inv[
               where I = "λr s.  bus_valid busPtr s ∧ actorPluginInfoEqual anActor anActorPtr s ∧ 
                                 pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
                                 ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧
                                 is_valid_ActorPluginInfo_C s anActorPtr " 
                  and R = "measure' (λ(r,s). case r of Inl a ⇒ 0 |
                             Inr v ⇒ nat (sint (PluginInfoVector_C.length_C
                      (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))))) - nat (fst v))"])
           apply auto unfolding NonDetMonad.lift_def throwError_def returnOk_def
         apply wpsimp                                     
            apply (wpsimp wp:des_impl_loadPluginInfoList_aux6)
            apply wpsimp+ by auto
     subgoal for r r'
     apply (rule corres_symb_exec_r[where Q' = "(λret s. bus_valid busPtr s ∧
               is_valid_ActorPluginInfo_C s anActorPtr ∧
               actorPluginInfoEqual anActor anActorPtr s ∧
               pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
               ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧ fst r' &lt; ret' ∧ ret = ())"])+
              defer apply wpsimp+
     apply (rule corres_symb_exec_r[where Q' = "(λret s. bus_valid busPtr s ∧
               is_valid_ActorPluginInfo_C s anActorPtr ∧
               actorPluginInfoEqual anActor anActorPtr s ∧
               pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
               ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧ fst r' &lt; ret' ∧
               ret = busName_C (heap_PluginInfo_C s (PluginInfoVector_C.data_C
                     (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>
                     int (fst r))))"])
     subgoal for tBusName
       apply (rule corres_symb_exec_r[where Q' = "(λret s. bus_valid busPtr s ∧
               is_valid_ActorPluginInfo_C s anActorPtr ∧
               actorPluginInfoEqual anActor anActorPtr s ∧
               pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
               ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧ fst r' &lt; ret' ∧
               tBusName = busName_C (heap_PluginInfo_C s (PluginInfoVector_C.data_C
                     (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>
                     int (fst r))))"])   
       apply (rule corres_symb_exec_r[where Q' = "(λret s. bus_valid busPtr s ∧
               is_valid_ActorPluginInfo_C s anActorPtr ∧
               actorPluginInfoEqual anActor anActorPtr s ∧
               pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
               ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧ fst r' &lt; ret' ∧
               tBusName = busName_C (heap_PluginInfo_C s (PluginInfoVector_C.data_C
                     (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>
                     int (fst r))) ∧ ret = GeneralBus_C.name_C (heap_GeneralBus_C s busPtr))"])   
             defer apply wpsimp+
       subgoal for busName
        apply(rule corres_underlying_split[where r' = " (λdes impl. ((des = False ∧  snd impl = 0)∨(des = True ∧ snd impl = 1)))" 
                       and P = "(λ_ s. fst r &lt; length (plugins (ActorPluginInfo.taskInfo anActor)))" 
                       and P' = "(λ_ s.  bus_valid busPtr s ∧is_valid_ActorPluginInfo_C s anActorPtr ∧
               ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧ fst r' &lt; ret' ∧
                                        actorPluginInfoEqual anActor anActorPtr s ∧
                            pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])))) "])
         subgoal
           apply(rule corres_condition_P)
             defer 
           subgoal 
             apply (rule corres_underlying_split_r[where r' = " (λdes impl. ((des = False ∧  impl = 0)∨(des = True ∧ impl = 1)))" 
                       and P = "(λ_ s. fst r &lt; length (plugins (ActorPluginInfo.taskInfo anActor)))" 
                       and P' = "(λ_ s.  bus_valid busPtr s ∧is_valid_ActorPluginInfo_C s anActorPtr ∧
                                        actorPluginInfoEqual anActor anActorPtr s ∧
                            pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])))) "])
                defer apply wpsimp
             subgoal 
               apply wpsimp                         
               apply (wpsimp wp:des_impl_loadPluginInfoList_aux4)
               by wpsimp+
              apply auto
             using finish_puase_apiList apply auto[1]
             apply (rule corres_symb_exec_r[where Q' = "(λret s. bus_valid busPtr s ∧
               is_valid_ActorPluginInfo_C s anActorPtr ∧
               actorPluginInfoEqual anActor anActorPtr s ∧
               ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧ fst r' &lt; ret' ∧
               pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧ ret = ())"])+ 
                      defer apply wpsimp+
             apply (rule corres_symb_exec_r[where Q' = "(λret s. bus_valid busPtr s ∧
               is_valid_ActorPluginInfo_C s anActorPtr ∧
               actorPluginInfoEqual anActor anActorPtr s ∧
               pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
               ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧ fst r' &lt; ret' ∧
               ret = PluginInfo_C.name_C (heap_PluginInfo_C s(PluginInfoVector_C.data_C
                     (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>
                     int (fst r))))"])
             subgoal for pluginNamePtr
             apply (rule corres_symb_exec_r[where Q' = "(λret s. bus_valid busPtr s ∧
               is_valid_ActorPluginInfo_C s anActorPtr ∧
               actorPluginInfoEqual anActor anActorPtr s ∧
               pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
               ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧ fst r' &lt; ret' ∧
               pluginNamePtr = PluginInfo_C.name_C (heap_PluginInfo_C s(PluginInfoVector_C.data_C
                     (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>
                     int (fst r))))"])
             apply (rule corres_symb_exec_r[where Q' = "(λret s. bus_valid busPtr s ∧
               is_valid_ActorPluginInfo_C s anActorPtr ∧
               actorPluginInfoEqual anActor anActorPtr s ∧
               pluginInfoPtr = plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧
               ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧ fst r' &lt; ret' ∧
               pluginNamePtr = PluginInfo_C.name_C (heap_PluginInfo_C s(PluginInfoVector_C.data_C
                     (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>
                     int (fst r))) ∧
               ret = ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s anActorPtr))"])
             apply (rule corres_underlying_split_r[where r' = " (λdes impl. ((des = False ∧  impl = 0)∨(des = True ∧ impl = 1)))" 
                       and P = "(λ_ s. True)" and P' = "(λ_ s.  True) "])
                        defer apply wpsimp+
               subgoal for actorID
                apply (insert des_impl_loadPlugin)
                 apply (unfold int64Equal_def actorPluginInfoEqual_def corres_underlying_def)
                 apply (simp add: case_prod_unfold)
                apply auto
                  proof -
                  fix a :: bus and b :: "char list list" and ba :: lifted_globals and aa :: int and bb :: lifted_globals
                  assume a1: "Bus_invariant_2_2 a"
                  assume a2: "Bus_invariant_3_2 a"
                    assume a3: "Bus_invariant_1_2 a"
                    assume a4: "bus_valid busPtr ba"
                    assume a5: "busPtrEqual busPtr ba a"
                    assume a6: "actorID = ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C ba anActorPtr)"
                    assume a7: "⋀pName pluginName1 actID actorID1 busPtr. ⟦stringEqual pName pluginName1; actID = sint actorID1⟧ ⟹ ∀a b ba. busPtrEqual busPtr ba a ⟶ Bus_invariant_2_2 a ∧ Bus_invariant_3_2 a ∧ Bus_invariant_1_2 a ∧ bus_valid busPtr ba ⟶ (∀x∈fst (Impl_loadPlugin busPtr pluginName1 actorID1 ba). ∃xa∈fst (Des_loadPlugin pName (sint actorID1) (a, b)). busPtrEqual busPtr (snd x) (fst (snd xa)) ∧ (¬ fst xa ∧ fst x = 0 ∨ fst xa ∧ fst x = 1))"
                    assume a8: "pluginInfoPtr = plugins_C (heap_TaskInfo_C ba (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])))"
                    assume a9: "ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C ba (plugins_C (heap_TaskInfo_C ba (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))))"
                    assume a10: "int (fst r) &lt; sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C ba (plugins_C (heap_TaskInfo_C ba (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))))"
                    assume a11: "pluginNamePtr = PluginInfo_C.name_C (heap_PluginInfo_C ba (PluginInfoVector_C.data_C (heap_PluginInfoVector_C ba (plugins_C (heap_TaskInfo_C ba (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub> int (fst r)))"
                    assume a12: "(aa, bb) ∈ fst (Impl_loadPlugin busPtr (PluginInfo_C.name_C (heap_PluginInfo_C ba (PluginInfoVector_C.data_C (heap_PluginInfoVector_C ba (plugins_C (heap_TaskInfo_C ba (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub> int (fst r)))) (ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C ba anActorPtr)) ba)"
                    assume a13: "∀r. int r &lt; sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C ba (plugins_C (heap_TaskInfo_C ba (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])))))) ⟶ stringEqual (PluginInfo.name (plugins (ActorPluginInfo.taskInfo anActor) ! r)) (PluginInfo_C.name_C (heap_PluginInfo_C ba (PluginInfoVector_C.data_C (heap_PluginInfoVector_C ba (plugins_C (heap_TaskInfo_C ba (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub> int r)))"
                    have f14: "sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C ba pluginInfoPtr)) = ret'"
                      using a9 a8 by meson
                    then have f15: "int (fst r) &lt; ret'"
                      using a10 a8 by meson
                    have f16: "PluginInfo_C.name_C (heap_PluginInfo_C ba (PluginInfoVector_C.data_C (heap_PluginInfoVector_C ba pluginInfoPtr) +<span class="hidden">⇩</span><sub>p</sub> int (fst r))) = pluginNamePtr"
                      using a11 a8 by meson
                    then have f17: "stringEqual (PluginInfo.name (plugins (ActorPluginInfo.taskInfo anActor) ! fst r)) pluginNamePtr"
                      using f15 f14 a13 a8 by blast
                    have "∀cs w b css p pa. ∃pb. ∀ba csa pc pd l pe wa pf la pg lb ph lc pi ld. (¬ Bus_invariant_1_2 ba ∨ ¬ Bus_invariant_3_2 ba ∨ ¬ Bus_invariant_2_2 ba ∨ ¬ stringEqual csa pc ∨ ¬ bus_valid pd l ∨ pe ∉ fst (Impl_loadPlugin pd pc wa l) ∨ ¬ busPtrEqual pd l ba ∨ fst pe = 0 ∨ fst pe = 1) ∧ (¬ Bus_invariant_1_2 b ∨ ¬ Bus_invariant_3_2 b ∨ ¬ Bus_invariant_2_2 b ∨ ¬ stringEqual cs pf ∨ ¬ bus_valid p la ∨ pa ∉ fst (Impl_loadPlugin p pf w la) ∨ ¬ busPtrEqual p la b ∨ fst pb ∨ fst pa = 0) ∧ (¬ Bus_invariant_1_2 b ∨ ¬ Bus_invariant_3_2 b ∨ ¬ Bus_invariant_2_2 b ∨ ¬ fst pb ∨ ¬ stringEqual cs pg ∨ ¬ bus_valid p lb ∨ pa ∉ fst (Impl_loadPlugin p pg w lb) ∨ ¬ busPtrEqual p lb b ∨ fst pa = 1) ∧ (¬ Bus_invariant_1_2 b ∨ ¬ Bus_invariant_3_2 b ∨ ¬ Bus_invariant_2_2 b ∨ ¬ stringEqual cs ph ∨ ¬ bus_valid p lc ∨ pa ∉ fst (Impl_loadPlugin p ph w lc) ∨ ¬ busPtrEqual p lc b ∨ busPtrEqual p (snd pa) (fst (snd pb))) ∧ (¬ Bus_invariant_1_2 b ∨ ¬ Bus_invariant_3_2 b ∨ ¬ Bus_invariant_2_2 b ∨ ¬ stringEqual cs pi ∨ ¬ bus_valid p ld ∨ pa ∉ fst (Impl_loadPlugin p pi w ld) ∨ ¬ busPtrEqual p ld b ∨ pb ∈ fst (Des_loadPlugin cs (sint w) (b, css)))"
                      using a7 by (metis (no_types))
                    then show "∃p∈fst (Des_loadPlugin (PluginInfo.name (plugins (ActorPluginInfo.taskInfo anActor) ! fst r)) (sint (ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C ba anActorPtr))) (a, b)). busPtrEqual busPtr bb (fst (snd p)) ∧ (¬ fst p ∧ aa = 0 ∨ fst p ∧ aa = 1)"
                      using f17 f16 a12 a8 a6 a5 a4 a3 a2 a1 by (metis fst_conv snd_conv)
                  qed 
               done  
             by wpsimp+
            apply corres apply auto[1]
            subgoal
             apply auto
             apply (unfold busPtrEqual_def actorPluginInfoEqual_def)
             using compare_str2  
                apply simp
             using compare_str3
               apply fast
             using compare_str2  
              apply simp
             using compare_str3
               apply fast 
             done
           done
         subgoal by wpsimp
         subgoal 
           apply wpsimp
                    apply(wpsimp wp:des_impl_loadPluginInfoList_aux5)
           by wpsimp+
         apply rule+
         apply (rule corres_if_simple_pre)
           apply auto[1]
          apply auto[1]
         apply rule
          apply (rule corres_symb_exec_r[where Q' = "(λret s.  bus_valid busPtr s ∧
              is_valid_ActorPluginInfo_C s anActorPtr ∧
              ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧
              fst r' &lt; ret' ∧
              actorPluginInfoEqual anActor anActorPtr s ∧
              pluginInfoPtr =
              plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) ∧ ret = ())"])+
            defer apply wpsimp+
         apply (rule corres_symb_exec_r[where Q' = "(λret s.  bus_valid busPtr s ∧
              is_valid_ActorPluginInfo_C s anActorPtr ∧
              ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pluginInfoPtr)) ∧
              fst r' &lt; ret' ∧
              actorPluginInfoEqual anActor anActorPtr s ∧
              pluginInfoPtr =
              plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) )"])+
             defer apply wpsimp+
         apply corres 
         by auto
       done
     by wpsimp+
   done
  done 



  

subsection ‹updateActorPluginState verify›


lemma des_impl_updateActorPluginState_aux0:
  "⦃λs.  x &lt; length (plugins (ActorPluginInfo.taskInfo anActor))  ∧
         Bus_invariant_2_2 (fst s) ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)⦄
       Des_loadPlugin (PluginInfo.name (plugins (ActorPluginInfo.taskInfo anActor) ! x)) (ActorPluginInfo.actorID anActor) 
       ⦃λxa a.
           ((y ⟶ ¬ xa) ⟶ Bus_invariant_2_2 (fst a) ∧ Bus_invariant_3_2 (fst a) ∧ Bus_invariant_1_2 (fst a)) ∧
           (y ∧ xa ⟶
            Suc x ≤ length (plugins (ActorPluginInfo.taskInfo anActor)) ∧
            Bus_invariant_2_2 (fst a) ∧ Bus_invariant_3_2 (fst a) ∧ Bus_invariant_1_2 (fst a))⦄"
  unfolding Des_loadPlugin_def 
  apply wp
    unfolding Des_createInstance_def  throwError_def returnOk_def Let_def
    apply wpsimp
    apply rule+ 
    unfolding validE_R_def validE_def
        apply wpsimp 
       apply rule
       apply wpsimp+
    unfolding Bus_invariant_2_2_def Bus_invariant_3_2_def Bus_invariant_1_2_def
    by auto


lemma des_impl_updateActorPluginState_aux1: "
    ⦃λs. Bus_invariant_2_2 (fst s) ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)⦄
      Des_loadPluginInfoList (plugins (ActorPluginInfo.taskInfo anActor)) (ActorPluginInfo.actorID anActor) 
    ⦃λdr s. Bus_invariant_2_2 (fst s) ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)⦄"
  unfolding Des_loadPluginInfoList_def
  apply(subst whileLoopE_add_inv
            [where I= "λ(i,setResult) s. i ≤ length (plugins (ActorPluginInfo.taskInfo anActor)) 
                          ∧ Bus_invariant_2_2 (fst s) 
                         ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)" 
              and M= "λ((i,setResult), s). length (plugins (ActorPluginInfo.taskInfo anActor)) - i"])
  apply wpsimp
  unfolding validE_def throwError_def returnOk_def 
  apply wpsimp
  apply (wpsimp wp:des_impl_updateActorPluginState_aux0)
  by wpsimp+

lemma des_impl_updateActorPluginState_aux2: 
  "   ⦃λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s⦄ 
          Impl_loadPlugin busPtr pluginName___ptr_to_char'param actorID___longlong'param 
       ⦃λret'a a.
           (ret'a = 0 ⟶ bus_valid busPtr a ∧ is_valid_ActorPluginInfo_C a anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr a) ∧
           (ret'a ≠ 0 ⟶
            0 ≤ 2147483649 + x ⟶
            x ≤ 2147483646 ⟶
            is_valid_TaskInfo_C a (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])) ⟶
            bus_valid busPtr a ∧ is_valid_ActorPluginInfo_C a anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr a)⦄"
  unfolding Impl_loadPlugin_def Impl_createInstance_def initializePlugin'_def
  apply (subst add_plugin_sem)
  apply wpsimp
  apply auto
  subgoal for s
    unfolding bus_valid_def apply auto
        apply(simp add:sint_add_1)
    subgoal unfolding  pluginName_valid_def apply auto
      using sint_add_2 by blast 
    subgoal  unfolding   pluginOwner_valid_def by auto
    subgoal unfolding pluginList_valid_def by auto
    unfolding  pluginName_valid_def
    by auto
  unfolding  actorPluginInfoEqual_def
  apply rule
  subgoal for s by auto
  apply rule
  subgoal for s by auto 
  apply rule
  subgoal for s by auto
  apply rule
  subgoal for s unfolding taskInfoPtrEqual_def pluginInfoListEqual_def  pluginInfoEqual_def
    by auto
  by (rule,auto)


lemma des_impl_updateActorPluginState_aux3: "
       ⦃λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s⦄ 
       Impl_loadPluginInfoList 1 busPtr v___ptr_to_struct_PluginInfoVector_C'param anActorPtr 
       ⦃λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s⦄"
  unfolding Impl_loadPluginInfoList_def
  apply(subst whileLoopE_add_inv
            [where I= "λ(i, ret, setResult) s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s" 
              and M= "λ((i, ret, setResult), s).  nat (sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s v___ptr_to_struct_PluginInfoVector_C'param)) - i)"])
  unfolding  pluginInfoVectorSize'_def   
  apply wp 
  unfolding validE_def throwError_def returnOk_def 
      apply wpsimp
                    apply (wpsimp wp:des_impl_updateActorPluginState_aux2)
  unfolding case_prod_unfold
  by wpsimp+ 


lemma des_impl_updateActorPluginState_aux4: "
       ⦃λs. False⦄ 
       Impl_loadPluginInfoList 1 busPtr v___ptr_to_struct_PluginInfoVector_C'param anActorPtr 
       ⦃λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s ∧ r = 1⦄"
  unfolding NonDetMonad.valid_def by auto


lemma des_impl_updateActorPluginState_aux5: "
    ⦃λs. bus_valid busPtr s ∧  is_valid_ActorPluginInfo_C s anActorPtr ∧
         actorPluginInfoEqual anActor anActorPtr s ∧ anActorIDa = sint (ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s anActorPtr))⦄
        Impl_startActorPlugins busPtr anActorIDa 
   ⦃λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s⦄"
  unfolding Impl_startActorPlugins_def
  apply(subst whileLoop_add_inv
          [where I= "λi s.  bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s" 
            and M= "λ(i,s). nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) - i)"])
  unfolding resume'_def setState'_def
  apply wpsimp
     defer defer apply wpsimp+
  apply auto
 subgoal for s
    unfolding bus_valid_def apply auto
    subgoal  unfolding   pluginOwner_valid_def by auto
    subgoal unfolding pluginList_valid_def by auto
    unfolding  pluginName_valid_def
    by auto
  unfolding  actorPluginInfoEqual_def
  apply rule
  subgoal for s by auto
  apply rule
  subgoal for s by auto 
  apply rule
  subgoal for s by auto
  apply rule
  subgoal for s unfolding taskInfoPtrEqual_def pluginInfoListEqual_def  pluginInfoEqual_def
    by auto
  by (rule,auto)

lemma des_impl_updateActorPluginState: "
    stateActorPluginInfoEqual anState anImplState ⟹
    corres_underlying ({(t,s). busPtrEqual busPtr s (fst t)}) False False
      (λdr ir. (dr ∧ ir = 1) ∨ (¬dr ∧ ir = 0))
      (λs. Bus_invariant_2_2 (fst s) ∧  Bus_invariant_3_2 (fst s)  ∧ Bus_invariant_1_2 (fst s)) 
      (λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s)
      (Des_updateActorPluginState anActor anState) (Impl_updateActorPluginState busPtr anActorPtr anImplState)"
  apply (unfold Impl_updateActorPluginState_def Des_updateActorPluginState_def)
  apply (rule corres_underlying_split[where P = "λdr s. Bus_invariant_2_2 (fst s) ∧  Bus_invariant_3_2 (fst s)  ∧ Bus_invariant_1_2 (fst s)" and P' = "λir s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s ∧ ir = 1" 
              and r' = "λdes impl. des = True ∧ impl = 1"])
     apply wpsimp+
  apply rule
  subgoal for setResult
    apply rule+
    apply (rule corres_condition_case)
    subgoal
      apply (case_tac "anState")
      apply simp
          apply (unfold stateActorPluginInfoEqual_def impl_ACTOR_STATE_INIT_def) 
          apply simp
      apply simp
         apply (unfold stateActorPluginInfoEqual_def impl_ACTOR_STATE_RUNNING_def) 
         apply simp
      apply simp
         apply (unfold stateActorPluginInfoEqual_def impl_ACTOR_STATE_PAUSE_def) 
        apply simp
      apply simp
         apply (unfold stateActorPluginInfoEqual_def impl_ACTOR_STATE_FINISH_def) 
         apply simp
      by simp
    subgoal
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s "])
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s "])
           defer apply wpsimp+
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ 
                                actorPluginInfoEqual anActor anActorPtr s ∧ 
                      r =  plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) "])
        defer apply wpsimp+
     subgoal for pluginInfoPtr
       apply (wpsimp wp: des_impl_loadPluginInfoList)
       done
     done
   subgoal  
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s "])
        defer apply wpsimp+
     apply (rule corres_underlying_split[where P = "λdr s. Bus_invariant_2_2 (fst s) ∧  Bus_invariant_3_2 (fst s)  ∧ Bus_invariant_1_2 (fst s)"
              and P' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s" 
              and r' = "λretDes retImpl. (retDes = True ∧ retImpl = 1) ∨ (retDes = False ∧ retImpl = 0) "])
     subgoal 
       apply(rule corres_condition_G)
       subgoal
         unfolding actorPluginInfoEqual_def stateACBEqual_def
         apply auto
         apply (simp add: impl_ACTOR_STATE_INIT_def)
       done 
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s "])
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s  ∧ 
                       r =  plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C''])))"])
      subgoal for _ pluginInfoPtr
        apply (wpsimp wp: des_impl_loadPluginInfoList)
        done
      by wpsimp+
    subgoal
      apply (rule des_impl_updateActorPluginState_aux1)
      done
    subgoal
      apply wpsimp
      apply (wpsimp wp: des_impl_updateActorPluginState_aux3)
      apply wpsimp+
      done
     apply auto
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s "])
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s
                                                      ∧ r = sint (ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s anActorPtr))"])
     apply (rule corres_underlying_split_r[where P = "λdr _. True"
              and P' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s" 
              and r' = "λretDes retImpl. (retDes = True ∧ retImpl = 1) ∨ (retDes = False ∧ retImpl = 0) "])
               defer apply wpsimp+
     subgoal for anActorIDa
       apply (rule des_impl_updateActorPluginState_aux5)
       done
     apply wpsimp+
      apply (insert des_impl_startActorPlugins)
      apply (unfold actorPluginInfoEqual_def)
      apply (rule corres_rel_imp[where r' = "(λdr ir. dr ∧ ir = 1)"])
      subgoal for rv
        apply (unfold corres_underlying_def)
        apply auto
        done
      apply auto
      done
    subgoal
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s"])
      defer
      apply wpsimp+
      apply (unfold actorPluginInfoEqual_def)
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s
                                                      ∧ r = sint (ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s anActorPtr))"])
      defer
      subgoal
        apply(unfold bus_valid_def actorPluginInfoEqual_def) by wpsimp+
      apply wpsimp+
      apply (insert des_impl_pauseActorPlugins)
      apply (unfold actorPluginInfoEqual_def)
      apply (rule corres_rel_imp[where r' = "(λdr ir. dr ∧ ir = 1)"])
      subgoal for rv
        apply (unfold corres_underlying_def)
        apply auto
        done
      apply auto
      done
    subgoal 
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s"])
      defer
      apply wpsimp+
      apply (unfold actorPluginInfoEqual_def)
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s
                                                      ∧ r = sint (ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s anActorPtr))"])
      defer
   subgoal
        apply(unfold bus_valid_def actorPluginInfoEqual_def) by wpsimp+
      apply wpsimp+
      apply (insert des_impl_stopActorPlugins)
      apply (unfold actorPluginInfoEqual_def)
      apply (rule corres_rel_imp[where r' = "(λdr ir. dr ∧ ir = 1)"])
      subgoal for rv
        apply (unfold corres_underlying_def)
        apply auto
        done
      apply auto
      done
    by wpsimp
  apply rule+
  apply (rule corres_condition_case)
  subgoal
     apply (case_tac "anState")
     apply simp
         apply (unfold stateActorPluginInfoEqual_def impl_ACTOR_STATE_INIT_def) 
         apply simp
     apply simp
         apply (unfold stateActorPluginInfoEqual_def impl_ACTOR_STATE_RUNNING_def) 
         apply simp
     apply simp
         apply (unfold stateActorPluginInfoEqual_def impl_ACTOR_STATE_PAUSE_def) 
         apply simp
     apply simp
         apply (unfold stateActorPluginInfoEqual_def impl_ACTOR_STATE_FINISH_def) 
         apply simp
     by simp
   subgoal for setResult 
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s "])
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s "])
           defer apply wpsimp+
     apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ 
                                actorPluginInfoEqual anActor anActorPtr s ∧ 
                      r =  plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(anActorPtr→[''taskInfo_C'']))) "])
        defer apply wpsimp+
     subgoal for pluginInfoPtr
       by(rule des_impl_loadPluginInfoList)
     done
   subgoal for setResult 
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s "])
        defer apply wpsimp+
     apply (rule corres_underlying_split_r_ret[where P = "λdr _. True"
              and P' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s ∧ r = 1" 
              and r' = "λ_ _. True"])
     subgoal 
       apply(rule corres_condition_notG)
       unfolding actorPluginInfoEqual_def stateACBEqual_def
        apply auto
       using ded_imp_pluginINIT apply linarith
       using ded_imp_pluginINIT apply linarith
       using ded_imp_pluginINIT apply linarith
       by (simp add: ded_imp_pluginINIT)
     apply wpsimp
     subgoal
       apply wpsimp
       apply (wpsimp wp: des_impl_updateActorPluginState_aux4)
          apply wpsimp+
       unfolding actorPluginInfoEqual_def stateACBEqual_def  
          apply auto
          apply (simp add: ded_imp_pluginINIT)
         apply (simp add: ded_imp_pluginINIT)
         apply (simp add: ded_imp_pluginINIT)
         apply (simp add: ded_imp_pluginINIT)
         using impl_ACTOR_STATE_INIT_def by auto
     apply auto
     apply(rule corres_condition_G)
     apply auto
     subgoal for setResulta
       apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s"])
       apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s ∧
                                        r = sint (ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s anActorPtr))"])
       defer apply wpsimp+
     apply (rule corres_underlying_split_r[where P = "λdr _. True"
              and P' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s " 
              and r' = "λretDes retImpl. (retDes = True ∧ retImpl = 1) ∨ (retDes = False ∧ retImpl = 0) "])
          defer apply wpsimp+
       subgoal for anActorID
         apply (wpsimp wp: des_impl_updateActorPluginState_aux5)
         done
      apply auto
      apply (insert des_impl_startActorPlugins)
      apply (unfold actorPluginInfoEqual_def)
      apply (rule corres_rel_imp[where r' = "(λdr ir. dr ∧ ir = 1)"])
      subgoal for rv
        apply (unfold corres_underlying_def)
        apply auto
        done
      apply auto
      done
     done
    subgoal
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s"])
      defer
      apply wpsimp+
      apply (unfold actorPluginInfoEqual_def)
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s
                                                      ∧ r = sint (ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s anActorPtr))"])
      defer
      subgoal
        apply(unfold bus_valid_def actorPluginInfoEqual_def) by wpsimp+
      apply wpsimp+
      apply (insert des_impl_pauseActorPlugins)
      apply (unfold actorPluginInfoEqual_def)
      apply (rule corres_rel_imp[where r' = "(λdr ir. dr ∧ ir = 1)"])
      subgoal for rv
        apply (unfold corres_underlying_def)
        apply auto
        done
      apply auto
      done
    subgoal
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s"])
      defer
      apply wpsimp+
      apply (unfold actorPluginInfoEqual_def)
      apply (rule corres_symb_exec_r[where Q' = "λr s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s anActorPtr ∧ actorPluginInfoEqual anActor anActorPtr s
                                                      ∧ r = sint (ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s anActorPtr))"])
      defer
   subgoal
        apply(unfold bus_valid_def actorPluginInfoEqual_def) by wpsimp+
      apply wpsimp+
      apply (insert des_impl_stopActorPlugins)
      apply (unfold actorPluginInfoEqual_def)
      apply (rule corres_rel_imp[where r' = "(λdr ir. dr ∧ ir = 1)"])
      subgoal for rv
        apply (unfold corres_underlying_def)
        apply auto
        done
      apply auto
      done
   by wpsimp


subsection ‹updateActorPluginStates verify›

definition actorPluginInfosEqual :: "ActorPluginInfo list ⇒ ActorPluginInfoVector_C ptr ⇒ lifted_globals ⇒ bool"
  where "actorPluginInfosEqual apil apiv glo ≡ sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C glo apiv)) = length apil ∧
              is_valid_ActorPluginInfoVector_C glo apiv ∧
              sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C glo apiv)) ≥ 0 ∧
              sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C glo apiv)) ≤ 2147483646 ∧
              (∀i. i≥0 ∧ i&lt;length apil ⟶ 
              (is_valid_ActorPluginInfo_C glo (ActorPluginInfoVector_C.data_C (heap_ActorPluginInfoVector_C glo apiv) +<span class="hidden">⇩</span><sub>p</sub> i) ∧ 
              actorPluginInfoEqual (apil!i) (ActorPluginInfoVector_C.data_C (heap_ActorPluginInfoVector_C glo apiv) +<span class="hidden">⇩</span><sub>p</sub> i) glo) ∧
              (∀ds is. stateActorPluginInfoEqual ds is ⟶ ( (ActorPluginInfo.state (apil!i)) = ds ∧ (scast (ActorPluginInfo_C.state_C (heap_ActorPluginInfo_C glo (ActorPluginInfoVector_C.data_C (heap_ActorPluginInfoVector_C glo apiv) +<span class="hidden">⇩</span><sub>p</sub> i))) = is)) 
                                                      ∨ ( (ActorPluginInfo.state (apil!i)) ≠ ds ∧ (scast (ActorPluginInfo_C.state_C (heap_ActorPluginInfo_C glo (ActorPluginInfoVector_C.data_C (heap_ActorPluginInfoVector_C glo apiv) +<span class="hidden">⇩</span><sub>p</sub> i))) ≠ is)) ) )"


lemma des_impl_updateActorPluginStates_aux011: "
         ⦃λa. Bus_invariant_2_2 (fst a) ∧ Bus_invariant_3_2 (fst a) ∧ Bus_invariant_1_2 (fst a)⦄
            NonDetMonad_call.call Des_resume (λσ. (pluginList (fst σ) ! r, snd σ)) (λσ p. (fst σ⦇pluginList := (pluginList (fst σ))[r := fst p]⦈, snd p)) 
         ⦃λxa a.  Bus_invariant_2_2 (fst a) ∧ Bus_invariant_3_2 (fst a) ∧ Bus_invariant_1_2 (fst a)⦄"
  unfolding Des_resume_def setPlugState_def NonDetMonad_call.call_def Bus_invariant_2_2_def Bus_invariant_1_2_def Bus_invariant_3_2_def
  unfolding condition_def modify_def return_def NonDetMonad.bind_def NonDetMonad.valid_def 
  apply wpsimp+
  done
lemma des_impl_updateActorPluginStates_aux012: "
         ⦃λa. Bus_invariant_2_2 (fst a) ∧ Bus_invariant_3_2 (fst a) ∧ Bus_invariant_1_2 (fst a)⦄
            NonDetMonad_call.call Des_pause (λσ. (pluginList (fst σ) ! r, snd σ)) (λσ p. (fst σ⦇pluginList := (pluginList (fst σ))[r := fst p]⦈, snd p)) 
         ⦃λxa a.  Bus_invariant_2_2 (fst a) ∧ Bus_invariant_3_2 (fst a) ∧ Bus_invariant_1_2 (fst a)⦄"
  unfolding Des_pause_def setPlugState_def NonDetMonad_call.call_def Bus_invariant_2_2_def Bus_invariant_1_2_def Bus_invariant_3_2_def
  unfolding condition_def modify_def return_def NonDetMonad.bind_def NonDetMonad.valid_def 
  apply wpsimp+
  apply auto
  done
lemma des_impl_updateActorPluginStates_aux013: "
         ⦃λa. Bus_invariant_2_2 (fst a) ∧ Bus_invariant_3_2 (fst a) ∧ Bus_invariant_1_2 (fst a)⦄
            NonDetMonad_call.call Des_stop (λσ. (pluginList (fst σ) ! r, snd σ)) (λσ p. (fst σ⦇pluginList := (pluginList (fst σ))[r := fst p]⦈, snd p)) 
         ⦃λxa a.  Bus_invariant_2_2 (fst a) ∧ Bus_invariant_3_2 (fst a) ∧ Bus_invariant_1_2 (fst a)⦄"
  unfolding Des_stop_def setPlugState_def NonDetMonad_call.call_def Bus_invariant_2_2_def Bus_invariant_1_2_def Bus_invariant_3_2_def
  unfolding condition_def modify_def return_def NonDetMonad.bind_def NonDetMonad.valid_def 
  apply wpsimp+
  apply auto
  done


lemma des_impl_updateActorPluginStates_aux01: "
    ⦃λb. Bus_invariant_2_2 (fst b) ∧ Bus_invariant_3_2 (fst b) ∧ Bus_invariant_1_2 (fst b)⦄ 
      Des_startActorPlugins aid
    ⦃λa b. Bus_invariant_2_2 (fst b) ∧ Bus_invariant_3_2 (fst b) ∧ Bus_invariant_1_2 (fst b)⦄"
  unfolding Des_startActorPlugins_def 
  apply(subst whileLoop_add_inv
            [where I= "λi s.  Bus_invariant_2_2 (fst s)  ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)" 
              and M= "λ(i, s). nat (nRegisteredPlugin (fst s))  - i"])
  apply wpsimp+
      apply (rule des_impl_updateActorPluginStates_aux011)
     apply wpsimp+
  done
lemma des_impl_updateActorPluginStates_aux02: "
    ⦃λb. Bus_invariant_2_2 (fst b) ∧ Bus_invariant_3_2 (fst b) ∧ Bus_invariant_1_2 (fst b)⦄ 
      Des_pauseActorPlugins aid
    ⦃λa b. Bus_invariant_2_2 (fst b) ∧ Bus_invariant_3_2 (fst b) ∧ Bus_invariant_1_2 (fst b)⦄"
  unfolding Des_pauseActorPlugins_def 
  apply(subst whileLoop_add_inv
            [where I= "λi s.  Bus_invariant_2_2 (fst s)  ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)" 
              and M= "λ(i, s). nat (nRegisteredPlugin (fst s))  - i"])
  apply wpsimp+
      apply (rule des_impl_updateActorPluginStates_aux012)
     apply wpsimp+
  done
lemma des_impl_updateActorPluginStates_aux03: "
    ⦃λb. Bus_invariant_2_2 (fst b) ∧ Bus_invariant_3_2 (fst b) ∧ Bus_invariant_1_2 (fst b)⦄ 
      Des_stopActorPlugins aid
    ⦃λa b. Bus_invariant_2_2 (fst b) ∧ Bus_invariant_3_2 (fst b) ∧ Bus_invariant_1_2 (fst b)⦄"
  unfolding Des_stopActorPlugins_def 
  apply(subst whileLoop_add_inv
            [where I= "λi s.  Bus_invariant_2_2 (fst s)  ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)" 
              and M= "λ(i, s). nat (nRegisteredPlugin (fst s))  - i"])
  apply wpsimp+
      apply (rule des_impl_updateActorPluginStates_aux013)
     apply wpsimp+
  done

  

lemma des_impl_updateActorPluginStates_aux11: "
       ⦃λb. Bus_invariant_2_2 (fst b) ∧ Bus_invariant_3_2 (fst b) ∧ Bus_invariant_1_2 (fst b)⦄ 
            Des_updateActorPluginState api anState
       ⦃λa b. Bus_invariant_2_2 (fst b) ∧ Bus_invariant_3_2 (fst b) ∧ Bus_invariant_1_2 (fst b)⦄"
  apply (unfold Des_updateActorPluginState_def)
  apply (case_tac "anState")
      apply auto
      apply (simp add: des_impl_updateActorPluginState_aux1)
  subgoal
    apply (insert des_impl_updateActorPluginState_aux1)
    apply (insert des_impl_updateActorPluginStates_aux01)
    apply (unfold condition_def NonDetMonad.bind_def NonDetMonad.valid_def)
    apply auto
    apply (smt case_prodD fst_conv in_return post_by_hoare2 des_impl_updateActorPluginState_aux1)+
    done
  apply (rule des_impl_updateActorPluginStates_aux01)
  apply (rule des_impl_updateActorPluginStates_aux02)
  apply (rule des_impl_updateActorPluginStates_aux03)
  done
  

lemma des_impl_updateActorPluginStates_aux1: "
       stateActorPluginInfoEqual anState anImplState ⟹
       anState ≠ ActorPluginInfo.state (apil ! x) ⟹
       ⦃λb. Bus_invariant_2_2 (fst b) ∧ Bus_invariant_3_2 (fst b) ∧ Bus_invariant_1_2 (fst b)⦄ 
                             do tmpRes &lt;- Des_updateActorPluginState (apil ! x) anState;
                                if y ⟶ ¬ tmpRes then throwError x else returnOk (x + 1, y ∧ tmpRes)
                             od 
       ⦃λa b. Bus_invariant_2_2 (fst b) ∧ Bus_invariant_3_2 (fst b) ∧ Bus_invariant_1_2 (fst b)⦄,
       ⦃λx a. Bus_invariant_2_2 (fst a) ∧ Bus_invariant_3_2 (fst a) ∧ Bus_invariant_1_2 (fst a)⦄"
  apply (insert des_impl_updateActorPluginStates_aux11)
  apply (case_tac "y")
    apply auto
  subgoal
    apply (unfold throwError_def returnOk_def return_def  NonDetMonad.valid_def  NonDetMonad.bind_def validE_def)
    apply rule+
    apply auto
    apply (smt case_prod_beta' comp_def eq_snd_iff fstI singletonD)+
    done
  subgoal
    apply (unfold throwError_def returnOk_def return_def  NonDetMonad.valid_def  NonDetMonad.bind_def validE_def)
    apply rule+
    apply auto
    apply (smt case_prod_beta' comp_def eq_snd_iff fstI singletonD)+
    done
  done

lemma des_impl_updateActorPluginStates_aux3110_aux:
  "no_fail (λs. bus_valid busPtr s)
     (whileLoop (λr s. 0 ≤ r ∧
                       r &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)))
        (λr. do y &lt;- guard (λs. r &lt; 128);
                y &lt;-
                guard
                 (λs. is_valid_w64 s
                       (PTR_COERCE(64 signed word → 64 word)
                         (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub> r)));
                y &lt;-
                condition (λs. sint
                                (heap_w64 s
                                  (PTR_COERCE(64 signed word → 64 word)
                                    (PTR(64 signed word)
                                      &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub>
                                     r))) =
                               rva)
                  (resume' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r))
                  skip;
                y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
                return (r + 1)
             od)
       0)"
  apply (rule noFail_whileLoop)
  apply (rule non_fail_seq2)
  apply simp
  apply (rule non_fail_seq2)
  subgoal
    unfolding bus_valid_def
    apply (meson less_eq_int_code(1) pluginOwner_valid_def zero_less_numeral)
    done
  apply (rule non_fail_seq3)
  apply wpsimp
  apply rule
  subgoal
    apply (rule non_fail_condition)
    apply rule
    unfolding resume'_def setState'_def
    subgoal
      apply (rule non_fail_seq4)
      apply (simp add: bus_valid_def pluginList_valid_def)
       apply (metis (no_types) less_eq_int_code(1) ptr_add_0_id zero_less_numeral)
      apply (rule non_fail_condition)
      apply rule
      apply (rule non_fail_skip)
      apply (rule non_fail_seq4)
       apply (simp add:bus_valid_def pluginList_valid_def)
       apply auto[1]
      apply wpsimp
      done
    apply (rule non_fail_skip)
    done
  apply rule
   apply wpsimp
  unfolding resume'_def setState'_def bus_valid_def
  apply wpsimp+
  done


lemma des_impl_updateActorPluginStates_aux3110: 
  "no_fail (λs. bus_valid busPtr s) (Impl_startActorPlugins busPtr rva)"
  unfolding Impl_startActorPlugins_def
  apply wpsimp
  apply (rule des_impl_updateActorPluginStates_aux3110_aux)
  apply wpsimp
    apply wpsimp
   apply wpsimp
  unfolding bus_valid_def
  apply auto
  done

lemma des_impl_updateActorPluginStates_aux3111_aux:
  "no_fail (λs. bus_valid busPtr s)
     (whileLoop (λr s. 0 ≤ r ∧
                       r &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)))
        (λr. do y &lt;- guard (λs. r &lt; 128);
                y &lt;-
                guard
                 (λs. is_valid_w64 s
                       (PTR_COERCE(64 signed word → 64 word)
                         (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub> r)));
                y &lt;-
                condition (λs. sint
                                (heap_w64 s
                                  (PTR_COERCE(64 signed word → 64 word)
                                    (PTR(64 signed word)
                                      &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub>
                                     r))) =
                               rva)
                  (pause' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r))
                  skip;
                y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
                return (r + 1)
             od)
       0)"
  apply (rule noFail_whileLoop)
  apply (rule non_fail_seq2)
  apply simp
  apply (rule non_fail_seq2)
  subgoal
    unfolding bus_valid_def
    apply (meson less_eq_int_code(1) pluginOwner_valid_def zero_less_numeral)
    done
  apply (rule non_fail_seq3)
  apply wpsimp
  apply rule
  subgoal
    apply(rule non_fail_condition)
    apply rule
     defer 
     apply (rule non_fail_skip) 
    unfolding pause'_def
    apply (rule non_fail_seq4)
     apply(simp add: bus_valid_def pluginList_valid_def)
    apply auto[1]
    apply (rule non_fail_condition)
    apply rule
    apply (rule non_fail_skip)
    apply (rule non_fail_condition)
    apply rule
    apply (rule non_fail_skip)
    unfolding setState'_def
    apply wpsimp
    unfolding bus_valid_def pluginList_valid_def
    apply auto[1]
    done
  apply rule
   apply wpsimp
  unfolding pause'_def setState'_def bus_valid_def
  apply wpsimp
  done

lemma des_impl_updateActorPluginStates_aux3111: 
  "no_fail (λs. bus_valid busPtr s) (Impl_pauseActorPlugins busPtr rva)"
  unfolding Impl_pauseActorPlugins_def
  apply wpsimp
  apply (rule des_impl_updateActorPluginStates_aux3111_aux)
  apply wpsimp
    apply wpsimp
   apply wpsimp
  unfolding bus_valid_def
  apply auto
  done


lemma des_impl_updateActorPluginStates_aux3112_aux:
  "no_fail (λs. bus_valid busPtr s)
     (whileLoop (λr s. 0 ≤ r ∧
                       r &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)))
        (λr. do y &lt;- guard (λs. r &lt; 128);
                y &lt;-
                guard
                 (λs. is_valid_w64 s
                       (PTR_COERCE(64 signed word → 64 word)
                         (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub> r)));
                y &lt;-
                condition (λs. sint
                                (heap_w64 s
                                  (PTR_COERCE(64 signed word → 64 word)
                                    (PTR(64 signed word)
                                      &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub>
                                     r))) =
                               rva)
                  (stop' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r))
                  skip;
                y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
                return (r + 1)
             od)
       0)"
  apply (rule noFail_whileLoop)
  apply (rule non_fail_seq2)
  apply simp
  apply (rule non_fail_seq2)
  subgoal
    unfolding bus_valid_def
    apply (meson less_eq_int_code(1) pluginOwner_valid_def zero_less_numeral)
    done
  apply (rule non_fail_seq3)
  apply wpsimp
  apply rule
  subgoal
    apply(rule non_fail_condition)
    apply rule
     defer 
     apply (rule non_fail_skip) 
    unfolding stop'_def
    apply (rule non_fail_seq4)
     apply(simp add: bus_valid_def pluginList_valid_def)
    apply auto[1]
    apply (rule non_fail_condition)
    apply rule
    apply (rule non_fail_skip)
    unfolding setState'_def
    apply wpsimp
    unfolding bus_valid_def pluginList_valid_def
    apply auto[1]
    done
  apply rule
   apply wpsimp
  unfolding stop'_def setState'_def bus_valid_def
  apply wpsimp
  done

lemma des_impl_updateActorPluginStates_aux3112: 
  "no_fail (λs. bus_valid busPtr s) (Impl_stopActorPlugins busPtr rva)"
  unfolding Impl_stopActorPlugins_def
  apply wpsimp
  apply (rule des_impl_updateActorPluginStates_aux3112_aux)
  apply wpsimp
    apply wpsimp
   apply wpsimp
  unfolding bus_valid_def
  apply auto
  done


lemma des_impl_updateActorPluginStates_aux31131_aux: 
  "⋀ret' tBusName str2___ptr_to_char'param.
       no_fail (λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia ∧ actorPluginInfoEqual apil apia s
              )
        (condition (λs. compare' s tBusName str2___ptr_to_char'param = 0)
          (do ret &lt;-
              condition (λs. setResult ≠ 0)
                (do y &lt;-
                    guard
                     (λs. is_valid_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])));
                    y &lt;-
                    guard
                     (λs. is_valid_PluginInfoVector_C s
                           (plugins_C
                             (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])))));
                    y &lt;-
                    guard
                     (λs. is_valid_PluginInfo_C s
                           (PluginInfoVector_C.data_C
                             (heap_PluginInfoVector_C s
                               (plugins_C
                                 (heap_TaskInfo_C s
                                   (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])))))));
                    pluginName___ptr_to_char'param &lt;-
                    gets
                     (λs. PluginInfo_C.name_C
                           (heap_PluginInfo_C s
                             (PluginInfoVector_C.data_C
                               (heap_PluginInfoVector_C s
                                 (plugins_C
                                   (heap_TaskInfo_C s
                                     (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))))))));
                    y &lt;- guard (λs. is_valid_ActorPluginInfo_C s apia);
                    actorID___longlong'param &lt;-
                    gets (λs. ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s apia));
                    ret' &lt;-
                    Impl_loadPlugin busPtr pluginName___ptr_to_char'param
                     actorID___longlong'param;
                    return (if ret' ≠ 0 then 1 else 0)
                 od)
                (return 0);
              return (ret, ret)
           od)
          (return (ret', setResult)))"
  apply (rule non_fail_condition)
  apply auto
  defer 
  apply wpsimp
  apply (rule non_fail_super)
  done
  
lemma des_impl_updateActorPluginStates_aux31131_aux2:
  "⋀ret' tBusName y str2___ptr_to_char'param p.
       no_fail (λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia ∧ actorPluginInfoEqual apil apia s)
        (if snd p = 0 then throwError (Break, fst (0, ret', setResult), snd p)
         else do guard (λs. 0 ≤ (2147483649) + fst (0, ret', setResult));
                 guard (λs. fst (0, ret', setResult) ≤ 2147483646);
                 guard (λs. is_valid_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])));
                 v___ptr_to_struct_PluginInfoVector_C'param &lt;-
                 gets
                  (λs. plugins_C
                        (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))));
                 ret'a &lt;-
                 gets
                  (λs. sint
                        (PluginInfoVector_C.length_C
                          (heap_PluginInfoVector_C s
                            v___ptr_to_struct_PluginInfoVector_C'param)));
                 returnOk (fst (0, ret', setResult) + 1, ret'a, snd p)
              od)"
  apply wpsimp
  apply auto
  using zero_axi
  apply auto[1]
  using zero_axi
   apply auto[1]
  unfolding actorPluginInfoEqual_def
  apply auto
  done

lemma des_impl_updateActorPluginStates_aux31131_aux31:
  "⋀ret' tBusName y str2___ptr_to_char'param pluginName___ptr_to_char'param
       actorID___longlong'param ret'a plugin_ptr aPluginName_ptr.
       ⦃λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia ∧ actorPluginInfoEqual apil apia s⦄
       initializePlugin' plugin_ptr actorID___longlong'param aPluginName_ptr 
       ⦃λret'b s.
           is_valid_GeneralBus_C s busPtr ⟶
           0 ≤ 2147483649 + sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) ⟶
           sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) ≤ 2147483646 ⟶
           bus_valid busPtr
            (heap_GeneralBus_C_update
              (λa b. if b = busPtr
                     then nRegisteredPlugin_C_update
                           (λa. nRegisteredPlugin_C (heap_GeneralBus_C s busPtr) + 1) (a busPtr)
                     else a b)
              s) ∧
           is_valid_ActorPluginInfo_C s apia ∧
           actorPluginInfoEqual apil apia
            (heap_GeneralBus_C_update
              (λa b. if b = busPtr
                     then nRegisteredPlugin_C_update
                           (λa. nRegisteredPlugin_C (heap_GeneralBus_C s busPtr) + 1) (a busPtr)
                     else a b)
              s)⦄"
  unfolding initializePlugin'_def
  apply (insert add_plugin_sem)
  apply wpsimp
  apply auto
  defer 
  subgoal
    using actorPluginInfo_valid
    by blast
  unfolding bus_valid_def 
  apply auto
  subgoal
    using sint_add_1 by blast
  subgoal
    using sint_add_4 by blast
  subgoal
    unfolding pluginOwner_valid_def
    by simp
  subgoal
    unfolding pluginList_valid_def
    by simp
  subgoal
    unfolding pluginName_valid_def
    by simp
  done
  
lemma des_impl_updateActorPluginStates_aux31131_aux32:
  "⋀ret' tBusName y str2___ptr_to_char'param pluginName___ptr_to_char'param
       actorID___longlong'param plug.
       pluginName___ptr_to_char'param ≠ NULL ⟹
       ⦃λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia ∧ actorPluginInfoEqual apil apia s⦄
       Impl_addPlugin busPtr plug 
       ⦃λxb a.
           is_valid_GeneralBus_C a busPtr ⟶
           sint (nRegisteredPlugin_C (heap_GeneralBus_C a busPtr)) &lt; 128 ⟶
           0 ≤ sint (nRegisteredPlugin_C (heap_GeneralBus_C a busPtr)) ⟶
           (∀aa∈set (array_addrs (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C''])) 128).
               is_valid_w64 a (PTR_COERCE(64 signed word → 64 word) aa)) ⟶
           (∀x∈set (array_addrs (PTR(8 word ptr) &amp;(busPtr→[''pluginName_C''])) 128).
               is_valid_w8'ptr a x) ⟶
           is_valid_w8'ptr a
            (PTR(8 word ptr) &amp;(busPtr→[''pluginName_C'']) +<span class="hidden">⇩</span><sub>p</sub>
             sint (nRegisteredPlugin_C (heap_GeneralBus_C a busPtr))) ⟶
           bus_valid busPtr
            (heap_w8'ptr_update
              (λaa. aa
                  (PTR(8 word ptr) &amp;(busPtr→[''pluginName_C'']) +<span class="hidden">⇩</span><sub>p</sub>
                   sint (nRegisteredPlugin_C (heap_GeneralBus_C a busPtr)) :=
                     pluginName___ptr_to_char'param))
              (heap_w64_update
                (λaa. aa
                    (PTR_COERCE(64 signed word → 64 word)
                      (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub>
                       sint (nRegisteredPlugin_C (heap_GeneralBus_C a busPtr))) :=
                       SCAST(64 signed → 64) actorID___longlong'param))
                a)) ∧
           is_valid_ActorPluginInfo_C a apia ∧
           actorPluginInfoEqual apil apia
            (heap_w8'ptr_update
              (λaa. aa
                  (PTR(8 word ptr) &amp;(busPtr→[''pluginName_C'']) +<span class="hidden">⇩</span><sub>p</sub>
                   sint (nRegisteredPlugin_C (heap_GeneralBus_C a busPtr)) :=
                     pluginName___ptr_to_char'param))
              (heap_w64_update
                (λaa. aa
                    (PTR_COERCE(64 signed word → 64 word)
                      (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub>
                       sint (nRegisteredPlugin_C (heap_GeneralBus_C a busPtr))) :=
                       SCAST(64 signed → 64) actorID___longlong'param))
                a))⦄"
  apply (insert add_plugin_sem)
  apply wpsimp
  apply auto
  unfolding bus_valid_def
   apply auto 
  subgoal 
    unfolding pluginOwner_valid_def
    by auto
  subgoal
    unfolding pluginList_valid_def
    by auto
  subgoal
    unfolding pluginName_valid_def
    by auto
  subgoal
    using actorPluginInfo_valid
    by blast
  done
  
lemma des_impl_updateActorPluginStates_aux31131_aux3:
  "⋀ret' tBusName y str2___ptr_to_char'param.
       ⦃λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia ∧ actorPluginInfoEqual apil apia s⦄
       condition (λs. compare' s tBusName str2___ptr_to_char'param = 0)
         (do ret &lt;-
             condition (λs. setResult ≠ 0)
               (do y &lt;-
                   guard (λs. is_valid_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])));
                   y &lt;-
                   guard
                    (λs. is_valid_PluginInfoVector_C s
                          (plugins_C
                            (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])))));
                   y &lt;-
                   guard
                    (λs. is_valid_PluginInfo_C s
                          (PluginInfoVector_C.data_C
                            (heap_PluginInfoVector_C s
                              (plugins_C
                                (heap_TaskInfo_C s
                                  (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])))))));
                   pluginName___ptr_to_char'param &lt;-
                   gets
                    (λs. PluginInfo_C.name_C
                          (heap_PluginInfo_C s
                            (PluginInfoVector_C.data_C
                              (heap_PluginInfoVector_C s
                                (plugins_C
                                  (heap_TaskInfo_C s
                                    (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))))))));
                   y &lt;- guard (λs. is_valid_ActorPluginInfo_C s apia);
                   actorID___longlong'param &lt;-
                   gets (λs. ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s apia));
                   ret' &lt;-
                   Impl_loadPlugin busPtr pluginName___ptr_to_char'param
                    actorID___longlong'param;
                   return (if ret' ≠ 0 then 1 else 0)
                od)
               (return 0);
             return (ret, ret)
          od)
         (return (ret', setResult)) 
       ⦃λp s. bus_valid busPtr s ∧
              is_valid_ActorPluginInfo_C s apia ∧ actorPluginInfoEqual apil apia s⦄"
  unfolding Impl_loadPlugin_def Impl_createInstance_def
  apply wpsimp
  apply(rule des_impl_updateActorPluginStates_aux31131_aux31)
  apply wpsimp+
  apply (rule des_impl_updateActorPluginStates_aux31131_aux32)
  apply wpsimp+
  done

lemma des_impl_updateActorPluginStates_aux31131_aux4:
  "⋀ret' tBusName y.
       ⦃(λs. bus_valid busPtr s ∧
                is_valid_ActorPluginInfo_C s apia ∧ actorPluginInfoEqual apil apia s)⦄ gets (λs. GeneralBus_C.name_C (heap_GeneralBus_C s busPtr)) 
       ⦃λstr2___ptr_to_char'param.
           (λa. bus_valid busPtr a ∧
                is_valid_ActorPluginInfo_C a apia ∧ actorPluginInfoEqual apil apia a) and
           (λs. bus_valid busPtr s ∧
                is_valid_ActorPluginInfo_C s apia ∧ actorPluginInfoEqual apil apia s)⦄"
  apply wpsimp
  done

lemma des_impl_updateActorPluginStates_aux31131_aux5:
  "⋀ret'.
       ⦃(λs. bus_valid busPtr s ∧
                is_valid_ActorPluginInfo_C s apia ∧ actorPluginInfoEqual apil apia s)⦄
       gets
        (λs. busName_C
              (heap_PluginInfo_C s
                (PluginInfoVector_C.data_C
                  (heap_PluginInfoVector_C s
                    (plugins_C
                      (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])))))))) 
       ⦃λtBusName.
           (λs. is_valid_GeneralBus_C s busPtr) and
           (λs. is_valid_GeneralBus_C s busPtr ⟶
                ((λ_. True) and
                 (λs. bus_valid busPtr s ∧
                      is_valid_ActorPluginInfo_C s apia ∧ actorPluginInfoEqual apil apia s))
                 s)⦄"
  apply wpsimp
  unfolding bus_valid_def
  apply auto
  done

lemma des_impl_updateActorPluginStates_aux31131:
  "⋀ret'.
       no_fail (λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia ∧ actorPluginInfoEqual apil apia s ∧
              ret' =  sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s rva)))
        (whileLoopE (λr. case r of (i, ret, setResult) ⇒ λa. 0 ≤ i ∧ i &lt; ret')
           (λr. case r of
                (i, ret, setResult) ⇒
                  do y &lt;-
                     guard
                      (λs. is_valid_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])));
                     y &lt;-
                     guard
                      (λs. is_valid_PluginInfoVector_C s
                            (plugins_C
                              (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])))));
                     y &lt;-
                     guard
                      (λs. is_valid_PluginInfo_C s
                            (PluginInfoVector_C.data_C
                              (heap_PluginInfoVector_C s
                                (plugins_C
                                  (heap_TaskInfo_C s
                                    (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>
                             i));
                     tBusName &lt;-
                     gets
                      (λs. busName_C
                            (heap_PluginInfo_C s
                              (PluginInfoVector_C.data_C
                                (heap_PluginInfoVector_C s
                                  (plugins_C
                                    (heap_TaskInfo_C s
                                      (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>
                               i)));
                     y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
                     str2___ptr_to_char'param &lt;-
                     gets (λs. GeneralBus_C.name_C (heap_GeneralBus_C s busPtr));
                     (ret, setResult) &lt;-
                     condition (λs. compare' s tBusName str2___ptr_to_char'param = 0)
                       (do ret &lt;-
                           condition (λs. setResult ≠ 0)
                             (do y &lt;-
                                 guard
                                  (λs. is_valid_TaskInfo_C s
                                        (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])));
                                 y &lt;-
                                 guard
                                  (λs. is_valid_PluginInfoVector_C s
                                        (plugins_C
                                          (heap_TaskInfo_C s
                                            (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])))));
                                 y &lt;-
                                 guard
                                  (λs. is_valid_PluginInfo_C s
                                        (PluginInfoVector_C.data_C
                                          (heap_PluginInfoVector_C s
                                            (plugins_C
                                              (heap_TaskInfo_C s
                                                (PTR(TaskInfo_C)
 &amp;(apia→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>
                                         i));
                                 pluginName___ptr_to_char'param &lt;-
                                 gets
                                  (λs. PluginInfo_C.name_C
                                        (heap_PluginInfo_C s
                                          (PluginInfoVector_C.data_C
                                            (heap_PluginInfoVector_C s
                                              (plugins_C
                                                (heap_TaskInfo_C s
 (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>
                                           i)));
                                 y &lt;- guard (λs. is_valid_ActorPluginInfo_C s apia);
                                 actorID___longlong'param &lt;-
                                 gets
                                  (λs. ActorPluginInfo_C.actorID_C
                                        (heap_ActorPluginInfo_C s apia));
                                 ret' &lt;-
                                 Impl_loadPlugin busPtr pluginName___ptr_to_char'param
                                  actorID___longlong'param;
                                 return (if ret' ≠ 0 then 1 else 0)
                              od)
                             (return 0);
                           return (ret, ret)
                        od)
                       (return (ret', setResult));
                     if setResult = 0 then throwError (Break, i, setResult)
                     else do guard (λs. 0 ≤ 2147483649 + i);
                             guard (λs. i ≤ 2147483646);
                             guard
                              (λs. is_valid_TaskInfo_C s
                                    (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])));
                             v___ptr_to_struct_PluginInfoVector_C'param &lt;-
                             gets
                              (λs. plugins_C
                                    (heap_TaskInfo_C s
                                      (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))));
                             ret' &lt;-
                             gets
                              (λs. sint
                                    (PluginInfoVector_C.length_C
                                      (heap_PluginInfoVector_C s
                                        v___ptr_to_struct_PluginInfoVector_C'param)));
                             returnOk (i + 1, ret', setResult)
                          od
                  od)
          (0, ret', setResult))"
  apply (rule noFail_whileLoopE)
  unfolding case_prod_unfold
  apply (rule non_fail_seq2)
  apply (simp add: actorPluginInfoEqual_def)
  apply auto[1]
  apply (rule non_fail_seq2)
  apply (simp add: actorPluginInfoEqual_def)
  apply (rule non_fail_seq2)
   apply auto[1]
  using pluginInfo_valid
   apply blast
  apply wpsimp
  apply (rule des_impl_updateActorPluginStates_aux31131_aux[where apil = "apil"])
  apply (rule des_impl_updateActorPluginStates_aux31131_aux2[where busPtr = "busPtr" and apil = "apil"])
  apply (rule des_impl_updateActorPluginStates_aux31131_aux3)
  apply (rule des_impl_updateActorPluginStates_aux31131_aux4)
  apply wpsimp             
   apply (rule des_impl_updateActorPluginStates_aux31131_aux5)
  apply auto
  done

lemma des_impl_updateActorPluginStates_aux3113:
  "stateActorPluginInfoEqual anState anImplState ⟹
   no_fail (λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia ∧ actorPluginInfoEqual apil apia s) 
          (Impl_loadPluginInfoList setResult busPtr rva apia)"
  unfolding Impl_loadPluginInfoList_def pluginInfoVectorSize'_def
  apply wpsimp
  apply(simp add:catch_def)
  apply wpsimp
  apply (rule des_impl_updateActorPluginStates_aux31131[where rva = "rva"])
  apply wpsimp+
  apply auto
  done

lemma des_impl_updateActorPluginStates_aux3114:
  "stateActorPluginInfoEqual anState anImplState ⟹
    no_fail (λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia ∧ actorPluginInfoEqual apil2 apia s) 
     (condition (λs. sint (ActorPluginInfo_C.state_C (heap_ActorPluginInfo_C s apia)) = sint impl_ACTOR_STATE_INIT)
       (do y &lt;- guard (λs. is_valid_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])));
           v___ptr_to_struct_PluginInfoVector_C'param &lt;- gets (λs. plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))));
           Impl_loadPluginInfoList setResult busPtr v___ptr_to_struct_PluginInfoVector_C'param apia
        od)
       (return setResult))"
    apply (rule non_fail_condition)
  apply auto
   apply wpsimp+
      apply(wpsimp wp:des_impl_updateActorPluginStates_aux3113)
     apply wpsimp+ defer apply wpsimp
  apply auto
  unfolding actorPluginInfoEqual_def
  apply auto
  done

lemma des_impl_updateActorPluginStates_aux3115:
  "no_fail (λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia ) 
     (condition (λs. setResult ≠ 0)
          (do y &lt;- guard (λs. is_valid_ActorPluginInfo_C s apia);
              anActorID___longlong'param &lt;- gets (λs. sint (ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s apia)));
              ret' &lt;- Impl_startActorPlugins busPtr anActorID___longlong'param;
              return (if ret' ≠ 0 then 1 else 0)
           od)
          (return 0))"
    apply (rule non_fail_condition)
  apply auto
   apply wpsimp+
        apply(wpsimp wp:des_impl_updateActorPluginStates_aux3110)
  by wpsimp+

lemma des_impl_updateActorPluginStates_aux3117_aux:
  "⦃λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia⦄
       Impl_loadPlugin busPtr pluginName___ptr_to_char'param actorID___longlong'param 
       ⦃λret' a.
           (ret' = 0 ⟶ bus_valid busPtr a ∧ is_valid_ActorPluginInfo_C a apia) ∧
           (ret' ≠ 0 ⟶
            0 ≤ 2147483649 + x ⟶
            x ≤ 2147483646 ⟶
            is_valid_TaskInfo_C a (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])) ⟶
            bus_valid busPtr a ∧ is_valid_ActorPluginInfo_C a apia)⦄"
  unfolding Impl_loadPlugin_def initializePlugin'_def Impl_createInstance_def
  apply (insert add_plugin_sem)
  apply wpsimp
  unfolding bus_valid_def
  apply auto
  apply (simp add: sint_add_1)
     apply (meson sint_add_2)
  subgoal
    unfolding pluginOwner_valid_def
    by simp
  subgoal
    unfolding pluginList_valid_def
    by simp
  subgoal
    unfolding pluginName_valid_def
    by simp
  done
  
lemma des_impl_updateActorPluginStates_aux3117:
  "⦃λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia ∧ 
        ret' = sint (PluginInfoVector_C.length_C (heap_PluginInfoVector_C s pivec)) ⦄
       whileLoopE (λ(i, ret, setResult) a. 0 ≤ i ∧ i &lt; ret')
         (λ(i, ret, setResult).
             do guard (λs. is_valid_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])));
                guard (λs. is_valid_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])))));
                guard
                 (λs. is_valid_PluginInfo_C s
                        (PluginInfoVector_C.data_C
                          (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>
                         i));
                tBusName &lt;-
                gets
                 (λs. busName_C
                        (heap_PluginInfo_C s
                          (PluginInfoVector_C.data_C
                            (heap_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>
                           i)));
                guard (λs. is_valid_GeneralBus_C s busPtr);
                str2___ptr_to_char'param &lt;- gets (λs. GeneralBus_C.name_C (heap_GeneralBus_C s busPtr));
                (ret, setResult) &lt;-
                condition (λs. compare' s tBusName str2___ptr_to_char'param = 0)
                  (do ret &lt;-
                      condition (λs. setResult ≠ 0)
                        (do guard (λs. is_valid_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])));
                            guard
                             (λs. is_valid_PluginInfoVector_C s (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])))));
                            guard
                             (λs. is_valid_PluginInfo_C s
                                    (PluginInfoVector_C.data_C
                                      (heap_PluginInfoVector_C s
                                        (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>
                                     i));
                            pluginName___ptr_to_char'param &lt;-
                            gets
                             (λs. PluginInfo_C.name_C
                                    (heap_PluginInfo_C s
                                      (PluginInfoVector_C.data_C
                                        (heap_PluginInfoVector_C s
                                          (plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))))) +<span class="hidden">⇩</span><sub>p</sub>
                                       i)));
                            guard (λs. is_valid_ActorPluginInfo_C s apia);
                            actorID___longlong'param &lt;- gets (λs. ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s apia));
                            ret' &lt;- Impl_loadPlugin busPtr pluginName___ptr_to_char'param actorID___longlong'param;
                            return (if ret' ≠ 0 then 1 else 0)
                         od)
                        (return 0);
                      return (ret, ret)
                   od)
                  (return (ret', setResult));
                if setResult = 0 then throwError (Break, i, setResult)
                else do guard (λs. 0 ≤ 2147483649 + i);
                        guard (λs. i ≤ 2147483646);
                        guard (λs. is_valid_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])));
                        v___ptr_to_struct_PluginInfoVector_C'param &lt;-
                        gets (λs. plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))));
                        ret' &lt;- pluginInfoVectorSize' v___ptr_to_struct_PluginInfoVector_C'param;
                        returnOk (i + 1, ret', setResult)
                     od
             od)
        (0, ret', setResult) 
       ⦃λx a. bus_valid busPtr a ∧ is_valid_ActorPluginInfo_C a apia⦄,
       ⦃λx. case x of (global_exn_var, ret, setResult) ⇒ λa. bus_valid busPtr a ∧ is_valid_ActorPluginInfo_C a apia⦄"
  apply(subst whileLoopE_add_inv
            [where I= "λ(i, ret, setResult) s.  bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia" 
              and M= "λ((i, ret, setResult), s). nat ( ret' - i)"])
  apply wp unfolding validE_def throwError_def returnOk_def pluginInfoVectorSize'_def
  apply wpsimp
  apply (rule des_impl_updateActorPluginStates_aux3117_aux)
  apply wpsimp apply wpsimp apply wpsimp apply wpsimp apply wpsimp 
  apply wpsimp apply wpsimp apply wpsimp apply wpsimp
  apply wpsimp apply wpsimp apply wpsimp apply wpsimp apply wpsimp
  apply auto
  done

lemma des_impl_updateActorPluginStates_aux3116:
 "⦃λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia⦄
      Impl_loadPluginInfoList setResult busPtr pivec apia
 ⦃λsetResult s. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia⦄"
  unfolding Impl_loadPluginInfoList_def
  apply wp
    apply(wpsimp wp:des_impl_updateActorPluginStates_aux3117[where pivec = "pivec"])
  unfolding pluginInfoVectorSize'_def
  by wpsimp+


lemma des_impl_updateActorPluginStates_aux311:
  "⋀api apia setResult.
       stateActorPluginInfoEqual anState anImplState ⟹
       no_fail (λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia ∧
                  actorPluginInfosEqual apil actorsPtr s ∧
                  actorPluginInfoEqual apil2 apia s ∧
                  ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))
              )
        (condition (λs. anImplState = impl_ACTOR_STATE_INIT)
          (do y &lt;- guard (λs. is_valid_ActorPluginInfo_C s apia);
              y &lt;- guard (λs. is_valid_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])));
              v___ptr_to_struct_PluginInfoVector_C'param &lt;-
              gets (λs. plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))));
              Impl_loadPluginInfoList setResult busPtr v___ptr_to_struct_PluginInfoVector_C'param apia
           od)
          (condition (λs. anImplState = impl_ACTOR_STATE_RUNNING)
            (do y &lt;- guard (λs. is_valid_ActorPluginInfo_C s apia);
                setResult &lt;-
                (condition (λs. sint (ActorPluginInfo_C.state_C (heap_ActorPluginInfo_C s apia)) = sint impl_ACTOR_STATE_INIT)
                  (do y &lt;- guard (λs. is_valid_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C''])));
                      v___ptr_to_struct_PluginInfoVector_C'param &lt;-
                      gets (λs. plugins_C (heap_TaskInfo_C s (PTR(TaskInfo_C) &amp;(apia→[''taskInfo_C'']))));
                      Impl_loadPluginInfoList setResult busPtr v___ptr_to_struct_PluginInfoVector_C'param apia
                   od)
                  (return setResult));
                (condition (λs. setResult ≠ 0)
                  (do y &lt;- guard (λs. is_valid_ActorPluginInfo_C s apia);
                      anActorID___longlong'param &lt;- gets (λs. sint (ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s apia)));
                      ret' &lt;- Impl_startActorPlugins busPtr anActorID___longlong'param;
                      return (if ret' ≠ 0 then 1 else 0)
                   od)
                  (return 0))
            od)
            (condition (λs. anImplState = impl_ACTOR_STATE_PAUSE)
              (do y &lt;- guard (λs. is_valid_ActorPluginInfo_C s apia);
                  gets (λs. sint (ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s apia))) &gt;&gt;= Impl_pauseActorPlugins busPtr
               od)
              (condition (λs. anImplState = impl_ACTOR_STATE_FINISH)
                (do y &lt;- guard (λs. is_valid_ActorPluginInfo_C s apia);
                    gets (λs. sint (ActorPluginInfo_C.actorID_C (heap_ActorPluginInfo_C s apia))) &gt;&gt;= Impl_stopActorPlugins busPtr
                 od)
                (return 0))))
         )"
  apply (rule non_fail_condition)
  apply auto
  subgoal
    apply wpsimp
    apply(wpsimp wp:des_impl_updateActorPluginStates_aux3113)
       apply wpsimp+
    apply auto
    defer
    using actorPluginInfo_valid
    apply auto[1]
    unfolding actorPluginInfoEqual_def
    apply simp
    done
  subgoal
    apply (rule non_fail_condition)
    apply auto
    subgoal 
      apply wpsimp
          apply(wpsimp wp:des_impl_updateActorPluginStates_aux3114)
         apply(wpsimp wp:des_impl_updateActorPluginStates_aux3115)
      apply wpsimp
           apply (wpsimp wp:des_impl_updateActorPluginStates_aux3116)
      by wpsimp+
    subgoal
      apply (rule non_fail_condition)
      apply auto
       apply wpsimp+
          apply (wpsimp wp:des_impl_updateActorPluginStates_aux3111)
         apply wpsimp+ 
      apply (rule non_fail_condition)
      apply auto apply wpsimp+
          apply (wpsimp wp:des_impl_updateActorPluginStates_aux3112)
      by wpsimp+ 
    done
  done


lemma des_impl_updateActorPluginStates_aux31:
  "⋀api apia. stateActorPluginInfoEqual anState anImplState ⟹
       no_fail (λs. bus_valid busPtr s ∧ is_valid_ActorPluginInfo_C s apia ∧
                  actorPluginInfosEqual apil actorsPtr s ∧
                  ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) ∧
            0 ≤ fst r' ∧ fst r' &lt; ret') (Impl_updateActorPluginState busPtr apia anImplState)"
  apply (unfold Impl_updateActorPluginState_def)
  apply wpsimp+
  apply (rule des_impl_updateActorPluginStates_aux311[where anState = "anState" and ret' = "ret'" and actorsPtr = "actorsPtr" and apil = "apil"])
    apply wpsimp+
  using actorPluginInfo_valid
  apply auto
  done

lemma des_impl_updateActorPluginStates_aux32: "
       stateActorPluginInfoEqual anState anImplState ⟹ 
       ⦃λs. bus_valid busPtr s ∧
             actorPluginInfosEqual apil actorsPtr s ∧
             ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) ∧
             0 ≤ fst r' ∧ fst r' &lt; ret'⦄ 
            Impl_updateActorPluginState busPtr apia anImplState 
       ⦃λtmpRes.
           (λa. 0 ≤ 2147483649 + fst r') and
           (λs. 0 ≤ 2147483649 + fst r' ⟶
                 ((λa. fst r' ≤ 2147483646) and
                  (λa. fst r' ≤ 2147483646 ⟶ (( λ_. True) and (if snd (snd r') = 1 ⟶ tmpRes ≠ 1 then λ_. True else (λ_. True))) a))
                  s)
      ⦄"
  apply (unfold Impl_updateActorPluginState_def actorPluginInfosEqual_def)
  apply wpsimp
  done

lemma des_impl_updateActorPluginStates_aux4: "
       stateActorPluginInfoEqual anState anImplState ⟹
       bus_valid busPtr s' ⟹
       actorPluginInfosEqual apil actorsPtr s' ⟹
       ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s' actorsPtr)) ⟹
       SCAST(16 signed → 32 signed) (ActorPluginInfo_C.state_C api) ≠ anImplState ⟹
       ⦃λs.  bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧  ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))
            ⦄ 
        Impl_updateActorPluginState busPtr apia anImplState 
       ⦃λtmpRes sa.
           0 ≤ 2147483649 + a ⟶
           a ≤ 2147483646 ⟶
           ((b = 1 ⟶ tmpRes ≠ 1) ⟶
            bus_valid busPtr sa ∧
            actorPluginInfosEqual apil actorsPtr sa ∧
            ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s' actorsPtr) =
            ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C sa actorsPtr) ∧
            0 &lt; sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) ∧
            a &lt; sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))) ∧
           (b = 1 ∧ tmpRes = 1 ⟶
            bus_valid busPtr sa ∧
            actorPluginInfosEqual apil actorsPtr sa ∧
            ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s' actorsPtr) =
            ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C sa actorsPtr) ∧
            nat (sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C sa actorsPtr))) - nat (a + 1)
            &lt; nat (sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))) - nat a)⦄"
  apply wpsimp
  apply (insert Impl_updateActorPluginState_super)
  by blast

lemma des_impl_updateActorPluginStates_aux51: "
      ⋀api apia.
       ⦃(λs. bus_valid busPtr s ∧
          actorPluginInfosEqual apil actorsPtr s ∧
          ret' =
          sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))) and
        (λs. 0 ≤ fst r' ∧ fst r' &lt; ret')⦄
        Impl_updateActorPluginState busPtr apia anImplState 
       ⦃λtmpRes s.
           0 ≤ 2147483649 + fst r' ⟶
           fst r' ≤ 2147483646 ⟶
           ((snd (snd r') = 1 ⟶ tmpRes ≠ 1) ⟶
            bus_valid busPtr s ∧
            actorPluginInfosEqual apil actorsPtr s ∧
            ret' =
            sint
             (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))) ∧
           (snd (snd r') = 1 ∧ tmpRes = 1 ⟶
            bus_valid busPtr s ∧
            actorPluginInfosEqual apil actorsPtr s ∧
            ret' =
            sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)))⦄"
  apply wpsimp
  apply (insert Impl_updateActorPluginState_super)
  by auto

lemma des_impl_updateActorPluginStates_aux5: "stateActorPluginInfoEqual anState anImplState ⟹
    ⦃(λs. bus_valid busPtr s ∧
          actorPluginInfosEqual apil actorsPtr s ∧
          ret' =
          sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))) and
     (λs. 0 ≤ fst r' ∧ fst r' &lt; ret')⦄
    do y &lt;- guard (λs. is_valid_ActorPluginInfoVector_C s actorsPtr);
       y &lt;-
       guard
        (λs. is_valid_ActorPluginInfo_C s
              (ActorPluginInfoVector_C.data_C (heap_ActorPluginInfoVector_C s actorsPtr) +<span class="hidden">⇩</span><sub>p</sub>
               fst r'));
       api &lt;-
       gets
        (λs. heap_ActorPluginInfo_C s
              (ActorPluginInfoVector_C.data_C (heap_ActorPluginInfoVector_C s actorsPtr) +<span class="hidden">⇩</span><sub>p</sub>
               fst r'));
       if SCAST(16 signed → 32 signed) (ActorPluginInfo_C.state_C api) = anImplState
       then do guard (λs. 0 ≤ 2147483649 + fst r');
               guard (λs. fst r' ≤ 2147483646);
               ret' &lt;-
               gets
                (λs. sint
                      (ActorPluginInfoVector_C.length_C
                        (heap_ActorPluginInfoVector_C s actorsPtr)));
               returnOk (fst r' + 1, ret', snd (snd r'))
            od
       else do api &lt;-
               gets
                (λs. ActorPluginInfoVector_C.data_C
                      (heap_ActorPluginInfoVector_C s actorsPtr) +<span class="hidden">⇩</span><sub>p</sub>
                     fst r');
               tmpRes &lt;- Impl_updateActorPluginState busPtr api anImplState;
               guard (λs. 0 ≤ 2147483649 + fst r');
               guard (λs. fst r' ≤ 2147483646);
               ret' &lt;-
               gets
                (λs. sint
                      (ActorPluginInfoVector_C.length_C
                        (heap_ActorPluginInfoVector_C s actorsPtr)));
               if ¬ (snd (snd r') = 1 ∧ tmpRes = 1) then throwError (fst r', ret', 0)
               else returnOk (fst r'+ 1, ret', snd (snd r'))
            od
    od 
    ⦃λ_ s. bus_valid busPtr s ∧
           actorPluginInfosEqual apil actorsPtr s ∧
           ret' =
           sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))⦄,
    ⦃λ_ s. bus_valid busPtr s ∧
           actorPluginInfosEqual apil actorsPtr s ∧
           ret' =
           sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))⦄"
  unfolding throwError_def returnOk_def validE_def
  apply wpsimp
  apply (rule des_impl_updateActorPluginStates_aux51)
  apply wpsimp+
  done


lemma des_impl_updateActorPluginStates: "
    stateActorPluginInfoEqual anState anImplState ⟹
    corres_underlying ({(t,s). busPtrEqual busPtr s (fst t)}) False False
      (λdr ir. (dr ∧ ir = 1) ∨ (¬dr ∧ ir = 0))
      (λs. Bus_invariant_2_2 (fst s) ∧  Bus_invariant_3_2 (fst s)  ∧ Bus_invariant_1_2 (fst s)) 
      (λs. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s)
      (Des_updateActorPluginStates apil anState) (Impl_updateActorPluginStates busPtr actorsPtr anImplState)"
  unfolding Impl_updateActorPluginStates_def Des_updateActorPluginStates_def
  apply (rule corres_underlying_symb_exec_l[where Q = "λdr s. Bus_invariant_2_2 (fst s) ∧  Bus_invariant_3_2 (fst s)  ∧ Bus_invariant_1_2 (fst s) ∧ dr"])
  apply auto
  unfolding case_prod_unfold
  apply (rule corres_symb_exec_r[where Q' = "λret s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s 
                    ∧ ret = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) "])
  defer unfolding actorPluginInfoVectorSize'_def
     apply wpsimp+
  subgoal for rv ret'
  apply (rule corres_underlying_split[where P = "λdr s. True" and P' = "λir s. True" 
              and r' = "λdes impl. ((snd des = False ∧ snd (snd impl) = 0)∨(snd des = True ∧ snd (snd impl) = 1)) "])
  defer 
  subgoal
    apply(subst whileLoopE_add_inv
            [where I="λr s. Bus_invariant_2_2 (fst s) 
                      ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s)" 
              and M="λ((i,st),s). nat (length apil) - i"])
    apply wpsimp+
    done
  apply wpsimp+
  unfolding catch_def
 apply(rule corres_underlying_split[where r' = "(λe e'. int e = fst e' ∧ (snd (snd e')) = 0 ) ⊕ 
             (λdes impl. ((snd des = False ∧ snd (snd impl) = 0) ∨ (snd des = True ∧ snd (snd impl) = 1)) ∧ 
                          fst impl = int (fst des ) ∧ fst (snd impl) = ret')" 
            and P = "(λ_ _. True)" and P' = "(λ_ s.  True) "])
     defer apply wpsimp+
 subgoal for x xa
   apply (case_tac "x") 
   by auto
  apply(rule corres_whileLoopE)
    subgoal for r r' s s'
      apply(case_tac r)  
      apply auto
      unfolding stateActorPluginInfoEqual_def actorPluginInfosEqual_def
      by auto
    defer 
    subgoal
      apply (simp add: case_prod_unfold)
      apply auto
      apply wpsimp
      apply (unfold Des_updateActorPluginState_def)
      apply (case_tac "anState")
      subgoal
        apply auto
        apply (insert des_impl_updateActorPluginState_aux1)
        unfolding throwError_def returnOk_def return_def NonDetMonad.valid_def NonDetMonad.bind_def
        apply (simp add: case_prod_unfold)
        apply rule+
        apply auto
      done
      subgoal
        apply (insert des_impl_updateActorPluginState_aux1)
        apply (insert des_impl_updateActorPluginStates_aux01)
        unfolding condition_def throwError_def returnOk_def return_def NonDetMonad.valid_def NonDetMonad.bind_def
        apply (simp add: case_prod_unfold)
        apply rule+
        apply auto
        apply (smt comp_apply post_by_hoare prod_injects(2) return_def singletonD des_impl_updateActorPluginState_aux1)+
      done
      subgoal
        apply (insert des_impl_updateActorPluginStates_aux02)
        unfolding throwError_def returnOk_def return_def NonDetMonad.valid_def NonDetMonad.bind_def
        apply (simp add: case_prod_unfold)
        apply rule+
        apply auto
      done
      subgoal
        apply (insert des_impl_updateActorPluginStates_aux03)
        unfolding throwError_def returnOk_def return_def NonDetMonad.valid_def NonDetMonad.bind_def
        apply (simp add: case_prod_unfold)
        apply rule+
        apply auto
      done
      subgoal
        unfolding throwError_def returnOk_def return_def NonDetMonad.valid_def NonDetMonad.bind_def
        apply (simp add: case_prod_unfold)
      done
    done
    subgoal
      apply wpsimp
      apply (rule des_impl_updateActorPluginStates_aux5[where anState = "anState"])
      apply simp+
      done
    subgoal
      apply simp
      using finish_puase_apiList by auto
    subgoal for r'(*fail*)
      apply wpsimp
      apply (rule des_impl_updateActorPluginStates_aux31[where anState = "anState" and ret' = "ret'" and actorsPtr = "actorsPtr" and apil = "apil" and r' = "r'"])
      apply simp apply wpsimp 
      apply (rule des_impl_updateActorPluginStates_aux32[where anState = "anState" and ret' = "ret'" and actorsPtr = "actorsPtr" and apil = "apil"])
      apply wpsimp+
      unfolding actorPluginInfosEqual_def
      apply auto
      apply (metis of_nat_less_iff zero_le_imp_eq_int)
      done
    subgoal for r' s' (*terminates*)
      unfolding whileLoop_terminatesE_def throwError_def returnOk_def
      apply (rule whileLoop_terminates_inv[
         where I = "λr s.  bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧  ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))" 
                  and R = "measure' (λ(r,s). case r of Inl a ⇒ 0 |
                             Inr v ⇒ nat (sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))) - nat (fst v))"])
      apply auto unfolding NonDetMonad.lift_def throwError_def returnOk_def
      apply wpsimp
      apply (wpsimp wp:des_impl_updateActorPluginStates_aux4)
      apply wpsimp+
      apply auto
      done
    apply wpsimp
    apply rule+
    subgoal for a b ba
      apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))) "])
         defer apply wpsimp+
      apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)))"])
         defer apply wpsimp+
      apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) ∧ r = heap_ActorPluginInfo_C s (ActorPluginInfoVector_C.data_C (heap_ActorPluginInfoVector_C s actorsPtr) +<span class="hidden">⇩</span><sub>p</sub> int a))"])
         defer apply wpsimp apply wpsimp apply wpsimp+
      apply rule+
      subgoal
        apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)))"])
        defer apply wpsimp+
        apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) ∧ r = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))) "])
           defer apply wpsimp+
        unfolding returnOk_def 
        apply wpsimp+
      done
      unfolding actorPluginInfosEqual_def actorPluginInfoEqual_def corres_underlying_def
      apply auto
      apply (metis (no_types))
      apply (metis (no_types))
      done
    subgoal for a b ba
      apply rule+
      apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)))"])
         defer apply wpsimp+
      apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)))"])
         defer apply wpsimp+
      apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) ∧ r = heap_ActorPluginInfo_C s (ActorPluginInfoVector_C.data_C (heap_ActorPluginInfoVector_C s actorsPtr) +<span class="hidden">⇩</span><sub>p</sub> int a))"])
         defer apply wpsimp apply wpsimp apply wpsimp+
      apply rule+
      subgoal 
        unfolding actorPluginInfosEqual_def actorPluginInfoEqual_def corres_underlying_def
        apply auto
        apply (metis (no_types))
        apply (metis (no_types))
      done
      apply rule+
      apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧
                  ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) ∧
              r = ActorPluginInfoVector_C.data_C (heap_ActorPluginInfoVector_C s actorsPtr) +<span class="hidden">⇩</span><sub>p</sub> int a )"])
       defer apply wpsimp+
    subgoal for api apia
       apply(rule corres_underlying_split[where r' = "λdr ir. (dr ∧ ir = 1) ∨ (¬dr ∧ ir = 0)" 
            and P = "(λ_ s. Bus_invariant_2_2 (fst s) ∧ Bus_invariant_3_2 (fst s) ∧ Bus_invariant_1_2 (fst s))" 
           and P' = "(λ_ s.  bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧
                  apia = ActorPluginInfoVector_C.data_C (heap_ActorPluginInfoVector_C s actorsPtr) +<span class="hidden">⇩</span><sub>p</sub> int a ∧
                  ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) )"])
      defer 
      subgoal
        apply (wpsimp wp: des_impl_updateActorPluginStates_aux11)
        done
      subgoal
        apply (insert Impl_updateActorPluginState_super)
        by simp
      subgoal
        apply wpsimp
        apply rule+
        subgoal
          apply wpsimp
          apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))) "])
             defer apply wpsimp+
          apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)))"])
             defer apply wpsimp+
        done
        subgoal
          apply rule+
          apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))) "])
             defer apply wpsimp apply wpsimp apply wpsimp
          apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) ∧
                            r = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) )"])
             defer apply wpsimp+
          done
        subgoal
          apply rule+
          subgoal
            apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))) "])
               defer apply wpsimp+
            apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) ∧
                            r = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) )"])
               defer apply wpsimp+
            unfolding returnOk_def 
            apply wpsimp
          done
          apply rule+
            apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr))) "])
              defer apply wpsimp+
            apply (rule corres_symb_exec_r[where Q' = "(λr s. bus_valid busPtr s ∧ actorPluginInfosEqual apil actorsPtr s ∧ ret' = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) ∧
                            r = sint (ActorPluginInfoVector_C.length_C (heap_ActorPluginInfoVector_C s actorsPtr)) )"])
              defer apply wpsimp+
         done
       done
     apply (insert des_impl_updateActorPluginState )
     unfolding corres_underlying_def actorPluginInfosEqual_def
     apply (simp add: case_prod_unfold)
     apply auto  
     subgoal for aa bb baa aaa bba
       by (metis fst_conv snd_conv)
     subgoal for aa bb baa aaa bba
       by (metis fst_conv snd_conv)
     done
   done
  done
  done
     

subsection ‹getActorPluginState verify›

lemma des_impl_getActorPluginState_aux0: 
  " stringEqual plugName aPluginName ⟹
       no_fail (λs. bus_valid busPtr s ∧  0 ≤ fst r' ∧
                     fst r' &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)))
                (condition (λs. compare' s pn aPluginName = 0 ∧ sint po = actID)
                        (do sta &lt;- getState' (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> fst r');
                            throwError (fst r', sta)
                         od)
                        (do y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
                            returnOk (fst r' + 1, snd r')
                         od))"
  apply wpsimp
  apply (rule non_fail_condition)
  apply auto
  unfolding throwError_def returnOk_def getState'_def
  apply wpsimp
  unfolding bus_valid_def pluginList_valid_def
  apply auto
  by wpsimp

lemma des_impl_getActorPluginState: 
  " stringEqual plugName aPluginName ⟹
    corres_underlying ({(t,s). busPtrEqual busPtr s (fst t)}) False False
      (λretDes retImpl. statePluginEqual retDes retImpl )
        (λ_. True) (λs. bus_valid busPtr s) 
      (Des_getActorPluginState plugName actID) (Impl_getActorPluginState busPtr aPluginName actID )"
  unfolding Des_getActorPluginState_def Impl_getActorPluginState_def
  apply wpsimp
  apply(rule corres_symb_exec_r[where Q' = "(λ_ s.  bus_valid busPtr s)"])
     defer apply wpsimp+   
  apply(rule corres_underlying_split[where P = "λ_ _. True" and P' = "λ_ s. bus_valid busPtr s" 
              and r' = "λrDes rImpl. statePluginEqual (snd rDes) (snd rImpl) ∧ int (fst rDes) = (fst rImpl) " ])
     defer apply wpsimp
  subgoal
    unfolding case_prod_unfold
    apply(subst whileLoopE_add_inv
            [where I="λ(i,sta) s. 0 ≤ i ∧ i ≤ sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) 
                                ∧ bus_valid busPtr s " 
              and M="λ((i,sta),s). nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) - i)"])
    apply wpsimp
    unfolding throwError_def returnOk_def validE_def getState'_def bus_valid_def
    by wpsimp+
   apply auto
  unfolding catch_def
  apply(rule corres_underlying_split[where r' = "(λe e'. statePluginEqual (snd e) (snd e') ∧ int (fst e) = (fst e')) ⊕ 
                                                 (λb b'. statePluginEqual (snd b) (snd b') ∧ int (fst b) = (fst b')) " 
                                       and P = "(λ_ _. True)" and P' = "(λ_ s. bus_valid busPtr s) "])
     defer apply wpsimp
  subgoal
    unfolding case_prod_unfold
    apply(subst whileLoopE_add_inv
            [where I="λ(i,sta) s. 0 ≤ i ∧ i ≤ sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) 
                                ∧ bus_valid busPtr s " 
              and M="λ((i,sta),s). nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) - i)"])
    apply wpsimp
    unfolding throwError_def returnOk_def validE_def getState'_def bus_valid_def
    by wpsimp+
  apply auto
  apply(case_tac "x") 
  apply auto
  unfolding case_prod_unfold
  apply(rule corres_whileLoopE)
  subgoal for r r' s s'
    apply (case_tac "r") 
    unfolding busPtrEqual_def int32Equal_def
    by auto 
  subgoal for r r'
    unfolding case_prod_unfold
    apply(rule corres_symb_exec_r[where Q' = "(λ_ s.  bus_valid busPtr s)"])
       defer apply wpsimp+
    apply(rule corres_symb_exec_r[where Q' = "(λ_ s.  bus_valid busPtr s)"])
       defer apply wpsimp+
    apply(rule corres_symb_exec_r[where Q' = "(λret s.  bus_valid busPtr s ∧ ret = 
                 heap_w8'ptr s (PTR(8 word ptr) &amp;(busPtr→[''pluginName_C'']) +<span class="hidden">⇩</span><sub>p</sub> fst r'))"])
       defer apply wpsimp+
    subgoal for pn
    apply(rule corres_symb_exec_r[where Q' = "(λret s.  bus_valid busPtr s ∧ pn = 
                 heap_w8'ptr s (PTR(8 word ptr) &amp;(busPtr→[''pluginName_C'']) +<span class="hidden">⇩</span><sub>p</sub> fst r'))"])
         defer apply wpsimp+
    apply(rule corres_symb_exec_r[where Q' = "(λret s.  bus_valid busPtr s ∧ ret = 
             heap_w64 s (PTR_COERCE(64 signed word → 64 word) (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub> fst r'))∧ 
              pn =  heap_w8'ptr s (PTR(8 word ptr) &amp;(busPtr→[''pluginName_C'']) +<span class="hidden">⇩</span><sub>p</sub> fst r'))"])
         defer apply wpsimp+
      apply (rule corres_condition_P)
        apply auto
      unfolding busPtrEqual_def  stringPtrListEqual_def int64PtrListEqual_def
      using compare_string  apply fastforce
      apply auto
      apply (metis compare_string_1)
      subgoal for po
        apply(rule corres_underlying_split[where r' = "(λb b'. statePluginEqual b b') " 
                and P = "(λ_ _. True)" and P' = "(λ_ s. bus_valid busPtr s) "])
        subgoal 
          unfolding getPlugState_def getState'_def
          apply(rule corres_symb_exec_r[where Q' = "(λret s.  bus_valid busPtr s ∧ po = 
             heap_w64 s (PTR_COERCE(64 signed word → 64 word) (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub> fst r'))∧ 
              pn =  heap_w8'ptr s (PTR(8 word ptr) &amp;(busPtr→[''pluginName_C'']) +<span class="hidden">⇩</span><sub>p</sub> fst r'))"])
          unfolding K_bind_def pluginPtrListEqual_def pluginEqual_def
             defer apply wpsimp+
          by metis
        unfolding getPlugState_def getState'_def 
        by wpsimp+
      subgoal for po
      apply(rule corres_symb_exec_r[where Q' = "(λret s.  bus_valid busPtr s ∧ po = 
             heap_w64 s (PTR_COERCE(64 signed word → 64 word) (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub> fst r'))∧ 
              pn =  heap_w8'ptr s (PTR(8 word ptr) &amp;(busPtr→[''pluginName_C'']) +<span class="hidden">⇩</span><sub>p</sub> fst r'))"])
        unfolding returnOk_def
        by wpsimp+
      done
    done
    apply wpsimp
  subgoal for r'
    apply wpsimp
    unfolding throwError_def returnOk_def validE_def getState'_def
    by wpsimp+
  subgoal 
    unfolding statePluginEqual_def by auto
  subgoal for r'
    apply wpsimp
    apply (wpsimp wp:des_impl_getActorPluginState_aux0)
          apply wpsimp+  
    unfolding bus_valid_def pluginName_valid_def pluginOwner_valid_def
    by auto
  unfolding whileLoop_terminatesE_def throwError_def returnOk_def
  apply (rule whileLoop_terminates_inv[
                where I = "λ_ s.  bus_valid busPtr s  " 
                  and R = "measure' (λ(r,s). case r of Inl a ⇒ 0 |
                             Inr v ⇒ nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr))) - nat (fst v))"])
    apply auto unfolding NonDetMonad.lift_def getName'_def resume'_def setState'_def
                         getActorID'_def  bus_valid_def throwError_def getState'_def
  apply wpsimp 
  by auto


subsection ‹getActorPlugin verify›

definition input_aPluginStr_valid :: " GeneralBus_C ptr ⇒ GeneralPlugin_C ptr ⇒ bool "
  where "input_aPluginStr_valid busPtr aPluginStr ≡ 
          ∀r. (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C''])) +<span class="hidden">⇩</span><sub>p</sub> r ≠ aPluginStr"

lemma input_aPluginStr_valid_aux0:
  " input_aPluginStr_valid busPtr aPluginStr ⟹
       stringEqual plugName aPluginName ⟹
       no_fail (λs. bus_valid busPtr s ∧ is_valid_GeneralPlugin_C s aPluginStr ∧
                     0 ≤ r' ∧ r' &lt; sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)))
        (condition (λs. sint po = actID ∧ compare' s pn aPluginName = 0 )
          (do y &lt;- guard (λs. is_valid_GeneralPlugin_C s aPluginStr);
              y &lt;- guard (λs. is_valid_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r'));
              y &lt;-
              modify
               (λs. heap_GeneralPlugin_C_update
                      (λa. a(aPluginStr :=
                                heap_GeneralPlugin_C s (PTR(GeneralPlugin_C) &amp;(busPtr→[''pluginList_C'']) +<span class="hidden">⇩</span><sub>p</sub> r')))
                      s);
              throwError r'
           od)
          (do y &lt;- guard (λs. is_valid_GeneralBus_C s busPtr);
              returnOk (r' + 1)
           od))"
  apply wpsimp
  apply (rule non_fail_condition)
  apply auto
  apply wpsimp
  unfolding bus_valid_def pluginList_valid_def
  apply auto
  by wpsimp

lemma des_impl_getActorPlugin : 
  " input_aPluginStr_valid busPtr aPluginStr ⟹
    stringEqual plugName aPluginName ⟹
    corres_underlying ({(t,s). busPtrEqual busPtr s (fst t)}) False False
      (λretDes retImpl. (snd retDes = True ∧ retImpl = 1)∨(snd retDes = False ∧ retImpl = 0))
        (λ_. True) (λs. bus_valid busPtr s ∧ is_valid_GeneralPlugin_C s aPluginStr) 
      (Des_getActorPlugin actID plugName) (Impl_getActorPlugin busPtr actID aPluginName aPluginStr)"
  unfolding Des_getActorPlugin_def Impl_getActorPlugin_def
  apply(rule corres_symb_exec_r[where Q' = "(λ_ s. bus_valid busPtr s ∧ is_valid_GeneralPlugin_C s aPluginStr )"])
  defer apply wpsimp+
  apply(rule corres_underlying_split[where P = "λ_ _. True" and P' = "λ_ s. bus_valid busPtr s ∧ is_valid_GeneralPlugin_C s aPluginStr" 
              and r' = "λrDes rImpl. int (fst rDes) = rImpl" ])
  defer apply wpsimp
  subgoal 
  apply(subst whileLoopE_add_inv
            [where I="λi s. 0 ≤ i ∧ i ≤ sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) ∧ bus_valid busPtr s
                              ∧ is_valid_GeneralPlugin_C s aPluginStr" 
              and M="λ(i,s). nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) - i)"])
    apply wpsimp unfolding validE_def throwError_def returnOk_def
      apply wpsimp unfolding bus_valid_def pluginOwner_valid_def pluginList_valid_def pluginName_valid_def
    by auto
  subgoal 
    apply auto
    apply (rule corres_condition)
    unfolding busPtrEqual_def int32Equal_def pluginPtrListEqual_def
    by auto
  unfolding catch_def
  apply(rule corres_underlying_split[where r' = "(λe e'. int (fst e) = e') ⊕ (λb b'. int (fst b) = b') " 
                                       and P = "(λ_ _. True)" and P' = "(λ_ s. bus_valid busPtr s ∧ is_valid_GeneralPlugin_C s aPluginStr) "])
     defer 
     apply wpsimp
  subgoal
    apply(subst whileLoopE_add_inv
            [where I="λi s. 0 ≤ i ∧ i ≤ sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) ∧ bus_valid busPtr s 
                            ∧ is_valid_GeneralPlugin_C s aPluginStr" 
              and M="λ(i,s). nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr)) - i)"])
    apply wpsimp unfolding validE_def throwError_def returnOk_def
      apply wpsimp unfolding bus_valid_def pluginOwner_valid_def pluginList_valid_def pluginName_valid_def
    by auto
   apply auto
  subgoal for x xa
    apply (case_tac "x")
    by auto
  apply(rule corres_whileLoopE)
  subgoal for r r' s s'
    apply (case_tac "r")
    apply auto
    unfolding busPtrEqual_def int32Equal_def
    by auto 
  subgoal for r r'
    unfolding case_prod_unfold
    apply(rule corres_symb_exec_r[where Q' = "(λ_ s.  bus_valid busPtr s ∧ is_valid_GeneralPlugin_C s aPluginStr)"])
       defer apply wpsimp+
    apply(rule corres_symb_exec_r[where Q' = "(λ_ s.  bus_valid busPtr s ∧ is_valid_GeneralPlugin_C s aPluginStr)"])
       defer apply wpsimp+
    apply(rule corres_symb_exec_r[where Q' = "(λret s.  bus_valid busPtr s ∧ is_valid_GeneralPlugin_C s aPluginStr ∧ ret = 
        heap_w64 s (PTR_COERCE(64 signed word → 64 word) (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub> r')))"])
       defer apply wpsimp+
    subgoal for po
    apply(rule corres_symb_exec_r[where Q' = "(λret s.  bus_valid busPtr s ∧ is_valid_GeneralPlugin_C s aPluginStr ∧ po = 
        heap_w64 s (PTR_COERCE(64 signed word → 64 word) (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub> r')))"])
       defer apply wpsimp+
    apply(rule corres_symb_exec_r[where Q' = "(λret s.  bus_valid busPtr s ∧ is_valid_GeneralPlugin_C s aPluginStr ∧ ret = 
         heap_w8'ptr s (PTR(8 word ptr) &amp;(busPtr→[''pluginName_C'']) +<span class="hidden">⇩</span><sub>p</sub> int (fst r)) ∧ po = 
        heap_w64 s (PTR_COERCE(64 signed word → 64 word) (PTR(64 signed word) &amp;(busPtr→[''pluginOwner_C'']) +<span class="hidden">⇩</span><sub>p</sub> r')))"])
         defer apply wpsimp+
    apply (rule corres_condition_P)
      subgoal for pn
        unfolding busPtrEqual_def int64PtrListEqual_def stringPtrListEqual_def
        apply auto
        using compare_string apply blast
        using compare_string_1 by blast 
      subgoal for pn
        apply(rule corres_symb_exec_r[where Q' = "(λ_ s.  bus_valid busPtr s ∧ is_valid_GeneralPlugin_C s aPluginStr)"])
           defer apply wpsimp+
        apply(rule corres_symb_exec_r[where Q' = "(λ_ s.  bus_valid busPtr s ∧ is_valid_GeneralPlugin_C s aPluginStr)"])
           defer apply wpsimp+
        apply(rule corres_underlying_split[where r' = "(λ_ _. True) " 
                                       and P = "(λ_ _. True)" 
                                       and P' = "(λ_ s. bus_valid busPtr s ∧ is_valid_GeneralPlugin_C s aPluginStr) "])
           apply auto
         defer apply wpsimp
        subgoal for s 
          unfolding bus_valid_def pluginOwner_valid_def pluginList_valid_def pluginName_valid_def
          by auto
        unfolding corres_underlying_def modify_def gets_def get_def put_def return_def NonDetMonad.bind_def
        unfolding input_aPluginStr_valid_def busPtrEqual_def pluginPtrListEqual_def int64PtrListEqual_def pluginEqual_def stringPtrListEqual_def
        by auto
      subgoal for pn
        apply(rule corres_symb_exec_r[where Q' = "(λ_ s.  bus_valid busPtr s ∧ is_valid_GeneralPlugin_C s aPluginStr)"])
           defer apply wpsimp+
        unfolding returnOk_def
        by auto
      done
    done
  apply wp
      apply auto
  subgoal for r'
    apply wpsimp
    unfolding validE_def throwError_def returnOk_def
     apply wpsimp
    unfolding bus_valid_def pluginOwner_valid_def pluginList_valid_def pluginName_valid_def
    by auto
  subgoal for r'
    apply wpsimp
          apply (wpsimp wp:input_aPluginStr_valid_aux0)
         apply wpsimp+ 
    unfolding bus_valid_def pluginOwner_valid_def pluginList_valid_def pluginName_valid_def
    by auto
  unfolding whileLoop_terminatesE_def throwError_def returnOk_def
  apply (rule whileLoop_terminates_inv[
                where I = "λ_ s.  bus_valid busPtr s  " 
                  and R = "measure' (λ(r,s). case r of Inl a ⇒ 0 |
                             Inr v ⇒ nat (sint (nRegisteredPlugin_C (heap_GeneralBus_C s busPtr))) - nat v)"])
  apply auto unfolding NonDetMonad.lift_def getName'_def resume'_def setState'_def getActorID'_def  bus_valid_def
  apply wpsimp
  apply auto
    apply (case_tac "r")
     apply auto
     unfolding pluginOwner_valid_def  pluginList_valid_def pluginName_valid_def
     by auto


end</pre></body>